{
    "generation": "      @Override\n      public boolean apply(Node n) {\n        // When the node is null it means, we reached the implicit return\n        // where the function returns (possibly without an return statement)\n        if (n == null) {\n          return false;\n        }\n\n        // Check for binary ops that contain a property lookup on its left hand\n        // side\n        if (n.isBinaryOp() &&\n            NodeUtil.mightHaveSideEffectInExprResult(\n                  n,\n                  Predicates.instanceOf(Node.class).named(\"ObjectPropertyGetter\", Predicates.or(\n                           Predicates.instanceOf(Token.class),\n                           Predicates.instanceOf(Node.class)), true/*allowUnknown*/)\n              /*NodeUtil.isPropertyLookup(n.getFirstChild()) */,\n            this.name) //\n        {\n            return true;\n        }\n\n\n        if (n.isCall() && NodeUtil.functionCallHasSideEffects(n)) {\n          return true;\n        }\n\n        if (n.isNew() && NodeUtil.constructorCallHasSideEffects(n)) {\n          return true;\n        }\n\n        if(NodeUtil.receivesExternObjectData(n)) {\n        \treturn true;\n        }\n        /**\n         * Added here: inline variables from if, which, else where and cases\n         *\n         *\n         */\n\n//        int type = this.nodeWithInlineableAssignmentsTypes.get(this.firstParentStatement);\n        this.checkSwitch(n);\n\n         if (!(n.getParent()==null))\n\n        if(isInsideNewScopeBlock()){\n        \taddToBlackOrGreyTree(n);\n\n\t\t\tFlowSensitiveInlineVariableTraverse.traverseOneStatementLeftToRight2(\n\t\t\t\t\t  n.getNext()\n\n\t\t\t\t\t  )\n\n\t\t};\n        //\n\n        //    System.err.println(node)\n        Node c1 ;\n        Set<Node> treeToParent = Sets.newHashSet(Arrays.asList(n,n.getChildren()));\n\n\t\t\t\tfor ( Node c:\n\t\t\t\t\t\ttreeToParent )\n\n\t/*\t\tif\n\t\t\t node is blackTree  blackTreeChildren will not use it\n\t\t  c  use black Tree as it might be called without this traverse\n\t\t\t\t inline to value\n\t\t  use this set to updateBlackTree   */\n\n           \t\tInlineWithoutBlackNodeByFlowContext(c);\n\n\t\t  updateBlackInTreeWithoutDelete(\n          c1=getBlackLeaf(c)\n          ,\"insetBlacktreeNoDeleet\"\n         ,\"testInlineSideEffectCallInsideVar\"\n\n\n          );\n\n           treeToParent.addAll(getFromParentFirstChildren2Children(\n    c,\n\t\t\t\t\t c.getNodeType()))\n\n\t\t\t\t\t\t\ttreeToParent.removeAll(Predicates.instanceOf(Node.class)\n               .named(nodeToItsParent2InlineTree)\n\n\n\t\t\t\t);\n\n        return getTranverseFlagInline();\n\n }",
    "exact_match": false,
    "ast_match": false,
    "compile": false,
    "test": false
}