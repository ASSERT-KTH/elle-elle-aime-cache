{
    "generation": "private boolean isQualifiedNameInferred(\n    String qName, Node n, JSDocInfo info,\n    Node rhsValue, JSType valueType) {\n\n  if (valueType == null) {\n    return true;\n  }\n\n  // Prototypes are inferred, except for constructors and native types.\n  if (qName != null && qName.endsWith(\".prototype\")) {\n    if (info != null && info.isConstructor() || valueType.isNativeType()) {\n      return false;\n    }\n    return true;\n  }\n\n  boolean inferred = true;\n  if (info != null) {\n    inferred = !(info.hasType()\n        || info.hasEnumParameterType()\n        || (isConstantSymbol(info, n) && valueType != null\n              && !valueType.isUnknownType())\n        || FunctionTypeBuilder.isFunctionTypeDeclaration(info));\n  }\n\n  if (inferred && rhsValue != null && rhsValue.isFunction()) {\n    if (info != null) {\n      return false;\n    } else if (n.isUnscopedQualifiedName()) {\n      // Check if this is in a conditional block or assigned in an inner scope.\n      // Functions assigned in these contexts are inferred.\n      Node current = n.getParent();\n      while(!(current.isScript() || current.isFunction())) {\n        if(NodeUtil.isControlStructure(current)) {\n          return true;\n        }\n        if(current.isFunction()) {\n          AstFunctionContents contents = getFunctionAnalysisResults(current);\n          if (contents != null &&\n              contents.getEscapedQualifiedNames().contains(qName)) {\n            return true;\n          }\n        }\n        current = current.getParent();\n      }\n      if (!scope.isDeclared(qName, false)) {\n        return false;\n      }\n    }\n  }\n  return inferred;\n}",
    "exact_match": false,
    "ast_match": false,
    "compile": false,
    "test": false
}