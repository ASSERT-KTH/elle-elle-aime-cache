{
    "generation": "/**\n * Gets the millisecond offset to subtract from local time to get UTC time.\n * This offset can be used to undo adding the offset obtained by getOffset.\n *\n * <pre>\n * millisLocal == millisUTC   + getOffset(millisUTC)\n * millisUTC   == millisLocal - getOffsetFromLocal(millisLocal)\n * </pre>\n *\n * NOTE: After calculating millisLocal, some error may be introduced. At\n * offset transitions (due to DST or other historical changes), ranges of\n * local times may map to different UTC times.\n * <p>\n * This method will return an offset suitable for calculating an instant\n * after any DST gap. For example, consider a zone with a cutover\n * from 01:00 to 01:59:<br />\n * Input: 00:00  Output: 00:00<br />\n * Input: 00:30  Output: 00:30<br />\n * Input: 01:00  Output: 02:00<br />\n * Input: 01:30  Output: 02:30<br />\n * Input: 02:00  Output: 02:00<br />\n * Input: 02:30  Output: 02:30<br />\n * <p>\n * During a DST overlap (where the local time is ambiguous) this method will return\n * the earlier instant. The combination of these two rules is to always favour\n * daylight (summer) time over standard (winter) time.\n * <p>\n * NOTE: Prior to v2.0, the DST overlap behaviour was not defined and varied by hemisphere.\n * Prior to v1.5, the DST gap behaviour was also not defined.\n *\n * @param instantLocal  the millisecond instant, relative to this time zone, to get the offset for\n * @return the millisecond offset to subtract from local time to get UTC time\n */\npublic int getOffsetFromLocal(long instantLocal) {\n    // Get the initial offset at the local instant\n    final int initialOffset = getOffset(instantLocal);\n    \n    // Adjust the local instant using the initial offset to estimate UTC\n    final long adjustedUtc = instantLocal - initialOffset;\n    \n    // Recalculate the offset using the adjusted UTC time\n    final int offsetFromUtc = getOffset(adjustedUtc);\n    \n    // If the offsets differ, handle DST transition\n    if (initialOffset != offsetFromUtc) {\n        // Determine the direction of the offset change\n        if ((initialOffset - offsetFromUtc) < 0) {\n            // If offset decreased (e.g., from daylight to standard time)\n            // Ensure time is after the DST gap\n            long nextLocalTransition = nextTransition(instantLocal);\n            long nextUtcTransition = nextTransition(adjustedUtc);\n            \n            // If transitions differ, use the initial offset\n            if (nextLocalTransition != nextUtcTransition) {\n                return initialOffset;\n            }\n        } else {\n            // If offset increased, favor daylight time\n            return initialOffset;\n        }\n    }\n    \n    // If offsets are the same, return the offset from UTC\n    return offsetFromUtc;\n}",
    "exact_match": false,
    "ast_match": false,
    "compile": true,
    "test": false
}