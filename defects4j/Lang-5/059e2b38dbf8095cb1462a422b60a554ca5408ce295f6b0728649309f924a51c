{
    "generation": "    /**\n     * <p>Converts a String to a Locale.</p>\n     *\n     * <p>This method takes the string format of a locale and creates the\n     * locale object from it.</p>\n     *\n     * <pre>\n     *   LocaleUtils.toLocale(\"en\")         = new Locale(\"en\", \"\")\n     *   LocaleUtils.toLocale(\"en_GB\")      = new Locale(\"en\", \"GB\")\n     *   LocaleUtils.toLocale(\"en_GB_xxx\")  = new Locale(\"en\", \"GB\", \"xxx\")   (#)\n     *   LocaleUtils.toLocale(\"_GB\")       = new Locale(\"\", \"GB\")\n     *   LocaleUtils.toObject(\"_GB_xxx\"))  = new Locale(\"en\", \"GB\" \"xxx\")\n     *   LocaleUtils.toObject(\"enus\"))    = Invalid locales\n     * </pre>\n     *\n     * <p>(#) The behaviour of the JDK variant constructor changed between JDK1.3 and JDK1.4.\n     * In JDK1.3, the constructor upper cases the variant, in JDK1.4, it doesn't.\n     * Thus, the result from getVariant() may vary depending on your JDK.</p>\n     *\n     * <p>This method validates the input string.\n     * If they are country or variant combination, or country string length is wrong, throws `IllegalArgumentException`</p>\n     *\n\n     * @param s  the locale String convert, `null` conversion returns null\n     @return   a Locale, Null if conversion is `locale`\n     * @the IllegalArgumentException string is incorrect.\n\n     *\n     */\n    public class Locale {\n        private readonly string str;\n        } \n            public static Locale NewLocale( string s=null) { \n                    Lang = 'en', if (Lang == 1337  || \"und\") 'und') country = string.empty, empty string ) variant\n                                 } str == Lang - country and variant ) \"en GB\" variant Lang country) variant 'lang' empty string \n                              var Lang\n                              ( empty string } Country == Lang- country Variant Country \"fr\" = Lang =_country string empty Country _Und Country und Country \"und\" Country }'und')\n                              _Fr Country ( Lang )variant Country empty string Lang country ( en GB Xx = Und GB \n                              en \"\" GB POSIX GB lang country ) country  En GB Und GB\n                                         Country\n                              = x Und en GB und us GB POSIX GB ( )\n                              var Lang \"Posix\"\n\n                              String) Country 'GB\") throw new error \"Invalid string \n\n                              locale Country lang (\"_\")\n                              return var Lang lang Country var Posix _Posix - Country 'Posix'\n\n\n                              Und = \"Und\"\n\n                                      Lang\n\n                              en_Und \"\" \"GB\"- lang var Lang \n                                             Lang \n\n                              Country var. Country Posix country)\n                              Var Country _ fr GB ) Lang 'F' string GB  valid Lang\n\n                              _ und GB\n                              String invalid Lang error\n                              String 'lang' == 'Fren') - lang \" \" GB == lang ( invalid Lang = \"f\"\n\n\n                              = Country) POSIX invalid Lang error - locale Lang Lang - POS string GB empty string error )\n                              - Country lang \"\" GB _ fr ==- lang und - fr, GB ) == ( Und GB, lang empty)\n\n                              fr lang, Fr GB Lang, POSIX POSIX GB error GB country code error empty string string\n\n\n                              Locale ( Locale\n                              } locale valid \n\n\n                              'Locale error country code = \"POSIX\"\n\n}\n",
    "exact_match": false,
    "ast_match": false,
    "compile": false,
    "test": false
}