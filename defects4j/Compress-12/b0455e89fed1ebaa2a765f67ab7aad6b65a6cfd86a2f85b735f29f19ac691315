{
    "generation": "    public TarArchiveEntry getNextTarEntry() throws IOException {\n        if (hasHitEOF) {\n            return null;\n        }\n\n        if (currEntry != null) {\n            long numToSkip = entrySize - entryOffset;\n\n            while (numToSkip > 0) {\n                long skipped = skip(numToSkip);\n                if (skipped <= 0) {\n                    throw new RuntimeException(\"failed to skip current tar entry\");\n                }\n                numToSkip -= skipped;\n            }\n\n            readBuf = null;\n        }\n\n        // Read the next header record\n        byte[] headerBuf = getRecord();\n        if (headerBuf == null || headerBuf.length == 0) {\n            hasHitEOF = true;\n        }\n\n        if (hasHitEOF) {\n            currEntry = null;\n            return null;\n        }\n\n        try {\n            currEntry = new TarArchiveEntry(headerBuf);\n        } catch (IllegalArgumentException e) {\n            throw new IOException(\"Invalid tar archive entry header\", e);\n        }\n\n        entryOffset = 0;\n        entrySize = currEntry.getSize();\n\n        if (currEntry.isGNULongNameEntry()) {\n            // Read in the name\n            StringBuffer longName = new StringBuffer();\n            byte[] buf = new byte[SMALL_BUFFER_SIZE];\n            int length = 0;\n            while ((length = read(buf)) >= 0) {\n                longName.append(new String(buf, 0, length));\n            }\n\n            // Recursively call to skip the long name entry and parse the actual entry\n            getNextTarEntry();\n\n            if (currEntry == null) {\n                // Bugzilla 40334: Malformed tar file - long entry name not followed by entry\n                return null;\n            }\n\n            // Remove trailing null terminator\n            if (longName.length() > 0 && longName.charAt(longName.length() - 1) == '\\0') {\n                longName.deleteCharAt(longName.length() - 1);\n            }\n            currEntry.setName(longName.toString());\n        }\n\n        if (currEntry.isPaxHeader()) { // Process Pax headers\n            paxHeaders();\n        }\n\n        if (currEntry.isGNUSparse()) { // Process sparse files\n            readGNUSparse();\n        }\n\n        // Update entry size in case it changed due to new size reported in headers\n        entrySize = currEntry.getSize();\n        return currEntry;\n    }",
    "exact_match": false,
    "ast_match": false,
    "compile": true,
    "test": false
}