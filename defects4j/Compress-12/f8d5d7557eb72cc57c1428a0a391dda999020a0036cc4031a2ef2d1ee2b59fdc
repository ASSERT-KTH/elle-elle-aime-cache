{
    "generation": "public TarArchiveEntry getNextTarEntry() throws IOException {\n    if (hasHitEOF) {\n        return null;\n    }\n\n    if (currEntry != null) {\n        long numToSkip = entrySize - entryOffset;\n\n        while (numToSkip > 0) {\n            long skipped = skip(numToSkip);\n            if (skipped <= 0) {\n                throw new RuntimeException(\"failed to skip current tar entry\");\n            }\n            numToSkip -= skipped;\n        }\n\n        readBuf = null;\n    }\n\n    byte[] headerBuf = getRecord();\n\n    if (hasHitEOF) {\n        currEntry = null;\n        return null;\n    }\n\n    currEntry = new TarArchiveEntry(headerBuf);\n    entryOffset = 0;\n    entrySize = currEntry.getSize();\n\n    if (currEntry.isGNULongNameEntry()) {\n        // Read the entire long name into a byte array\n        ByteArrayOutputStream byteStream = new ByteArrayOutputStream();\n        byte[] buf = new byte[SMALL_BUFFER_SIZE];\n        int length;\n        while ((length = read(buf)) > 0) {\n            byteStream.write(buf, 0, length);\n        }\n        byte[] longNameBytes = byteStream.toByteArray();\n\n        // Find the null terminator\n        int nullIndex = -1;\n        for (int i = 0; i < longNameBytes.length; i++) {\n            if (longNameBytes[i] == 0) {\n                nullIndex = i;\n                break;\n            }\n        }\n\n        // Extract the name up to the null terminator\n        byte[] nameBytes;\n        if (nullIndex != -1) {\n            nameBytes = Arrays.copyOfRange(longNameBytes, 0, nullIndex);\n        } else {\n            nameBytes = longNameBytes;\n        }\n\n        // Convert bytes to string using UTF-8 encoding\n        String longName = new String(nameBytes, StandardCharsets.UTF_8);\n\n        // Set the name in the current entry\n        currEntry.setName(longName);\n\n        // Read the next entry header\n        getNextEntry();\n        if (currEntry == null) {\n            // Malformed tar file - long entry name not followed by entry\n            return null;\n        }\n    }\n\n    if (currEntry.isPaxHeader()) { // Process Pax headers\n        paxHeaders();\n    }\n\n    if (currEntry.isGNUSparse()) { // Process sparse files\n        readGNUSparse();\n    }\n\n    // Update entrySize if the size has changed due to posix header information\n    entrySize = currEntry.getSize();\n    return currEntry;\n}",
    "exact_match": false,
    "ast_match": false,
    "compile": false,
    "test": false
}