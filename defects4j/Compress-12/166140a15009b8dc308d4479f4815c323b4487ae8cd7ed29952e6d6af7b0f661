{
    "generation": "/**\n * Get the next entry in this tar archive. This will skip\n * over any remaining data in the current entry, if there\n * is one, and place the input stream at the header of the\n * next entry, and read the header and instantiate a new\n * TarEntry from the header bytes and return that entry.\n * If there are no more entries in the archive, null will\n * be returned to indicate that the end of the archive has\n * been reached.\n *\n * @return The next TarEntry in the archive, or null.\n * @throws IOException on error\n */\npublic TarArchiveEntry getNextTarEntry() throws IOException {\n    if (hasHitEOF) {\n        return null;\n    }\n\n    if (currEntry!= null) {\n        long numToSkip = entrySize - entryOffset;\n\n        while (numToSkip > 0) {\n            long skipped = skip(numToSkip);\n            if (skipped <= 0) {\n                throw new RuntimeException(\"failed to skip current tar entry\");\n            }\n            numToSkip -= skipped;\n        }\n\n        readBuf = null;\n    }\n\n    byte[] headerBuf = getRecord();\n\n    if (hasHitEOF) {\n        currEntry = null;\n        return null;\n    }\n\n    if (headerBuf == null || headerBuf.length < TarArchiveEntry.RECORDSIZE) {\n        throw new IOException(\"Failed to read header\");\n    }\n\n    // check that the header byte at offset 257, 258, 259, 260, 265, 266, 271 and 272 \n    // contains only null bytes as per the POSIX standard.\n    for (int i = 257; i <= 260; i++) {\n        if (headerBuf[i]!= 0) {\n            throw new IOException(\"Invalid header - expected a null byte at offset \" + i);\n        }\n    }\n    for (int i = 265; i <= 266; i++) {\n        if (headerBuf[i]!= 0) {\n            throw new IOException(\"Invalid header - expected a null byte at offset \" + i);\n        }\n    }\n    for (int i = 271; i <= 272; i++) {\n        if (headerBuf[i]!= 0) {\n            throw new IOException(\"Invalid header - expected a null byte at offset \" + i);\n        }\n    }\n\n    currEntry = new TarArchiveEntry(headerBuf);\n    entryOffset = 0;\n    entrySize = currEntry.getSize();\n\n    if (currEntry.isGNULongNameEntry()) {\n        // read in the name\n        StringBuffer longName = new StringBuffer();\n        byte[] buf = new byte[SMALL_BUFFER_SIZE];\n        int length = 0;\n        while ((length = read(buf)) >= 0) {\n            longName.append(new String(buf, 0, length));\n        }\n        getNextEntry();\n        if (currEntry == null) {\n            // Bugzilla: 40334\n            // Malformed tar file - long entry name not followed by entry\n            return null;\n        }\n        // remove trailing null terminator\n        if (longName.length() > 0\n            && longName.charAt(longName.length() - 1) == 0) {\n            longName.deleteCharAt(longName.length() - 1);\n        }\n        currEntry.setName(longName.toString());\n    }\n\n    if (currEntry.isPaxHeader()){ // Process Pax headers\n        paxHeaders();\n    }\n\n    if (currEntry.isGNUSparse()){ // Process sparse files\n        readGNUSparse();\n    }\n\n    // If the size of the next element in the archive has changed\n    // due to a new size being reported in the posix header\n    // information, we update entrySize here so that it contains\n    // the correct value.\n    entrySize = currEntry.getSize();\n    return currEntry;\n}",
    "exact_match": false,
    "ast_match": false,
    "compile": false,
    "test": false
}