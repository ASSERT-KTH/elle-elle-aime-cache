{
    "generation": "public static Number createNumber(final String str) throws NumberFormatException {\n    if (str == null) {\n        return null;\n    }\n    if (str.trim().isEmpty()) {\n        throw new NumberFormatException(\"A blank string is not a valid number\");\n    }\n    \n    // Handle hexadecimal prefixes\n    String[] hexPrefixes = {\"0x\", \"0X\", \"-0x\", \"-0X\", \"#\", \"-#\"};\n    int pfxLen = 0;\n    for (String pfx : hexPrefixes) {\n        if (str.startsWith(pfx)) {\n            pfxLen = pfx.length();\n            break;\n        }\n    }\n    if (pfxLen > 0) {\n        String numStr = str.substring(pfxLen);\n        try {\n            long num = Long.parseLong(numStr, 16);\n            return num;\n        } catch (NumberFormatException e) {\n            return new BigInteger(numStr, 16);\n        }\n    }\n    \n    // Check for type specifiers\n    char lastChar = str.charAt(str.length() - 1);\n    if (!Character.isDigit(lastChar) && lastChar != '.') {\n        String numeric = str.substring(0, str.length() - 1);\n        switch (lastChar) {\n            case 'f':\n            case 'F':\n                try {\n                    float f = Float.parseFloat(numeric);\n                    if (!Float.isInfinite(f)) {\n                        return f;\n                    }\n                } catch (NumberFormatException e) {\n                    // Ignore\n                }\n                // Fall through to double\n            case 'd':\n            case 'D':\n                try {\n                    double d = Double.parseDouble(numeric);\n                    if (!Double.isInfinite(d)) {\n                        return d;\n                    }\n                } catch (NumberFormatException e) {\n                    // Ignore\n                }\n                return new BigDecimal(numeric);\n            case 'l':\n            case 'L':\n                try {\n                    return Long.parseLong(numeric);\n                } catch (NumberFormatException e) {\n                    return new BigInteger(numeric);\n                }\n            default:\n                throw new NumberFormatException(str + \" is not a valid number.\");\n        }\n    }\n    \n    // No type specifier, determine the type based on content\n    if (str.contains(\".\")) {\n        try {\n            float f = Float.parseFloat(str);\n            if (!Float.isInfinite(f)) {\n                return f;\n            }\n        } catch (NumberFormatException e) {\n            // Ignore\n        }\n        try {\n            double d = Double.parseDouble(str);\n            if (!Double.isInfinite(d)) {\n                return d;\n            }\n        } catch (NumberFormatException e) {\n            // Ignore\n        }\n        return new BigDecimal(str);\n    } else {\n        try {\n            return Integer.parseInt(str);\n        } catch (NumberFormatException e) {\n            // Ignore\n        }\n        try {\n            return Long.parseLong(str);\n        } catch (NumberFormatException e) {\n            // Ignore\n        }\n        return new BigInteger(str);\n    }\n}",
    "exact_match": false,
    "ast_match": false,
    "compile": true,
    "test": false
}