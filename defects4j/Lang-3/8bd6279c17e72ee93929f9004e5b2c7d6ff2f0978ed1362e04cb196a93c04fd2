{
    "generation": "package org.apache.commons.lang3.math;\n\nimport org.apache.commons.lang3.StringUtils;\n\nimport java.math.BigDecimal;\nimport java.math.BigInteger;\nimport java.util.Arrays;\n\npublic class NumberUtils {\n\n    public static Number createNumber(final String str) throws NumberFormatException {\n        if (str == null) {\n            return null;\n        }\n        if (str.trim().isEmpty()) {\n            throw new NumberFormatException(\"A blank string is not a valid number\");\n        }\n\n        // Handle hexadecimal and octal formats\n        String cleanedStr = str;\n        int radix = 10;\n        if (str.startsWith(\"0x\") || str.startsWith(\"0X\") || str.startsWith(\"#\")) {\n            radix = 16;\n            cleanedStr = str.startsWith(\"#\") ? str.substring(1) : str.substring(2);\n        } else if (str.startsWith(\"-0x\") || str.startsWith(\"-0X\") || str.startsWith(\"-#\")) {\n            radix = 16;\n            cleanedStr = str.startsWith(\"-#\") ? str.substring(2) : str.substring(3);\n            cleanedStr = \"-\" + cleanedStr;\n        } else if (str.startsWith(\"0\") && str.length() > 1 && !str.startsWith(\"-0\")) {\n            radix = 8;\n            cleanedStr = str.substring(1);\n        }\n\n        // Check for type qualifiers\n        char lastChar = cleanedStr.charAt(cleanedStr.length() - 1);\n        if (isTypeQualifier(lastChar)) {\n            String numeric = cleanedStr.substring(0, cleanedStr.length() - 1);\n            switch (lastChar) {\n                case 'l':\n                case 'L':\n                    try {\n                        return Long.parseLong(numeric, radix);\n                    } catch (NumberFormatException e) {\n                        return new BigInteger(numeric, radix);\n                    }\n                case 'f':\n                case 'F':\n                    try {\n                        float f = Float.parseFloat(numeric);\n                        if (!Float.isInfinite(f) && !Float.isNaN(f)) {\n                            return f;\n                        }\n                    } catch (NumberFormatException e) {\n                        // Ignore and try next type\n                    }\n                    // Fall through to Double or BigDecimal\n                case 'd':\n                case 'D':\n                    try {\n                        double d = Double.parseDouble(numeric);\n                        if (!Double.isInfinite(d) && !Double.isNaN(d)) {\n                            return d;\n                        }\n                    } catch (NumberFormatException e) {\n                        // Ignore and try next type\n                    }\n                    try {\n                        return new BigDecimal(numeric);\n                    } catch (NumberFormatException e) {\n                        // Ignore and proceed to throw exception\n                    }\n                default:\n                    // Invalid type qualifier\n                    throw new NumberFormatException(str + \" is not a valid number.\");\n            }\n        }\n\n        // No type qualifier, determine type based on content\n        if (cleanedStr.contains(\".\") || cleanedStr.contains(\"e\") || cleanedStr.contains(\"E\")) {\n            // Floating point number\n            try {\n                BigDecimal bd = new BigDecimal(cleanedStr);\n                try {\n                    float f = bd.floatValue();\n                    BigDecimal fBd = new BigDecimal(Float.toString(f));\n                    if (bd.compareTo(fBd) == 0) {\n                        return f;\n                    }\n                } catch (NumberFormatException e) {\n                    // Ignore and try double\n                }\n                try {\n                    double d = bd.doubleValue();\n                    BigDecimal d Bd = new BigDecimal(Double.toString(d));\n                    if (bd.compareTo(dBd) == 0) {\n                        return d;\n                    }\n                } catch (NumberFormatException e) {\n                    // Ignore and return BigDecimal\n                }\n                return bd;\n            } catch (NumberFormatException e) {\n                throw new NumberFormatException(str + \" is not a valid number.\");\n            }\n        } else {\n            // Integral number\n            try {\n                return Integer.parseInt(cleanedStr, radix);\n            } catch (NumberFormatException e) {\n                try {\n                    return Long.parseLong(cleanedStr, radix);\n                } catch (NumberFormatException e1) {\n                    return new BigInteger(cleanedStr, radix);\n                }\n            }\n        }\n    }\n\n    private static boolean isTypeQualifier(char c) {\n        return Arrays.asList('f', 'F', 'd', 'D', 'l', 'L').contains(c);\n    }\n}",
    "exact_match": false,
    "ast_match": false,
    "compile": false,
    "test": false
}