{
    "generation": "/**\n * <p>Turns a string value into a java.lang.Number.</p>\n *\n *... (rest of the Javadoc remains the same)\n *\n * @param str  String containing a number, may be null\n * @return Number created from the string (or null if the input is null)\n * @throws NumberFormatException if the value cannot be converted\n */\npublic static Number createNumber(final String str) throws NumberFormatException {\n    if (str == null) {\n        return null;\n    }\n    if (StringUtils.isBlank(str)) {\n        throw new NumberFormatException(\"A blank string is not a valid number\");\n    }\n    //... (hex prefix handling remains the same)\n\n    final char lastChar = str.charAt(str.length() - 1);\n    String mant;\n    String dec;\n    String exp;\n    final int decPos = str.indexOf('.');\n    final int expPos = str.indexOf('e') + str.indexOf('E') + 1; // assumes both not present\n    //... (decimal and exponent handling remains the same)\n\n    if (!Character.isDigit(lastChar) && lastChar!= '.') {\n        //... (specific type handling remains the same)\n    } else {\n        // User doesn't have a preference on the return type, so let's start\n        // small and go from there...\n        if (expPos > -1 && expPos < str.length() - 1) {\n            exp = str.substring(expPos + 1, str.length());\n        } else {\n            exp = null;\n        }\n        if (dec == null && exp == null) { // no decimal point and no exponent\n            // Must be an Integer, Long, BigInteger\n            try {\n                return createInteger(str);\n            } catch (final NumberFormatException nfe) { // NOPMD\n                // ignore the bad number\n            }\n            try {\n                return createLong(str);\n            } catch (final NumberFormatException nfe) { // NOPMD\n                // ignore the bad number\n            }\n            return createBigInteger(str);\n        }\n\n        // Must be a Float, Double, BigDecimal\n        final boolean allZeros = isAllZeros(mant) && isAllZeros(exp);\n        try {\n            // Check for float precision loss\n            final Float f = createFloat(str);\n            if (!(f.isInfinite() || (f.floatValue() == 0.0F &&!allZeros) || hasPrecisionLoss(str, f.floatValue()))) {\n                return f;\n            }\n        } catch (final NumberFormatException nfe) { // NOPMD\n            // ignore the bad number\n        }\n        try {\n            // Check for double precision loss\n            final Double d = createDouble(str);\n            if (!(d.isInfinite() || (d.doubleValue() == 0.0D &&!allZeros) || hasPrecisionLoss(str, d.doubleValue()))) {\n                return d;\n            }\n        } catch (final NumberFormatException nfe) { // NOPMD\n            // ignore the bad number\n        }\n\n        return createBigDecimal(str);\n    }\n}\n\n// Helper method to detect precision loss\nprivate static boolean hasPrecisionLoss(String str, double value) {\n    BigDecimal bd = new BigDecimal(str);\n    return bd.compareTo(new BigDecimal(String.valueOf(value)))!= 0;\n}",
    "exact_match": false,
    "ast_match": false,
    "compile": false,
    "test": false
}