{
    "generation": "boolean process(Token t, TreeBuilder tb) {\n    switch (t.type) {\n        case Character: {\n            Token.Character c = t.asCharacter();\n            if (c.getData() == null || c.getData().equals(nullString)) { // Fix: Avoid comparing objects with equals. Check for null first.\n                tb.error(this);\n                return false;\n            } else if (isWhitespace(c)) {\n                tb.reconstructFormattingElements();\n                tb.insert(c);\n            } else {\n                tb.reconstructFormattingElements();\n                tb.insert(c);\n                tb.framesetOk(false);\n            }\n            break;\n        }\n        case Comment: {\n            tb.insert(t.asComment());\n            break;\n        }\n        case Doctype: {\n            tb.error(this);\n            return false;\n        }\n        case StartTag:\n            Token.StartTag startTag = t.asStartTag();\n            String name = startTag.name();\n            if (name.equals(\"html\")) {\n                tb.error(this);\n                Element html = tb.getStack().getFirst();\n                for (Attribute attribute : startTag.getAttributes()) {\n                    if (!html.hasAttr(attribute.getKey()))\n                        html.attributes().put(attribute);\n                }\n            } else if (StringUtil.in(name, \"base\", \"basefont\", \"bgsound\", \"command\", \"link\", \"meta\", \"noframes\", \"style\", \"title\")) {\n                tb.process(t, TreeBuilderState.InHead);\n            } else if (name.equals(\"body\")) {\n                tb.error(this);\n                LinkedList<Element> stack = tb.getStack();\n                if (stack.size() == 1 || (stack.size() > 2 && !stack.get(1).nodeName().equals(\"body\"))) {\n                    return false;\n                } else {\n                    tb.framesetOk(false);\n                    Element body = stack.get(1);\n                    for (Attribute attribute : startTag.getAttributes()) {\n                        if (!body.hasAttr(attribute.getKey()))\n                            body.attributes().put(attribute);\n                    }\n                }\n            } else if (name.equals(\"frameset\")) {\n                tb.error(this);\n                LinkedList<Element> stack = tb.getStack();\n                if (stack.size() == 1 || (stack.size() > 2 && !stack.get(1).nodeName().equals(\"body\"))) {\n                    return false;\n                } else if (!tb.framesetOk()) {\n                    return false;\n                } else {\n                    Element second = stack.get(1);\n                    if (second.parent() != null)\n                        second.remove();\n                    while (stack.size() > 1)\n                        stack.removeLast();\n                    tb.insert(startTag);\n                    tb.transition(TreeBuilderState.InFrameset);\n                }\n            } else if (StringUtil.in(name, \"script\", \"style\", \"iframe\", \"xmp\", \"noembed\", \"noframes\", \"noscript\", \"textarea\", \"title\")) {\n                if (tb.inButtonScope(\"p\")) {\n                    tb.process(new Token.EndTag(\"p\"));\n                }\n                tb.insert(startTag);\n                tb.tokeniser.transition(name.equals(\"textarea\") ? TokeniserState.Rcdata : TokeniserState.Rawtext); // Correctly handle special tags.\n                if (name.equals(\"textarea\")) {\n                    tb.markInsertionMode();\n                    tb.framesetOk(false);\n                    tb.transition(TreeBuilderState.Text);\n                }\n            } else {\n                // Handle all other types of StartTag\n                handleStartTag(startTag, tb, name);\n            }\n            break;\n\n        case EndTag:\n            Token.EndTag endTag = t.asEndTag();\n            String endName = endTag.name();\n            if (endName.equals(\"body\")) {\n                if (!tb.inScope(\"body\")) {\n                    tb.error(this);\n                    return false;\n                } else {\n                    tb.transition(TreeBuilderState.AfterBody);\n                }\n            } else if (endName.equals(\"html\")) {\n                boolean notIgnored = tb.process(new Token.EndTag(\"body\"));\n                if (notIgnored)\n                    return tb.process(endTag);\n            } else {\n                // Refactored to process other end tags through helper\n                return handleEndTag(endTag, tb, endName);\n            }\n            break;\n\n        case EOF:\n            // Ensure proper handling on EOF\n            if (!tb.inSpecificScope(\"body\", \"html\")) {\n                tb.error(this);\n            }\n            return true;\n\n        default:\n            // Error case for unknown token (defensive programming)\n            tb.error(this);\n            return false;\n    }\n    return true;\n}\n\nprivate void handleStartTag(Token.StartTag startTag, TreeBuilder tb, String name) {\n    // Consolidated logic for handling other StartTags\n    if (StringUtil.in(name, \"caption\", \"col\", \"colgroup\", \"frame\")) {\n        tb.error(this);\n    } else {\n        tb.insert(startTag);\n    }\n}\n\nprivate boolean handleEndTag(Token.EndTag endTag, TreeBuilder tb, String endName) {\n    // Consolidated logic for handling other EndTags\n    Element currentForm = tb.getFormElement();\n    if (endName.equals(\"form\")) {\n        if (currentForm == null || !tb.inScope(endName)) {\n            tb.error(this);\n            return false;\n        } else {\n            tb.generateImpliedEndTags();\n            tb.removeFromStack(currentForm);\n            tb.setFormElement(null);\n        }\n    } else {\n        tb.generateImpliedEndTags();\n        if (!tb.currentElement().nodeName().equals(endName)) {\n            tb.error(this);\n        }\n        tb.popStackToClose(endName);\n    }\n    return true;\n}",
    "exact_match": false,
    "ast_match": false,
    "compile": false,
    "test": false
}