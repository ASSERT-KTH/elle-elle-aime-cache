{
    "generation": "\nprivate void checkParameters() {\n\n    final double[] init = getStartPoint();\n\n    final double[] lB = getLowerBound();\n\n    final double[] uB = getUpperBound();\n\n    // Checks whether there is at least one finite bound value.\n\n    boolean hasFiniteBounds = false;\n\n    for (int i = 0; i < lB.length; i++) {\n\n        if (!Double.isInfinite(lB[i]) ||\n\n            !Double.isInfinite(uB[i])) {\n\n            hasFiniteBounds = true;\n\n            break;\n\n        }\n\n    }\n\n    // Checks whether there is at least one infinite bound value.\n\n    boolean hasInfiniteBounds = false;\n\n    if (hasFiniteBounds) {\n\n        for (int i = 0; i < lB.length; i++) {\n\n            if (Double.isInfinite(lB[i]) ||\n\n                Double.isInfinite(uB[i])) {\n\n                hasInfiniteBounds = true;\n\n                break;\n\n            }\n\n        }\n\n        if (hasInfiniteBounds) {\n\n            // If there is at least one finite bound, none can be infinite,\n\n            // because mixed cases are not supported by the current code.\n\n            throw new MathUnsupportedOperationException();\n\n        } else {\n\n            // Convert API to internal handling of boundaries.\n\n            boundaries = new double[2][];\n\n            boundaries[0] = lB;\n\n            boundaries[1] = uB;\n\n            // Check if any boundary range is too large.\n\n            for (int i = 0; i < lB.length; i++) {\n\n                double range = uB[i] - lB[i];\n\n                if (range > Double.MAX_VALUE / 10) {\n\n                    throw new NumberIsTooLargeException(range, Double.MAX_VALUE / 10, false);\n\n                }\n\n            }\n\n            // Abort early if the normalization will overflow (cf. \"encode\" method).\n\n        }\n\n    } else {\n\n        // Convert API to internal handling of boundaries.\n\n        boundaries = null;\n\n    }\n\n    if (inputSigma != null) {\n\n        if (inputSigma.length != init.length) {\n\n            throw new DimensionMismatchException(inputSigma.length, init.length);\n\n        }\n\n        for (int i = 0; i < init.length; i++) {\n\n            if (inputSigma[i] < 0) {\n\n                throw new NotPositiveException(inputSigma[i]);\n\n            }\n\n            if (boundaries != null) {\n\n                if (inputSigma[i] > boundaries[1][i] - boundaries[0][i]) {\n\n                    throw new OutOfRangeException(inputSigma[i], 0, boundaries[1][i] - boundaries[0][i]);\n\n                }\n\n            }\n\n        }\n\n    }\n\n}\n",
    "exact_match": false,
    "ast_match": false,
    "compile": true,
    "test": true
}