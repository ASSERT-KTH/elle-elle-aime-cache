{
    "generation": "/**\n * Computes the square-root of the weight matrix.\n *\n * @param m Symmetric, positive-definite (weight) matrix.\n * @return the square-root of the weight matrix.\n */\nprivate RealMatrix squareRoot(RealMatrix m) {\n    // Fix: Check for singularity and handle large matrices to prevent OOM\n    if (m.getRowDimension() > 1000) { // arbitrary large size threshold\n        // For large matrices, use a more memory-efficient approach (e.g., iterative method)\n        return iterativeSquareRoot(m);\n    } else if (new LUDecomposition(m).getDeterminant() == 0) {\n        // Handle singular matrix (non-invertible)\n        throw new SingularMatrixException();\n    } else {\n        // Original approach for smaller, non-singular matrices\n        final EigenDecomposition dec = new EigenDecomposition(m);\n        return dec.getSquareRoot();\n    }\n}\n\n// New method for iterative square root computation (memory-efficient)\nprivate RealMatrix iterativeSquareRoot(RealMatrix m) {\n    int maxIter = 100; // max iterations\n    double tol = 1e-6; // convergence tolerance\n    RealMatrix Y = m.copy();\n    RealMatrix Z = MatrixUtils.createRealIdentityMatrix(m.getColumnDimension());\n    \n    for (int i = 0; i < maxIter; i++) {\n        RealMatrix T = Y.multiply(Y);\n        RealMatrix delta = T.subtract(m).scalarMultiply(0.5);\n        if (delta.getFrobeniusNorm() < tol) {\n            break;\n        }\n        Y = Y.subtract(delta.multiply(Z));\n        Z = Z.add(delta.multiply(Y));\n    }\n    return Y;\n}",
    "exact_match": false,
    "ast_match": false,
    "compile": false,
    "test": false
}