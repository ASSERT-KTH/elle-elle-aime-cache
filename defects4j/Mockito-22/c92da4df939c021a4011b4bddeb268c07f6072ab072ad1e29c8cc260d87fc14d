{
    "generation": "/**\n * Checks if two objects are equal, handling arrays and nulls.\n * \n * @param o1 the first object to compare\n * @param o2 the second object to compare\n * @return true if the objects are equal, false otherwise\n */\npublic static boolean areEqual(Object o1, Object o2) {\n    if (o1 == null || o2 == null) {\n        return o1 == null && o2 == null;\n    } else if (isArray(o1)) {\n        // Check if both are arrays and have the same component type\n        if (!isArray(o2) ||!o1.getClass().getComponentType().equals(o2.getClass().getComponentType())) {\n            return false;\n        }\n        return areArraysEqual(o1, o2);\n    } else if (o1.getClass().isArray()!= o2.getClass().isArray()) {\n        // One is an array, the other is not, but could be an array wrapper (e.g., Integer[] vs int[])\n        if (o1.getClass().isArray()) {\n            return areEqual(wrapArray(o1), o2);\n        } else {\n            return areEqual(o1, wrapArray(o2));\n        }\n    } else {\n        // Attempt to use.equals, but handle classes that override.equals poorly (like our 'BadEquals' test case)\n        try {\n            return o1.equals(o2);\n        } catch (RuntimeException e) {\n            // If.equals throws, fall back to reference equality\n            return o1 == o2;\n        }\n    }\n}\n\n// Helper method to wrap primitive arrays in their object counterparts\nprivate static Object wrapArray(Object array) {\n    Class<?> componentType = array.getClass().getComponentType();\n    if (componentType == byte.class) {\n        byte[] bytes = (byte[]) array;\n        return java.util.Arrays.stream(bytes).mapToObj(b -> b).toArray(Byte[]::new);\n    } else if (componentType == short.class) {\n        short[] shorts = (short[]) array;\n        return java.util.Arrays.stream(shorts).mapToObj(s -> s).toArray(Short[]::new);\n    } else if (componentType == int.class) {\n        int[] ints = (int[]) array;\n        return java.util.Arrays.stream(ints).mapToObj(i -> i).toArray(Integer[]::new);\n    } else if (componentType == long.class) {\n        long[] longs = (long[]) array;\n        return java.util.Arrays.stream(longs).mapToObj(l -> l).toArray(Long[]::new);\n    } else if (componentType == float.class) {\n        float[] floats = (float[]) array;\n        return java.util.Arrays.stream(floats).mapToObj(f -> f).toArray(Float[]::new);\n    } else if (componentType == double.class) {\n        double[] doubles = (double[]) array;\n        return java.util.Arrays.stream(doubles).mapToObj(d -> d).toArray(Double[]::new);\n    } else if (componentType == boolean.class) {\n        boolean[] booleans = (boolean[]) array;\n        return java.util.Arrays.stream(booleans).mapToObj(b -> b).toArray(Boolean[]::new);\n    } else if (componentType == char.class) {\n        char[] chars = (char[]) array;\n        return java.util.Arrays.stream(chars).mapToObj(c -> c).toArray(Character[]::new);\n    }\n    throw new UnsupportedOperationException(\"Unsupported array type: \" + componentType);\n}\n\n// Assume isArray() and areArraysEqual() methods are correctly implemented elsewhere",
    "exact_match": false,
    "ast_match": false,
    "compile": false,
    "test": false
}