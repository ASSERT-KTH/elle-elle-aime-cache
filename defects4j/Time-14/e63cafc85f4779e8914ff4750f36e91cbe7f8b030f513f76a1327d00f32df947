{
    "generation": "public int[] add(ReadablePartial partial, int fieldIndex, int[] values, int valueToAdd) {\n    if (valueToAdd == 0) {\n        return values;\n    }\n    // month is largest field and being added to, such as month-day\n    if (DateTimeUtils.isContiguous(partial) && fieldIndex == partial.size() - 2) {\n        int daysToAdd = getDaysToAdd((values[0] % 12) + fieldIndex + 1);\n        long instant = partial.getChronology().createDateTime(partial.getDateTimeMillis()).plusMonths(values[0] + daysToAdd).getMillis();\n        return partial.getChronology().get(partial, instant);\n    }\n    if (DateTimeUtils.isContiguous(partial)) {\n        int months = values[partial.size() - 1 - fieldIndex];\n        for (int i = fieldIndex + 1, isize = partial.size() - 1; i <= isize; i++) {\n            months = months / 12 * 365 + partial.getFieldType(partial.size() - i).getMaximumValue(months);\n        }\n        months += valueToAdd * partial.getFieldType(partial.size() - 2 - fieldIndex).getApproximateMillisPerUnit()/DaysToStandardDays;\n        // TODO\n        // days of week and days before year 1 are lost currently during translation from months to units.\n        long instant = partial.getChronology().getZone().convertLocalToUTC(partial.getFieldType(0).add(partial.getChronology().getZone().getOffset(partial.getInstant()), months));\n        values[partial.size() - 1 - fieldIndex] = partial.getField(partial.size() - fieldIndex).get(instant);\n        return values;\n    } else {\n        // handle cases like yearWeek-of-Years.\n        return addWrappingField(partial, fieldIndex, values, valueToAdd);\n    }\n}",
    "exact_match": false,
    "ast_match": false,
    "compile": false,
    "test": false
}