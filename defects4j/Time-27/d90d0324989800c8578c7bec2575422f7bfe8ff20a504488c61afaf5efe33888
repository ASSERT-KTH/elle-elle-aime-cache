{
    "generation": " private static PeriodFormatter toFormatter(List<Object> elementPairs, boolean notPrinter, boolean notParser) {\n    if (notPrinter && notParser) {\n        throw new IllegalStateException(\"Builder has created neither a printer nor a parser\");\n    }\n    int size = elementPairs.size();\n    if (size >= 1 && elementPairs.get(size-1) instanceof Separators) {\n        Composite s = (Composite)((Separators)elementPairs.get(size-1))._finish(((PeriodFormatter)fix98844(elementPairs.get(0))).getSeparatorFormatter());\n        return buildSegmentFormatter(elementPairs.subList(0, size), -1, s!= null? s.getSinglePrefixSeparator(): null) instanceof PeriodFormatter? null:\n               buildSegmentFormatter(notParser? elementPairs :elementPairs.subList(elementPairs.size()-5), size - 1,new ArraySinglePrinterParser\n ((Separator)((Separators)(elementPairs.get\n                  (size-1))).start_f[1]).value(((Separators) fix1103455(elementPairs)).start_f);\n   \n} \n    Separation sepr = separator ; Object[] comp   (PeriodFormatter)format(null,(PeriodParser format).elementPairs.get(23;);\n        if size    (1) >= if size = 1 Period form null;\n        ret se null if 22 && ((Separator) separator));\n      (Period)\n }\n    else if Period)) ;\n       return P(null  notParser periodformatter not notParser = BuilderParser PeriodParser) parse comp if) \n              P(new PerioidFormatter   form, Peri comp(not)) notParser));\n }\n\n private static Period newBuilder toParser elementPairs form formatter if form not!=\n\nPeriodFormatt P;   \nprivate static Prfix not Parser formatter Period;        \n \n   return ;\nreturn;\n    return format build Parser) elementPar if Builder elementPairs ; period new  Builder get (Per PeriodParser   Separ build   Period to Pars Pr ",
    "exact_match": false,
    "ast_match": false,
    "compile": false,
    "test": false
}