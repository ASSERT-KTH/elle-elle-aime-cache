{
    "generation": "private Node performArithmeticOp(int opType, Node left, Node right) {\n    // ...\n\n    switch (opType) {\n        case Token.BITAND:\n            result = ScriptRuntime.toInt32(lval) & ScriptRuntime.toInt32(rval);\n            break;\n        case Token.BITOR:\n            result = ScriptRuntime.toInt32(lval) | ScriptRuntime.toInt32(rval);\n            break;\n        case Token.BITXOR:\n            result = ScriptRuntime.toInt32(lval) ^ ScriptRuntime.toInt32(rval);\n            break;\n        case Token.ADD:\n            result = lval + rval;\n            break;\n        case Token.SUB:\n            result = lval - rval;\n            break;\n        case Token.MUL:\n            result = lval * rval;\n            break;\n        case Token.MOD:\n            if (rval == 0) {\n                error(DiagnosticType.error(\"JSC_DIVIDE_BY_0_ERROR\", \"Divide by 0\"), right);\n                return Node.newString(Token.NAME, \"NaN\"); // return 'NaN' when dividing by zero for Modulo operation\n            }\n            result = lval % rval;\n            break;\n        case Token.DIV:\n            if (rval == 0) {\n                error(DiagnosticType.error(\"JSC_DIVIDE_BY_0_ERROR\", \"Divide by 0\"), right);\n                return Node.newString(Token.NAME, \"Infinity\"); // return 'Infinity' when dividing by zero\n            }\n            result = lval / rval;\n            break;\n        default:\n            throw new Error(\"Unexpected arithmetic operator\");\n    }\n\n    // ...\n}",
    "exact_match": false,
    "ast_match": false,
    "compile": false,
    "test": false
}