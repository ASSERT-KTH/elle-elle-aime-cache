{
    "generation": "private Node performArithmeticOp(int opType, Node left, Node right) {\n  // Unlike other operations, ADD operands are not always converted\n  // to Number.\n  if (opType == Token.ADD\n      && (NodeUtil.mayBeString(left, false)\n          || NodeUtil.mayBeString(right, false))) {\n    return null;\n  }\n\n  Double lValObj = NodeUtil.getNumberValue(left);\n  if (lValObj == null) {\n    return null;\n  }\n  Double rValObj = NodeUtil.getNumberValue(right);\n  if (rValObj == null) {\n    return null;\n  }\n\n  double lval = lValObj;\n  double rval = rValObj;\n\n  switch (opType) {\n    case Token.BITAND:\n      return Node.newNumber(ScriptRuntime.toInt32(lval) & ScriptRuntime.toInt32(rval));\n    case Token.BITOR:\n      return Node.newNumber(ScriptRuntime.toInt32(lval) | ScriptRuntime.toInt32(rval));\n    case Token.BITXOR:\n      return Node.newNumber(ScriptRuntime.toInt32(lval) ^ ScriptRuntime.toInt32(rval));\n    case Token.ADD:\n      return Node.newNumber(lval + rval);\n    case Token.SUB:\n      return Node.newNumber(lval - rval);\n    case Token.MUL:\n      return Node.newNumber(lval * rval);\n    case Token.MOD:\n      if (rval == 0) {\n        // Handle modulo by zero by returning the original expression\n        return null;\n      }\n      return Node.newNumber(lval % rval);\n    case Token.DIV:\n      if (rval == 0) {\n        // For division by zero, do not fold and return the original expression\n        return null;\n      }\n      return Node.newNumber(lval / rval);\n    default:\n      throw new Error(\"Unexpected arithmetic operator\");\n  }\n}",
    "exact_match": false,
    "ast_match": false,
    "compile": true,
    "test": false
}