{
    "generation": "private Node performArithmeticOp(int opType, Node left, Node right) {\n  // Unlike other operations, ADD operands are not always converted\n  // to Number.\n  if (opType == Token.ADD &&\n      (NodeUtil.mayBeString(left, false) || NodeUtil.mayBeString(right, false))) {\n    return null;\n  }\n\n  Double lValObj = NodeUtil.getNumberValue(left);\n  if (lValObj == null) {\n    return null;\n  }\n  Double rValObj = NodeUtil.getNumberValue(right);\n  if (rValObj == null) {\n    return null;\n  }\n\n  double lval = lValObj;\n  double rval = rValObj;\n\n  double result;\n  switch (opType) {\n    case Token.BITAND:\n      result = ScriptRuntime.toInt32(lval) & ScriptRuntime.toInt32(rval);\n      break;\n    case Token.BITOR:\n      result = ScriptRuntime.toInt32(lval) | ScriptRuntime.toInt32(rval);\n      break;\n    case Token.BITXOR:\n      result = ScriptRuntime.toInt32(lval) ^ ScriptRuntime.toInt32(rval);\n      break;\n    case Token.ADD:\n      result = lval + rval;\n      break;\n    case Token.SUB:\n      result = lval - rval;\n      break;\n    case Token.MUL:\n      result = lval * rval;\n      break;\n    case Token.MOD:\n      if (rval == 0) {\n        // Do not fold division by zero, return null to keep original node\n        return null;\n      }\n      result = lval % rval;\n      break;\n    case Token.DIV:\n      if (rval == 0) {\n        // Do not fold division by zero, return null to keep original node\n        return null;\n      }\n      result = lval / rval;\n      break;\n    default:\n      throw new Error(\"Unexpected arithmetic operator\");\n  }\n\n  // Check if the result can be accurately represented as a Number\n  if (Math.abs(result) > MAX_FOLD_NUMBER) {\n    return null;\n  }\n\n  // Check for NaN, Infinity, and -Infinity\n  if (Double.isNaN(result)) {\n    return Node.newString(Token.NAME, \"NaN\");\n  } else if (result == Double.POSITIVE_INFINITY) {\n    return Node.newString(Token.NAME, \"Infinity\");\n  } else if (result == Double.NEGATIVE_INFINITY) {\n    return new Node(Token.NEG, Node.newString(Token.NAME, \"Infinity\"));\n  } else {\n    // Ensure that the folded number is precise\n    if (result == (float) result) {\n      return Node.newNumber(result);\n    } else {\n      return null;\n    }\n  }\n}",
    "exact_match": false,
    "ast_match": false,
    "compile": true,
    "test": false
}