{
    "generation": "/**\n* Try to fold arithmetic binary operators\n*/\nprivate Node performArithmeticOp(int opType, Node left, Node right) {\n    // Unlike other operations, ADD operands are not always converted\n    // to Number.\n    if (opType == Token.ADD\n            && (NodeUtil.mayBeString(left, false)\n            || NodeUtil.mayBeString(right, false))) {\n        return null;\n    }\n\n    Double lValObj = NodeUtil.getNumberValue(left);\n    if (lValObj == null) {\n        return null;\n    }\n    Double rValObj = NodeUtil.getNumberValue(right);\n    if (rValObj == null) {\n        return null;\n    }\n\n    double lval = lValObj;\n    double rval = rValObj;\n\n    switch (opType) {\n        case Token.BITAND:\n            result = ScriptRuntime.toInt32(lval) & ScriptRuntime.toInt32(rval);\n            break;\n        case Token.BITOR:\n            result = ScriptRuntime.toInt32(lval) | ScriptRuntime.toInt32(rval);\n            break;\n        case Token.BITXOR:\n            result = ScriptRuntime.toInt32(lval) ^ ScriptRuntime.toInt32(rval);\n            break;\n        case Token.ADD:\n            result = lval + rval;\n            break;\n        case Token.SUB:\n            result = lval - rval;\n            break;\n        case Token.MUL:\n            result = lval * rval;\n            break;\n        case Token.MOD:\n            if (rval == 0) {\n                error(DiagnosticType.error(\"JSC_DIVIDE_BY_0_ERROR\", \"Divide by 0\"), right);\n                return null;\n            }\n            result = lval % rval;\n            break;\n        case Token.DIV:\n            if (rval == 0) {\n                error(DiagnosticType.error(\"JSC_DIVIDE_BY_0_ERROR\", \"Divide by 0\"), right);\n                return null;\n            }\n            result = lval / rval;\n            break;\n        default:\n            throw new Error(\"Unexpected arithmetic operator\");\n    }\n\n    // Check if the result is within acceptable length and value range\n    String resultStr = String.valueOf(result);\n    String lvalStr = String.valueOf(lval);\n    String rvalStr = String.valueOf(rval);\n    if (resultStr.length() <= lvalStr.length() + rvalStr.length() + 1 &&\n            Math.abs(result) <= MAX_FOLD_NUMBER) {\n        Node newNumber = Node.newNumber(result);\n        return newNumber;\n    } else if (Double.isNaN(result)) {\n        return Node.newString(Token.NAME, \"NaN\");\n    } else if (result == Double.POSITIVE_INFINITY) {\n        return Node.newString(Token.NAME, \"Infinity\");\n    } else if (result == Double.NEGATIVE_INFINITY) {\n        return new Node(Token.NEG, Node.newString(Token.NAME, \"Infinity\"));\n    }\n\n    return null;\n}",
    "exact_match": false,
    "ast_match": false,
    "compile": false,
    "test": false
}