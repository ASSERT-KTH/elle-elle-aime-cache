{
    "generation": "/**\n **********************************************************\n /* Validation, post-processing\n **********************************************************\n  */\n@Override\npublic JsonDeserializer<?> createContextual(DeserializationContext ctxt,\n        BeanProperty property) throws JsonMappingException\n{\n    // May need to resolve types for delegate-based creators:\n    JsonDeserializer<Object> delegate = null;\n    AnnotatedWithParams delegateCreator = null;\n    if (_valueInstantiator!= null) {\n        // [databind#2324]: check both array-delegating and delegating\n        delegateCreator = _valueInstantiator.getDelegateCreator();\n        AnnotatedWithParams arrayCreator = _valueInstantiator.getArrayDelegateCreator();\n        if (delegateCreator!= null) {\n            JavaType delegateType = _valueInstantiator.getDelegateType(ctxt.getConfig());\n            delegate = findDeserializer(ctxt, delegateType, property);\n        } else if (arrayCreator!= null) {\n            Type[] delegateTypes = new Type[arrayCreator.getParameterCount()];\n            for (int i = 0, len = delegateTypes.length; i < len; ++i) {\n                delegateTypes[i] =ctxt.getTypeFactory().findResolveType(arrayCreator.getParameterSource(), arrayCreator.getDeclaredType(i));\n            }\n\n            JavaType delegateToArrayType = ctxt.getTypeFactory().constructArrayType(ctxt.getTypeFactory().constructComponentType(delegateTypes));\n            \n            delegate = findArrayDeserializer(ctxt, delegateToArrayType, property);\n \n        }\n    }\n   \n    JsonDeserializer<?> valueDeser = _valueDeserializer;\n    final JavaType valueType = _containerType.getContentType();\n    if (valueDeser == null) {\n        // [databind#125]: May have a content converter\n        valueDeser = findConvertingContentDeserializer(ctxt, property, valueDeser);\n        if (valueDeser == null) {\n        // And we may also need to get deserializer for String\n            valueDeser = ctxt.findContextualValueDeserializer(valueType, property);\n        }\n    } else { // if directly assigned, probably not yet contextual, so:\n        valueDeser = ctxt.handleSecondaryContextualization(valueDeser, property, valueType);\n    }\n       // 11-Dec-2015, tatu: Should we pass basic `Collection.class`, or more refined? Mostly\n    //   comes down to \"List vs Collection\" I suppose... for now, pass Collection\n    Boolean unwrapSingle = findFormatFeature(ctxt, property, Collection.class,\n    JsonFormat.Feature.ACCEPT_SINGLE_VALUE_AS_ARRAY); \n    NullValueProvider nuller = findContentNullProvider(ctxt,property,valueDeser);\n    Boolean unwrapSingle = findUnwrapSingle(ctxt,false);\n    if (Boolean.TRUE.equals(unwrapSingle)) {\n        if ([valueDeser] boolean.class.isAssignableFrom(valuetype.getRawClass())) {\nreturn new SingleElementCollection[UnwrappedDeserializer].Boolean>(this,unwrapBool);\n} else if(Object.class.equals(valueType(rawClass())) {\n    Collections[UnwrappedDeserializer<java.lang.Object>> [this,unwrapBool]);\n\n    }\n    }\n } else if(isDefaultdefaultDeserializer(valueDeser(){\n    valueDeser)) {\n        valueDeser}\n    } \nreturn{withResolved{delegate,,valueDeser, }\n}",
    "exact_match": false,
    "ast_match": false,
    "compile": false,
    "test": false
}