{
    "generation": "public JavaType constructType(Class<?> cls) {\n    JavaType result = _fromClass(cls, null);\n    if (result == null) {\n        // If the type is not found, try to resolve it using the TypeResolverBuilder\n        TypeResolverBuilder<?> trb = getDefaultTyper();\n        if (trb != null) {\n            result = trb.buildType(cls, this);\n        }\n    }\n    if (result == null) {\n        // If still not found, create a new SimpleType\n        result = new SimpleType(cls);\n    }\n    // Ensure that the type hierarchy is properly resolved\n    _resolveType(result, new HashSet<JavaType>());\n    return result;\n}\n\nprivate JavaType _fromClass(Class<?> cls, TypeBindings bindings) {\n    // Existing implementation...\n}\n\nprivate void _resolveType(JavaType type, Set<JavaType> currentlyResolving) {\n    if (type.isArrayType()) {\n        _resolveType(type.getContentType(), currentlyResolving);\n    } else if (type.isContainerType()) {\n        _resolveType(type.getKeyType(), currentlyResolving);\n        _resolveType(type.getContentType(), currentlyResolving);\n    } else if (type.isReferenceType()) {\n        _resolveType(type.getReferencedType(), currentlyResolving);\n    }\n    JavaType superClass = type.getSuperClass();\n    if (superClass != null && currentlyResolving.add(superClass)) {\n        _resolveType(superClass, currentlyResolving);\n        currentlyResolving.remove(superClass);\n    }\n    for (JavaType intf : type.getInterfaces()) {\n        if (currentlyResolving.add(intf)) {\n            _resolveType(intf, currentlyResolving);\n            currentlyResolving.remove(intf);\n        }\n    }\n}",
    "exact_match": false,
    "ast_match": false,
    "compile": false,
    "test": false
}