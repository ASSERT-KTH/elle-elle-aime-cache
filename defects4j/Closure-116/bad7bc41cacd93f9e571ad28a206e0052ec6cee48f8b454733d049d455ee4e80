{
    "generation": "while (cArg != null || fnParam != null) {\n  // For each named parameter check if a mutable argument use more than one.\n  if (fnParam != null) {\n    if (cArg != null) {\n      // Get the references to the function parameter within the called function\n      List<Node> fnParamReferences = NodeUtil.findReferencesToParameter(block, fnParam);\n\n      // Check if the call argument is a reference to the function parameter\n      if (cArg.isName() && cArg.getString().equals(fnParam.getString())) {\n        // Check if the function parameter is modified inside the called function\n        boolean isModifiedInFunction = isParameterModifiedWithinFunction(fnNode, fnParam);\n\n        // Check if the function parameter is referenced more than once in the called function\n        boolean isReferencedMultipleTimes = fnParamReferences.size() > 1;\n\n        // Check if the call argument may effect mutable state\n        boolean hasSideEffects = NodeUtil.mayEffectMutableState(cArg, compiler);\n\n        // If the function parameter is modified and referenced multiple times or has side effects, return CanInlineResult.NO\n        if (isModifiedInFunction || isReferencedMultipleTimes || hasSideEffects) {\n          return CanInlineResult.NO;\n        }\n      }\n    }\n\n    // Move to the next name.\n    fnParam = fnParam.getNext();\n  }\n\n  // For every call argument check for side-effects, even if there\n  // isn't a named parameter to match.\n  if (cArg != null) {\n    if (NodeUtil.mayHaveSideEffects(cArg, compiler)) {\n      return CanInlineResult.NO;\n    }\n    cArg = cArg.getNext();\n  }\n}",
    "exact_match": false,
    "ast_match": false,
    "compile": false,
    "test": false
}