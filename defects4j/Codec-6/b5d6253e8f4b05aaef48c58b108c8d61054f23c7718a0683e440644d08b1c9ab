{
    "generation": "\n// Rationale for while-loop on (readLen == 0):\n\n// ----\n\n// Base64.readResults() usually returns > 0 or EOF (-1). In the\n\n// rare case where it returns 0, we just keep trying.\n\n//\n\n// This is essentially an undocumented contract for InputStream\n\n// implementors that want their code to work properly with\n\n// java.io.InputStreamReader, since the latter hates it when\n\n// InputStream.read(byte[]) returns a zero. Unfortunately our\n\n// readResults() call must return 0 if a large amount of the data\n\n// being decoded was non-base64, so this while-loop enables proper\n\n// interop with InputStreamReader for that scenario.\n\n// ----\n\n// This is a fix for CODEC-101\n\n//\n\nwhile (true) {\n\nif (!base64.hasData()) {\n\nbyte[] buf = new byte[doEncode ? 4096 : 8192];\n\nint c = in.read(buf);\n\n// A little optimization to avoid System.arraycopy()\n\n// when possible.\n\nif (c > 0 && b.length == len) {\n\nbase64.setInitialBuffer(b, offset, len);\n\n}\n\nif (doEncode) {\n\nbase64.encode(buf, 0, c);\n\n} else {\n\nbase64.decode(buf, 0, c);\n\n}\n\n}\n\nint readLen = base64.readResults(b, offset, len);\n\nif (readLen != 0) {\n\nreturn readLen;\n\n}\n\n}\n",
    "exact_match": false,
    "ast_match": false,
    "compile": false,
    "test": false
}