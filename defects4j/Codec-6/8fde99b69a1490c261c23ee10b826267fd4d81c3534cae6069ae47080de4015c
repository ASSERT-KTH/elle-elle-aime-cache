{
    "generation": "    public int read(byte b[], int offset, int len) throws IOException {\n        if (b == null) {\n            throw new NullPointerException();\n        } else if (offset < 0 || len < 0) {\n            throw new IndexOutOfBoundsException();\n        } else if (offset > b.length || offset + len > b.length) {\n            throw new IndexOutOfBoundsException();\n        } else if (len == 0) {\n            return 0;\n        }\n\n        int bytesRead = 0;\n\n        /*\n         Rationale for while-loop on (bytesRead == 0):\n         -----\n         Base64.readResults() usually returns > 0 or EOF (-1). \n         In the rare case where it returns 0, we keep trying \n         to read to ensure proper interoperation with java.io.InputStreamReader.\n         */\n        while (bytesRead == 0) {\n            if (!base64.hasData()) {\n                byte[] buf = new byte[doEncode ? 4096 : 8192];\n                int c = in.read(buf);\n                if (c == -1) {\n                    if (base64.hasData()) {\n                        break; // Process remaining buffered data\n                    }\n                    return -1; // End of stream\n                } else if (c > 0) {\n                    if (doEncode) {\n                        base64.encode(buf, 0, c);\n                    } else {\n                        base64.decode(buf, 0, c);\n                    }\n                }\n            }\n            bytesRead = base64.readResults(b, offset, len);\n        }\n\n        return bytesRead;\n    }",
    "exact_match": false,
    "ast_match": false,
    "compile": true,
    "test": false
}