{
    "generation": "\npublic int read(byte b[], int offset, int len) throws IOException {\n\n    if (b == null) {\n\n        throw new NullPointerException();\n\n    } else if (offset < 0 || len < 0) {\n\n        throw new IndexOutOfBoundsException();\n\n    } else if (offset > b.length || offset + len > b.length) {\n\n        throw new IndexOutOfBoundsException();\n\n    } else if (len == 0) {\n\n        return 0;\n\n    } else {\n\n        boolean eofReached = false;\n\n        while (true) {\n\n            if (!base64.hasData()) {\n\n                if (eofReached) {\n\n                    break;\n\n                }\n\n                byte[] buf = new byte[doEncode ? 4096 : 8192];\n\n                int c = in.read(buf);\n\n                if (c == -1) {\n\n                    eofReached = true;\n\n                } else {\n\n                    // A little optimization to avoid System.arraycopy()\n\n                    // when possible.\n\n                    if (c > 0 && b.length == len) {\n\n                        base64.setInitialBuffer(b, offset, len);\n\n                    }\n\n                    if (doEncode) {\n\n                        base64.encode(buf, 0, c);\n\n                    } else {\n\n                        base64.decode(buf, 0, c);\n\n                    }\n\n                }\n\n            }\n\n            int readLen = base64.readResults(b, offset, len);\n\n            if (readLen > 0) {\n\n                return readLen;\n\n            } else if (eofReached) {\n\n                return -1;\n\n            }\n\n            // Otherwise, continue the loop to read more data\n\n        }\n\n    }\n\n}\n",
    "exact_match": false,
    "ast_match": false,
    "compile": false,
    "test": false
}