{
    "generation": "public int read(byte b[], int offset, int len) throws IOException {\n    if (b == null) {\n        throw new NullPointerException();\n    } else if (offset < 0 || len < 0) {\n        throw new IndexOutOfBoundsException();\n    } else if (offset > b.length || offset + len > b.length) {\n        throw new IndexOutOfBoundsException();\n    } else if (len == 0) {\n        return 0;\n    } else {\n        int bytesRead = 0;\n        // Check if there is available data in base64 object\n        if (!base64.hasData()) {\n            byte[] buf = new byte[doEncode ? 4096 : 8192];\n            int c = in.read(buf);\n            // If no data is available to read, return -1 (EOF)\n            if (c < 0) {\n                return -1;\n            }\n            // A little optimization to avoid System.arraycopy() when possible\n            if (b.length == len) {\n                base64.setInitialBuffer(b, offset, len);\n            }\n            if (doEncode) {\n                base64.encode(buf, 0, c);\n            } else {\n                base64.decode(buf, 0, c);\n            }\n        }\n        // Read results from base64 object into the given byte array\n        bytesRead = base64.readResults(b, offset, len);\n        // If the readResults method returns 0, it means there is no data available to read.\n        // In this case, we need to keep trying until there is data or we reach the end of the stream.\n        while (bytesRead == 0) {\n            byte[] buf = new byte[doEncode ? 4096 : 8192];\n            int c = in.read(buf);\n            if (c < 0) {\n                return -1;\n            }\n            if (doEncode) {\n                base64.encode(buf, 0, c);\n            } else {\n                base64.decode(buf, 0, c);\n            }\n            bytesRead = base64.readResults(b, offset, len);\n        }\n        return bytesRead;\n    }\n}",
    "exact_match": false,
    "ast_match": false,
    "compile": true,
    "test": false
}