{
    "generation": "/**\n * <p>Creates a random string based on a variety of options, using\n * supplied source of randomness.</p>\n *\n * <p>If start and end are both {@code 0}, start and end are set\n * to {@code ' '} and {@code 'z'}, the ASCII printable\n * characters, will be used, unless letters and numbers are both\n * {@code false}, in which case, start and end are set to\n * {@code 0} and {@code Integer.MAX_VALUE}.\n *\n * <p>If set is not {@code null}, characters between start and\n * end are chosen.</p>\n *\n * <p>This method accepts a user-supplied {@link Random}\n * instance to use as a source of randomness. By seeding a single \n * {@link Random} instance with a fixed seed and using it for each call,\n * the same random sequence of strings can be generated repeatedly\n * and predictably.</p>\n *\n * @param count  the length of random string to create\n * @param start  the position in set of chars to start at\n * @param end  the position in set of chars to end before\n * @param letters  only allow letters?\n * @param numbers  only allow numbers?\n * @param chars  the set of chars to choose randoms from, must not be empty.\n *  If {@code null}, then it will use the set of all chars.\n * @param random  a source of randomness.\n * @return the random string\n * @throws ArrayIndexOutOfBoundsException if there are not\n *  {@code (end - start) + 1} characters in the set array.\n * @throws IllegalArgumentException if {@code count} &lt; 0 or the provided chars array is empty.\n * @since 2.0\n */\npublic static String random(int count, int start, int end, boolean letters, boolean numbers,\n                            char[] chars, Random random) {\n    if (count < 0) {\n        throw new IllegalArgumentException(\"Requested random string length \" + count + \" is less than 0.\");\n    }\n    if (chars != null && chars.length == 0) {\n        throw new IllegalArgumentException(\"Provided chars array is empty.\");\n    }\n\n    if (start == 0 && end == 0) {\n        if (!letters && !numbers) {\n            start = 0;\n            end = Integer.MAX_VALUE;\n        } else {\n            start = ' ';\n            end = 'z' + 1;\n        }\n    }\n\n    int gap = end - start;\n    if (gap <= 0) {\n        throw new IllegalArgumentException(\"End must be greater than start.\");\n    }\n\n    char[] buffer = new char[count];\n    for (int i = 0; i < count; i++) {\n        char ch;\n        if (chars == null) {\n            ch = (char) (random.nextInt(gap) + start);\n        } else {\n            ch = chars[random.nextInt(gap)];\n        }\n        if ((letters && Character.isLetter(ch)) || (numbers && Character.isDigit(ch)) || (!letters && !numbers)) {\n            if (ch >= 56320 && ch <= 57343) { // low surrogate\n                if (i == count - 1) {\n                    i--; // skip this character\n                } else {\n                    buffer[i] = ch;\n                    buffer[i + 1] = (char) (55296 + random.nextInt(128));\n                    i++;\n                }\n            } else if (ch >= 55296 && ch <= 56191) { // high surrogate\n                if (i == count - 1) {\n                    i--; // skip this character\n                } else {\n                    buffer[i] = (char) (56320 + random.nextInt(128));\n                    buffer[i + 1] = ch;\n                    i++;\n                }\n            } else if (ch >= 56192 && ch <= 56319) { // private high surrogate\n                i--; // skip this character\n            } else {\n                buffer[i] = ch;\n            }\n        } else {\n            i--; // retry for this position\n        }\n    }\n    return new String(buffer);\n}",
    "exact_match": false,
    "ast_match": false,
    "compile": true,
    "test": false
}