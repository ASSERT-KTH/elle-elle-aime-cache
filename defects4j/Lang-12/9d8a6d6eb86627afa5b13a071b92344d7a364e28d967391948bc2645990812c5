{
    "generation": "/**\n * <p>Creates a random string based on a variety of options, using\n * supplied source of randomness.</p>\n *\n * <p>If start and end are both {@code 0}, start and end are set\n * to {@code ' '} and {@code 'z'}, the ASCII printable\n * characters, will be used, unless letters and numbers are both\n * {@code false}, in which case, start and end are set to\n * {@code 0} and {@code Integer.MAX_VALUE}.\n *\n * <p>If set is not {@code null}, characters between start and\n * end are chosen.</p>\n *\n * <p>This method accepts a user-supplied {@link Random}\n * instance to use as a source of randomness. By seeding a single \n * {@link Random} instance with a fixed seed and using it for each call,\n * the same random sequence of strings can be generated repeatedly\n * and predictably.</p>\n *\n * @param count  the length of random string to create\n * @param start  the position in set of chars to start at\n * @param end  the position in set of chars to end before\n * @param letters  only allow letters?\n * @param numbers  only allow numbers?\n * @param chars  the set of chars to choose randoms from, must not be empty.\n *  If {@code null}, then it will use the set of all chars.\n * @param random  a source of randomness.\n * @return the random string\n * @throws ArrayIndexOutOfBoundsException if there are not\n *  {@code (end - start) + 1} characters in the set array.\n * @throws IllegalArgumentException if {@code count} &lt; 0 or the provided chars array is empty.\n * @since 2.0\n */\npublic static String random(int count, int start, int end, boolean letters, boolean numbers,\n                            char[] chars, Random random) {\n    if (count < 0) {\n        throw new IllegalArgumentException(\"Requested random string length \" + count + \" is less than 0.\");\n    }\n    if (chars!= null && chars.length == 0) {\n        throw new IllegalArgumentException(\"Character array must not be empty.\");\n    }\n\n    if (start == 0 && end == 0) {\n        if (!letters &&!numbers) {\n            start = 0;\n            end = Integer.MAX_VALUE;\n        } else {\n            start = ' ';\n            end = 'z' + 1;                \n        }\n    }\n\n    char[] buffer = new char[count];\n    if (chars == null) {\n        // handle all chars\n        int gap = end - start;\n        while (count--!= 0) {\n            char ch;\n            do {\n                ch = (char) (random.nextInt(gap) + start);\n            } while ((letters &&!Character.isLetter(ch)) \n                     || (numbers &&!Character.isDigit(ch)) \n                     || (!letters &&!numbers && (Character.isLetter(ch) || Character.isDigit(ch))));\n\n            // handle surrogate pairs\n            if(ch >= 55296 && ch <= 56343) {\n                if(count == 0) {\n                    // avoid index out of bounds\n                    break;\n                } else if(ch >= 55296 && ch <= 56191) {\n                    // high surrogate, insert low surrogate before putting it in\n                    buffer[count] = (char) (56320 + random.nextInt(128));\n                    count--;\n                    buffer[count] = ch;\n                } else {\n                    // low surrogate, insert high surrogate after putting it in\n                    buffer[count] = ch;\n                    count--;\n                    buffer[count] = (char) (55296 + random.nextInt(128));\n                }\n            } else {\n                buffer[count] = ch;\n            }\n        }\n    } else {\n        // handle provided char array\n        int gap = chars.length;\n        while (count--!= 0) {\n            char ch;\n            do {\n                ch = chars[random.nextInt(gap)];\n            } while ((letters &&!Character.isLetter(ch)) \n                     || (numbers &&!Character.isDigit(ch)) \n                     || (!letters &&!numbers && (Character.isLetter(ch) || Character.isDigit(ch))));\n            buffer[count] = ch;\n        }\n    }\n    return new String(buffer);\n}",
    "exact_match": false,
    "ast_match": false,
    "compile": true,
    "test": false
}