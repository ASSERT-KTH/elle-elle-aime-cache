{
    "generation": "private void inferPropertyTypesToMatchConstraint(JSType type, JSType constraint) {\n    if (type == null || constraint == null) {\n        return;\n    }\n\n    // Restrict the constraint to non-null and non-undefined types\n    JSType constraintNotNull = constraint.restrictByNotNullOrUndefined();\n    ObjectType constraintObj = ObjectType.cast(constraintNotNull);\n    if (constraintObj != null && constraintObj.isRecordType()) {\n        // Restrict the type to non-null and non-undefined types\n        JSType typeNotNull = type.restrictByNotNullOrUndefined();\n        ObjectType objType = ObjectType.cast(typeNotNull);\n        if (objType != null) {\n            for (String prop : constraintObj.getOwnPropertyNames()) {\n                JSType propType = constraintObj.getPropertyType(prop);\n                if (!objType.isPropertyTypeDeclared(prop)) {\n                    // If the property is not declared, infer a type that is the least upper bound\n                    // of the property type and the native void type.\n                    JSType typeToInfer = getNativeType(VOID_TYPE).getLeastSupertype(propType);\n                    objType.defineInferredProperty(prop, typeToInfer, null);\n                } else {\n                    // If the property is declared, widen its type to match the constraint\n                    JSType currentType = objType.getPropertyType(prop);\n                    JSType widenedType = currentType.getLeastSupertype(propType);\n                    objType.setPropertyType(prop, widenedType);\n                }\n            }\n        }\n    }\n}",
    "exact_match": false,
    "ast_match": false,
    "compile": false,
    "test": false
}