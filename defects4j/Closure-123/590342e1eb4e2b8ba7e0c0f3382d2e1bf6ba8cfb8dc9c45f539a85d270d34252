{
    "generation": "void add(Node n, Context context) {\n  if (!cc.continueProcessing()) {\n    return;\n  }\n\n  int type = n.getType();\n  String opstr = NodeUtil.opToStr(type);\n  int childCount = n.getChildCount();\n  Node first = n.getFirstChild();\n  Node last = n.getLastChild();\n\n  // Handle all binary operators\n  if (opstr != null && first != last) {\n    Preconditions.checkState(\n        childCount == 2,\n        \"Bad binary operator \\\"%s\\\": expected 2 arguments but got %s\",\n        opstr, childCount);\n    int p = NodeUtil.precedence(type);\n\n    // For right-hand-side of operations, only pass context if it's\n    // the IN_FOR_INIT_CLAUSE one.\n    Context rhsContext = getContextForNoInOperator(context);\n\n    // Handle associativity.\n    // e.g. if the parse tree is a * (b * c),\n    // we can simply generate a * b * c.\n    if (last.getType() == type &&\n        NodeUtil.isAssociative(type)) {\n      addExpr(first, p, context);\n      cc.addOp(opstr, true);\n      addExpr(last, p, rhsContext);\n    } else if (NodeUtil.isAssignmentOp(n) && NodeUtil.isAssignmentOp(last)) {\n      // Assignments are the only right-associative binary operators\n      addExpr(first, p, context);\n      cc.addOp(opstr, true);\n      addExpr(last, p, rhsContext);\n    } else {\n      unrollBinaryOperator(n, type, opstr, context, rhsContext, p, p + 1);\n    }\n    return;\n  }\n\n  cc.startSourceMapping(n);\n\n  switch (type) {\n    case Token.TRY: {\n      Preconditions.checkState(first.getNext().isBlock() &&\n              !first.getNext().hasMoreThanOneChild());\n      Preconditions.checkState(childCount >= 2 && childCount <= 3);\n\n      add(\"try\");\n      add(first, Context.PRESERVE_BLOCK);\n\n      // second child contains the catch block, or nothing if there\n      // isn't a catch block\n      Node catchblock = first.getNext().getFirstChild();\n      if (catchblock != null) {\n        add(catchblock);\n      }\n\n      if (childCount == 3) {\n        add(\"finally\");\n        add(last, Context.PRESERVE_BLOCK);\n      }\n      break;\n    }\n\n    case Token.CATCH:\n      Preconditions.checkState(childCount == 2);\n      add(\"catch(\");\n      add(first);\n      add(\")\");\n      add(last, Context.PRESERVE_BLOCK);\n      break;\n\n    case Token.THROW:\n      Preconditions.checkState(childCount == 1);\n      add(\"throw\");\n      add(first);\n\n      // Must have a ';' after a throw statement, otherwise safari can't\n      // parse this.\n      cc.endStatement(true);\n      break;\n\n    case Token.RETURN:\n      add(\"return\");\n      if (childCount == 1) {\n        add(first);\n      } else {\n        Preconditions.checkState(childCount == 0);\n      }\n      cc.endStatement();\n      break;\n\n    case Token.VAR:\n      if (first != null) {\n        add(\"var \");\n        addList(first, false, getContextForNoInOperator(context));\n      }\n      break;\n\n    case Token.LABEL_NAME:\n      Preconditions.checkState(!n.getString().isEmpty());\n      addIdentifier(n.getString());\n      break;\n\n    case Token.NAME:\n      if (first == null || first.isEmpty()) {\n        addIdentifier(n.getString());\n      } else {\n        Preconditions.checkState(childCount == 1);\n        addIdentifier(n.getString());\n        cc.addOp(\"=\", true);\n        if (first.isComma()) {\n          addExpr(first, NodeUtil.precedence(Token.ASSIGN), Context.OTHER);\n        } else {\n          // Add expression, consider nearby code at lowest level of\n          // precedence.\n          addExpr(first, 0, Context.OTHER);\n        }\n      }\n      break;\n\n    case Token.EXPR_RESULT:\n      addExpr(first, 0, Context.OTHER);\n      cc.endStatement();\n      break;\n\n    case Token.BLOCK:\n      addBlock(first, context);\n      break;\n\n    case Token.SCRIPT:\n    case Token.MODULE_BODY:\n      addAllSiblings(first);\n      break;\n\n    case Token.FUNCTION:\n      if (n.isFunctionDeclaration()) {\n        addFunctionDeclaration(n);\n      } else {\n        addFunctionExpression(n);\n      }\n      break;\n\n    case Token.IF:\n      addIf(n, context);\n      break;\n\n    case Token.WHILE:\n      addWhile(n, context);\n      break;\n\n    case Token.DO:\n      addDo(n, context);\n      break;\n\n    case Token.FOR:\n      addFor(n, context);\n      break;\n\n    case Token.FOR_IN:\n      addForIn(n, context);\n      break;\n\n    case Token.FOR_OF:\n      addForOf(n, context);\n      break;\n\n    case Token.SWITCH:\n      addSwitch(n, context);\n      break;\n\n    case Token.CASE:\n      addCase(n, context);\n      break;\n\n    case Token.DEFAULT_CASE:\n      addDefaultCase(n, context);\n      break;\n\n    case Token.LABEL:\n      addLabel(n, context);\n      break;\n\n    case Token.BREAK:\n      addBreak(n);\n      break;\n\n    case Token.CONTINUE:\n      addContinue(n);\n      break;\n\n    case Token.WITH:\n      addWith(n, context);\n      break;\n\n    case Token.CAST:\n      addCast(n);\n      break;\n\n    default:\n      throw new Error(\"Unknown type \" + type + \"\\n\" + n.toStringTree());\n  }\n\n  cc.endSourceMapping(n);\n}",
    "exact_match": false,
    "ast_match": false,
    "compile": false,
    "test": false
}