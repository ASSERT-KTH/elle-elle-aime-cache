{
    "generation": "void add(Node n, Context context) {\n    if (!cc.continueProcessing()) {\n        return;\n    }\n\n    int type = n.getType();\n    String opstr = NodeUtil.opToStr(type);\n    int childCount = n.getChildCount();\n    Node first = n.getFirstChild();\n    Node last = n.getLastChild();\n\n    // Handle all binary operators\n    if (opstr != null && first != last) {\n        Preconditions.checkState(\n            childCount == 2,\n            \"Bad binary operator \\\"%s\\\": expected 2 arguments but got %s\",\n            opstr, childCount);\n        int p = NodeUtil.precedence(type);\n\n        // For right-hand-side of operations, only pass context if it's\n        // the IN_FOR_INIT_CLAUSE one.\n        Context rhsContext = getContextForNoInOperator(context);\n\n        // Handle associativity.\n        // e.g. if the parse tree is a * (b * c),\n        // we can simply generate a * b * c.\n        if (last.getType() == type &&\n            NodeUtil.isAssociative(type)) {\n            addExpr(first, p, context);\n            cc.addOp(opstr, true);\n            addExpr(last, p, rhsContext);\n        } else if (NodeUtil.isAssignmentOp(n) && NodeUtil.isAssignmentOp(last)) {\n            // Assignments are the only right-associative binary operators\n            addExpr(first, p, context);\n            cc.addOp(opstr, true);\n            addExpr(last, p, rhsContext);\n        } else {\n            unrollBinaryOperator(n, type, opstr, context, rhsContext, p, p + 1);\n        }\n        return;\n    }\n\n    cc.startSourceMapping(n);\n\n    switch (type) {\n        // ... other cases remain unchanged ...\n\n        case Token.INC:\n        case Token.DEC: {\n            Preconditions.checkState(childCount == 1);\n            String o = type == Token.INC ? \"++\" : \"--\";\n            int postProp = n.getIntProp(Node.INCRDECR_PROP);\n            // A non-zero post-prop value indicates a post inc/dec, default of zero\n            // is a pre-inc/dec.\n            if (postProp != 0) {\n                addExpr(first, NodeUtil.precedence(type), context);\n                cc.addOp(o, false);\n            } else {\n                cc.addOp(o, false);\n                add(first);\n            }\n            break;\n        }\n\n        case Token.IN: {\n            // Ensure proper parenthesis are applied when needed for \"in\" expressions\n            Preconditions.checkState(\n                childCount == 2,\n                \"Bad IN operator: expected 2 children but got %s\", childCount);\n            boolean needsParens = (context != Context.IN_FOR_INIT_CLAUSE);\n            if (needsParens) {\n                add(\"(\");\n            }\n            addExpr(first, NodeUtil.precedence(type), context);\n            cc.addOp(\"in\", true);\n            addExpr(last, NodeUtil.precedence(type), context);\n            if (needsParens) {\n                add(\")\");\n            }\n            break;\n        }\n\n        // ... other cases remain unchanged ...\n\n        default:\n            throw new Error(\"Unknown type \" + type + \"\\n\" + n.toStringTree());\n    }\n\n    cc.endSourceMapping(n);\n}",
    "exact_match": false,
    "ast_match": false,
    "compile": true,
    "test": false
}