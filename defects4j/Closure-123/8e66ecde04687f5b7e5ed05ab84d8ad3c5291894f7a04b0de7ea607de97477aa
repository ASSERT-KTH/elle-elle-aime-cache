{
    "generation": "  void add(Node n, Context context) {\n    if (!cc.continueProcessing()) {\n      return;\n    }\n\n    int type = n.getType();\n    String opstr = NodeUtil.opToStr(type);\n    int childCount = n.getChildCount();\n    Node first = n.getFirstChild();\n    Node last = n.getLastChild();\n\n    // Handle all binary operators\n    if (opstr != null && first != last) {\n      Preconditions.checkState(\n          childCount == 2,\n          \"Bad binary operator \\\"%s\\\": expected 2 arguments but got %s\",\n          opstr, childCount);\n      int p = NodeUtil.precedence(type);\n\n      // For right-hand-side of operations, only pass context if it's\n      // the IN_FOR_INIT_CLAUSE one.\n      Context rhsContext = getContextForNoInOperator(context);\n\n      // Handle associativity.\n      // e.g. if the parse tree is a * (b * c),\n      // we can simply generate a * b * c.\n      if (last.getType() == type &&\n          NodeUtil.isAssociative(type)) {\n        addExpr(first, p, context);\n        cc.addOp(opstr, true);\n        addExpr(last, p, rhsContext);\n      } else if (NodeUtil.isAssignmentOp(n) && NodeUtil.isAssignmentOp(last)) {\n        // Assignments are the only right-associative binary operators\n        addExpr(first, p, context);\n        cc.addOp(opstr, true);\n        addExpr(last, p, rhsContext);\n      } else {\n        unrollBinaryOperator(n, type, opstr, context, rhsContext, p, p + 1);\n      }\n      return;\n    }\n\n    cc.startSourceMapping(n);\n\n    switch (type) {\n      // ... rest of the code is unchanged ...\n\n      // In the case of unary operators, ensure correct precedence\n      // handling. Specifically, handle the 'in' operator with precedence.\n      case Token.TYPEOF:\n      case Token.VOID:\n      case Token.NOT:\n      case Token.BITNOT:\n      case Token.POS: {\n        // All of these unary operators are right-associative\n        Preconditions.checkState(childCount == 1);\n        cc.addOp(NodeUtil.opToStrNoFail(type), false);\n        addExpr(first, NodeUtil.precedence(type), Context.OTHER);\n        break;\n      }\n\n      case Token.NEG: {\n        Preconditions.checkState(childCount == 1);\n\n        // It's important to our sanity checker that the code\n        // we print produces the same AST as the code we parse back.\n        // NEG is a weird case because Rhino parses \"- -2\" as \"2\".\n        if (n.getFirstChild().isNumber()) {\n          cc.addNumber(-n.getFirstChild().getDouble());\n        } else {\n          cc.addOp(NodeUtil.opToStrNoFail(type), false);\n          // Fix for handling 'in' operator inside expressions\n          int negPrecedence = NodeUtil.precedence(type);\n          if (first.getType() == Token.IN) {\n            cc.addOp(\"(\", false);\n            addExpr(first, negPrecedence, Context.OTHER);\n            cc.addOp(\")\", false);\n          } else {\n            addExpr(first, negPrecedence, Context.OTHER);\n          }\n        }\n\n        break;\n      }\n\n      // Handle 'in' operator specifically for inside a FOR loop\n      case Token.IN: {\n        Preconditions.checkState(childCount == 2);\n        if (context == Context.IN_FOR_INIT_CLAUSE || context == Context.IN_FOR_CONDITION) {\n          addExpr(first, NodeUtil.precedence(Token.COMMA), context);\n          cc.addOp(\" in \", true);\n          addExpr(last, NodeUtil.precedence(type), context);\n        } else {\n          addExpr(first, NodeUtil.precedence(type), context);\n          cc.addOp(\" in \", true);\n          addExpr(last, NodeUtil.precedence(type), context);\n        }\n        break;\n      }\n\n      // ... rest of the code is unchanged ...\n      \n      default:\n        throw new Error(\"Unknown type \" + type + \"\\n\" + n.toStringTree());\n    }\n\n    cc.endSourceMapping(n);\n  }",
    "exact_match": false,
    "ast_match": false,
    "compile": false,
    "test": false
}