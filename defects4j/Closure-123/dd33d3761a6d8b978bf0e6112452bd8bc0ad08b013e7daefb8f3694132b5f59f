{
    "generation": "void add(Node n, Context context) {\n    if (!cc.continueProcessing()) {\n        return;\n    }\n\n    int type = n.getType();\n    String opstr = NodeUtil.opToStr(type);\n    int childCount = n.getChildCount();\n    Node first = n.getFirstChild();\n    Node last = n.getLastChild();\n\n    // Handle all binary operators\n    if (opstr != null && first != last) {\n        Preconditions.checkState(\n            childCount == 2,\n            \"Bad binary operator \\\"%s\\\": expected 2 arguments but got %s\",\n            opstr, childCount);\n        int p = NodeUtil.precedence(type);\n\n        // For right-hand-side of operations, only pass context if it's\n        // the IN_FOR_INIT_CLAUSE one.\n        Context rhsContext = getContextForNoInOperator(context);\n\n        // Handle associativity.\n        // e.g., if the parse tree is a * (b * c),\n        // we can simply generate a * b * c.\n        if (last.getType() == type &&\n            NodeUtil.isAssociative(type)) {\n            addExpr(first, p, context);\n            cc.addOp(opstr, true);\n            addExpr(last, p, rhsContext);\n        } else if (NodeUtil.isAssignmentOp(n) && NodeUtil.isAssignmentOp(last)) {\n            // Assignments are the only right-associative binary operators.\n            addExpr(first, p, context);\n            cc.addOp(opstr, true);\n            addExpr(last, p, rhsContext);\n        } else {\n            unrollBinaryOperator(n, type, opstr, context, rhsContext, p, p + 1);\n        }\n        return;\n    }\n\n    cc.startSourceMapping(n);\n\n    switch (type) {\n        case Token.TRY: {\n            Preconditions.checkState(first.getNext().isBlock() &&\n                                     !first.getNext().hasMoreThanOneChild());\n            Preconditions.checkState(childCount >= 2 && childCount <= 3);\n\n            add(\"try\");\n            add(first, Context.PRESERVE_BLOCK);\n\n            // Second child contains the catch block, or nothing if there\n            // isn't a catch block.\n            Node catchblock = first.getNext().getFirstChild();\n            if (catchblock != null) {\n                add(catchblock);\n            }\n\n            if (childCount == 3) {\n                add(\"finally\");\n                add(last, Context.PRESERVE_BLOCK);\n            }\n            break;\n        }\n\n        case Token.FOR:\n            if (childCount == 4) {\n                add(\"for(\");\n                if (first.isVar()) {\n                    add(first, Context.IN_FOR_INIT_CLAUSE);\n                } else {\n                    // If the \"in\" operator is in an expression, ensure correct precedence\n                    addExpr(first,\n                        NodeUtil.containsType(first, Token.IN, NodeUtil.MATCH_NOT_FUNCTION)\n                        ? NodeUtil.precedence(Token.IN) \n                        : 0, \n                        Context.IN_FOR_INIT_CLAUSE);\n                }\n                add(\";\");\n                add(first.getNext());\n                add(\";\");\n                add(first.getNext().getNext());\n                add(\")\");\n                addNonEmptyStatement(\n                    last, getContextForNonEmptyExpression(context), false);\n            } else {\n                Preconditions.checkState(childCount == 3);\n                add(\"for(\");\n                add(first);\n                add(\"in\");\n                add(first.getNext());\n                add(\")\");\n                addNonEmptyStatement(\n                    last, getContextForNonEmptyExpression(context), false);\n            }\n            break;\n\n        case Token.HOOK: {\n            Preconditions.checkState(childCount == 3);\n            int p = NodeUtil.precedence(type);\n            Context rhsContext = Context.OTHER;\n            addExpr(first, p + 1, context);\n            cc.addOp(\"?\", true);\n            addExpr(first.getNext(), 1, rhsContext);\n            cc.addOp(\":\", true);\n            addExpr(last, 1, rhsContext);\n            break;\n        }\n\n        case Token.IN:\n            addExpr(first, NodeUtil.precedence(Token.IN), Context.OTHER);\n            cc.addOp(\"in\", true);\n            addExpr(last, NodeUtil.precedence(Token.IN), Context.OTHER);\n            break;\n\n        default:\n            // Pass to original implementation for other cases\n            super.add(n, context);\n            break;\n    }\n\n    cc.endSourceMapping(n);\n}",
    "exact_match": false,
    "ast_match": false,
    "compile": false,
    "test": false
}