{
    "generation": "  void add(Node n, Context context) {\n    if (!cc.continueProcessing()) {\n      return;\n    }\n\n    int type = n.getType();\n    String opstr = NodeUtil.opToStr(type);\n    int childCount = n.getChildCount();\n    Node first = n.getFirstChild();\n    Node last = n.getLastChild();\n\n    // Handle all binary operators\n    if (opstr != null && first != last) {\n      // ...\n      // For right-hand-side of operations, only pass context if it's\n      // the IN_FOR_INIT_CLAUSE one, with a modification:\n      Context rhsContext =\n          (type == Token.IN || context == Context.IN_FOR_INIT_CLAUSE)\n          ? Context.OTHER\n          : getContextForNoInOperator(context);\n      // ...\n\n      // Handle associativity.\n      // e.g. if the parse tree is a * (b * c),\n      // we can simply generate a * b * c.\n      // Modified to handle IN operator\n      if (last.getType() == type &&\n          NodeUtil.isAssociative(type) &&\n          type != Token.IN) {\n        addExpr(first, p, context);\n        cc.addOp(opstr, true);\n        addExpr(last, p, rhsContext);\n      } else if (NodeUtil.isAssignmentOp(n) && NodeUtil.isAssignmentOp(last)) {\n        addExpr(first, p, context);\n        cc.addOp(opstr, true);\n        addExpr(last, p, rhsContext);\n      } else {\n        unrollBinaryOperator(n, type, opstr, context, rhsContext, p, p + 1);\n      }\n      return;\n    }\n\n    // Rest of the function...\n\n    // Handle the IN operator inside a FOR loop initializer\n    if (type == Token.IN && context == Context.IN_FOR_INIT_CLAUSE) {\n      add(\"(\");\n      add(first);\n      cc.addOp(\"in\", true);\n      add(last);\n      add(\")\");\n      return;\n    }\n\n    // Rest of the function...\n  }",
    "exact_match": false,
    "ast_match": false,
    "compile": false,
    "test": false
}