{
    "generation": "/** {@inheritDoc} */\n@Override\nprotected void iterateSimplex(final Comparator<RealPointValuePair> comparator)\n    throws FunctionEvaluationException, OptimizationException, IllegalArgumentException {\n\n    while (true) {\n\n        incrementIterationsCounter();\n\n        // save the original vertex\n        final RealPointValuePair[] original = simplex;\n        final RealPointValuePair best = original[0];\n        final RealPointValuePair worst = original[original.length - 1];\n        final RealPointValuePair secondWorst = original[original.length - 2];\n\n        // perform a reflection step\n        final RealPointValuePair reflected = evaluateNewSimplex(original, 1.0, comparator);\n        if (comparator.compare(reflected, best) < 0 && comparator.compare(reflected, secondWorst) <= 0) {\n            // accept the reflected simplex if it's better than the best and not worse than the second worst\n            simplex = new RealPointValuePair[original.length];\n            System.arraycopy(original, 0, simplex, 0, original.length - 1);\n            simplex[original.length - 1] = reflected;\n        } else if (comparator.compare(reflected, secondWorst) < 0 && comparator.compare(reflected, worst) >= 0) {\n            // accept the reflected simplex if it's between the second worst and the worst\n            simplex = new RealPointValuePair[original.length];\n            System.arraycopy(original, 0, simplex, 0, original.length - 1);\n            simplex[original.length - 1] = reflected;\n        } else if (comparator.compare(reflected, worst) < 0) {\n            // compute the contracted simplex\n            final RealPointValuePair contracted = evaluateNewSimplex(original, gamma, comparator);\n            if (comparator.compare(contracted, worst) < 0) {\n                // accept the contracted simplex if it's better than the worst\n                simplex = new RealPointValuePair[original.length];\n                System.arraycopy(original, 0, simplex, 0, original.length - 1);\n                simplex[original.length - 1] = contracted;\n            } else {\n                // perform a shrink step\n                for (int i = 1; i < simplex.length; i++) {\n                    simplex[i] = new RealPointValuePair(\n                        midpoint(simplex[0].getPoint(), simplex[i].getPoint()),\n                        Double.NaN, false);\n                }\n                evaluateSimplex(comparator);\n            }\n        } else {\n            // compute the expanded simplex\n            final RealPointValuePair expanded = evaluateNewSimplex(original, khi, comparator);\n            if (comparator.compare(expanded, reflected) >= 0) {\n                // accept the expanded simplex if it's at least as good as the reflected\n                simplex = new RealPointValuePair[original.length];\n                System.arraycopy(original, 0, simplex, 0, original.length - 1);\n                simplex[original.length - 1] = expanded;\n            } else {\n                // accept the reflected simplex\n                simplex = new RealPointValuePair[original.length];\n                System.arraycopy(original, 0, simplex, 0, original.length - 1);\n                simplex[original.length - 1] = reflected;\n            }\n        }\n\n        checkConvergence();\n    }\n}\n\nprivate double[] midpoint(final double[] p1, final double[] p2) {\n    final double[] midpoint = new double[p1.length];\n    for (int i = 0; i < p1.length; i++) {\n        midpoint[i] = (p1[i] + p2[i]) / 2.0;\n    }\n    return midpoint;\n}\n\nprivate void evaluateSimplex(final Comparator<RealPointValuePair> comparator)\n    throws FunctionEvaluationException, OptimizationException {\n    for (int i = 0; i < simplex.length; i++) {\n        if (Double.isNaN(simplex[i].getValue())) {\n            simplex[i] = new RealPointValuePair(simplex[i].getPoint(), function.value(simplex[i].getPoint()), false);\n        }\n    }\n    Arrays.sort(simplex, comparator);\n}\n\nprivate void checkConvergence()\n    throws ConvergenceException {\n    if (getIterations() >= getMaxIterations()) {\n        throw new MaxIterationsExceededException(getMaxIterations());\n    }\n    if (getEvaluations() >= getMaxEvaluations()) {\n        throw new MaxEvaluationsExceededException(getMaxEvaluations());\n    }\n    // Additional convergence checks can be added here if necessary\n}",
    "exact_match": false,
    "ast_match": false,
    "compile": false,
    "test": false
}