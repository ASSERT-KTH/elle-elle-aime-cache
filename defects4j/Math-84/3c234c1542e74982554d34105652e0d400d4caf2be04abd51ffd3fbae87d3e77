{
    "generation": "/** {@inheritDoc} */\n@Override\nprotected void iterateSimplex(final Comparator<RealPointValuePair> comparator)\n        throws FunctionEvaluationException, OptimizationException, IllegalArgumentException {\n\n    int iteration = 0;\n    int maxIterations = getMaxIterations();\n    ConvergenceChecker<RealPointValuePair> checker = getConvergenceChecker();\n\n    while (iteration < maxIterations) {\n\n        incrementIterationsCounter();\n        iteration++;\n\n        // Save the original simplex\n        final RealPointValuePair[] original = simplex;\n        final RealPointValuePair best = original[0];\n        final RealPointValuePair worst = original[simplex.length - 1];\n\n        // Perform reflection\n        final RealPointValuePair reflected = evaluateNewSimplex(original, 1.0, comparator);\n        int comparisonReflectedBest = comparator.compare(reflected, best);\n\n        if (comparisonReflectedBest < 0) {\n            // Reflected point is better than the best\n\n            // Perform expansion\n            final RealPointValuePair expanded = evaluateNewSimplex(original, khi, comparator);\n            int comparisonExpandedReflected = comparator.compare(expanded, reflected);\n\n            if (comparisonExpandedReflected < 0) {\n                // Expanded point is better than reflected\n                simplex = evaluateNewSimplex(original, khi, comparator);\n            } else {\n                // Reflected point is better\n                simplex = reflected;\n            }\n        } else {\n            // Reflected point is not better than the best\n\n            // Perform contraction\n            final RealPointValuePair contracted = evaluateNewSimplex(original, gamma, comparator);\n            int comparisonContractedBest = comparator.compare(contracted, best);\n\n            if (comparisonContractedBest < 0) {\n                // Contracted point is better than the best\n                simplex = contracted;\n            } else {\n                // Perform shrinkage\n                simplex = shrinkage(original, best);\n            }\n        }\n\n        // Check convergence\n        if (checker != null) {\n            if (checker.converged(iteration, best, simplex[0])) {\n                return;\n            }\n        }\n    }\n\n    // If maximum iterations reached without convergence\n    throw new OptimizationException(new MaxIterationsExceededException(maxIterations));\n}\n\nprivate RealPointValuePair shrinkage(final RealPointValuePair[] original, final RealPointValuePair best) {\n    final RealPointValuePair[] newSimplex = new RealPointValuePair[original.length];\n    newSimplex[0] = best;\n    for (int i = 1; i < original.length; i++) {\n        final double[] ShrunkPoint = new double[best.getPoint().length];\n        for (int j = 0; j < best.getPoint().length; j++) {\n            ShrunkPoint[j] = best.getPoint()[j] + sigma * (original[i].getPoint()[j] - best.getPoint()[j]);\n        }\n        newSimplex[i] = computeObjectiveValue(ShrunkPoint);\n    }\n    return newSimplex;\n}",
    "exact_match": false,
    "ast_match": false,
    "compile": false,
    "test": false
}