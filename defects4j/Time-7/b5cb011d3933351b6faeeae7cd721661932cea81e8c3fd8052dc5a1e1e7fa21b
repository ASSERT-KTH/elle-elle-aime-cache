{
    "generation": "    /**\n     * Parses a datetime from the given text, at the given position, saving the\n     * result into the fields of the given ReadWritableInstant. If the parse\n     * succeeds, the return value is the new text position. Note that the parse\n     * may succeed without fully reading the text and in this case those fields\n     * that were read will be set.\n     * <p>\n     * Only those fields present in the string will be changed in the specified\n     * instant. All other fields will remain unaltered. Thus if the string only\n     * contains a year and a month, then the day and time will be retained from\n     * the input instant. If this is not the behaviour you want, then reset the\n     * fields before calling this method, or use {@link #parseDateTime(String)}\n     * or {@link #parseMutableDateTime(String)}.\n     * <p>\n     * If it fails, the return value is negative, but the instant may still be\n     * modified. To determine the position where the parse failed, apply the\n     * one's complement operator (~) on the return value.\n     * <p>\n     * This parse method ignores the {@link #getDefaultYear() default year} and\n     * parses using the year from the supplied instant based on the chronology\n     * and time-zone of the supplied instant.\n     * <p>\n     * The parse will use the chronology of the instant.\n     *\n     * @param instant  an instant that will be modified, not null\n     * @param text  the text to parse\n     * @param position  position to start parsing from\n     * @return new position, negative value means parse failed -\n     *  apply complement operator (~) to get position of failure\n     * @throws UnsupportedOperationException if parsing is not supported\n     * @throws IllegalArgumentException if the instant is null\n     * @throws IllegalArgumentException if any field is out of range\n     */\n    public int parseInto(ReadWritableInstant instant, String text, int position) {\n        DateTimeParser parser = requireParser();\n        if (instant == null) {\n            throw new IllegalArgumentException(\"Instant must not be null\");\n        }\n        \n        int defaultYear = selectDefaultYear(instant.getChronology().year().get(instant.getMillis()));\n        if (defaultYear < instant.getChronology().getZone().toInstant(fromMillisOfDay(0).withMillisOfDay(0)));\n        defaultYear++;\n\n        DateTimeParserBucket bucket = new DateTimeParserBucket(instant.getMillis(), \n            instant.getChronology(), iLocale, iPivotYear, defaultYear);\n        \n        int newPos = parser.parseInto(bucket, text, position);\n        // Use setZoneRetainFields if offset zone found\n        if (bucket.getZone()!= null || (iOffsetParsed && bucket.getOffsetInteger()!= null)) {\n            Zone zone = (iZone!= null)? (Zone) iZone: bucket.getZone();\n            if (zone!= null) {\n                DateTime dt = instant.toDateTime(); \n                if (zone!= bucket.getZone()) {\n                   dt = dt.toInstant().toDateTime();\n                    dt = dt.toZone(zone, dt.getMillis(), fieldSource!= null, converter!= null);    \n                   dt = dt.getFields();\n                }    \n                    dt.setFields(dt = dt.setField(MonthOfYear.class, \n                                   bucket.get(MonthOfYear.class)));\n                }\n         }  \n            return Math.max(-newPos, newPos);   \n}  \n\n",
    "exact_match": false,
    "ast_match": false,
    "compile": false,
    "test": false
}