{
    "generation": "/**\n * Parses a datetime from the given text, at the given position, saving the\n * result into the fields of the given ReadWritableInstant. If the parse\n * succeeds, the return value is the new text position. Note that the parse\n * may succeed without fully reading the text and in this case those fields\n * that were read will be set.\n * <p>\n * Only those fields present in the string will be changed in the specified\n * instant. All other fields will remain unaltered. Thus if the string only\n * contains a year and a month, then the day and time will be retained from\n * the input instant. If this is not the behaviour you want, then reset the\n * fields before calling this method, or use {@link #parseDateTime(String)}\n * or {@link #parseMutableDateTime(String)}.\n * <p>\n * If it fails, the return value is negative, but the instant may still be\n * modified. To determine the position where the parse failed, apply the\n * one's complement operator (~) on the return value.\n * <p>\n * This parse method ignores the {@link #getDefaultYear() default year} and\n * parses using the year from the supplied instant based on the chronology\n * and time-zone of the supplied instant.\n * <p>\n * The parse will use the chronology of the instant.\n *\n * @param instant  an instant that will be modified, not null\n * @param text  the text to parse\n * @param position  position to start parsing from\n * @return new position, negative value means parse failed -\n *  apply complement operator (~) to get position of failure\n * @throws UnsupportedOperationException if parsing is not supported\n * @throws IllegalArgumentException if the instant is null\n * @throws IllegalArgumentException if any field is out of range\n */\npublic int parseInto(ReadWritableInstant instant, String text, int position) {\n    DateTimeParser parser = requireParser();\n    if (instant == null) {\n        throw new IllegalArgumentException(\"Instant must not be null\");\n    }\n    \n    long instantMillis = instant.getMillis();\n    Chronology chrono = instant.getChronology();\n    long instantLocal = instantMillis + chrono.getZone().getOffset(instantMillis);\n    chrono = selectChronology(chrono);\n    \n    // Calculate default year based on the instant's year, not the other way around\n    int defaultYear = (int) (instantMillis / DateTimeConstants.MILLIS_PER_YEAR) + chrono.year().getMinimumValue();\n    \n    DateTimeParserBucket bucket = new DateTimeParserBucket(\n        instantLocal, chrono, iLocale, iPivotYear, defaultYear);\n    int newPos = parser.parseInto(bucket, text, position);\n    \n    // If the parser successfully parsed the date, but the resulting date is invalid (e.g., Feb 29 in non-leap year),\n    // the bucket will contain the invalid values. We need to check if the resulting date is valid before setting it.\n    if (newPos >= 0) {\n        try {\n            chrono.year().checkValid(instantLocal, bucket.computeMillis(false, text), bucket.getResolvedValues());\n            instant.setMillis(bucket.computeMillis(false, text));\n        } catch (IllegalFieldValueException e) {\n            // If the date is invalid, return an error\n            return ~(position + 1);\n        }\n    } else {\n        // If the parser failed, the bucket may still contain some valid values, so let's set them\n        instant.setMillis(bucket.computeMillis(false, text));\n    }\n    \n    if (iOffsetParsed && bucket.getOffsetInteger()!= null) {\n        int parsedOffset = bucket.getOffsetInteger();\n        DateTimeZone parsedZone = DateTimeZone.forOffsetMillis(parsedOffset);\n        chrono = chrono.withZone(parsedZone);\n    } else if (bucket.getZone()!= null) {\n        chrono = chrono.withZone(bucket.getZone());\n    }\n    instant.setChronology(chrono);\n    if (iZone!= null) {\n        instant.setZone(iZone);\n    }\n    return newPos;\n}",
    "exact_match": false,
    "ast_match": false,
    "compile": false,
    "test": false
}