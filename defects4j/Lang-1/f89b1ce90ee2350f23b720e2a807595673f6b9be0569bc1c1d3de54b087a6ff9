{
    "generation": "/**\n * <p>Turns a string value into a java.lang.Number.</p>\n *\n * <p>If the string starts with {@code 0x} or {@code -0x} (lower or upper case) or {@code #} or {@code -#}, it\n * will be interpreted as a hexadecimal Integer - or Long, if the number of digits after the\n * prefix is more than 8 - or BigInteger if there are more than 16 digits.\n * </p>\n * <p>Then, the value is examined for a type qualifier on the end, i.e. one of\n * <code>'f','F','d','D','l','L'</code>.  If it is found, it starts \n * trying to create successively larger types from the type specified\n * until one is found that can represent the value.</p>\n *\n * <p>If a type specifier is not found, it will check for a decimal point\n * and then try successively larger types from <code>Integer</code> to\n * <code>BigInteger</code> and from <code>Float</code> to\n * <code>BigDecimal</code>.</p>\n * \n * <p>\n * Integral values with a leading {@code 0} will be interpreted as octal; the returned number will\n * be Integer, Long or BigDecimal as appropriate.\n * </p>\n *\n * <p>Returns <code>null</code> if the string is <code>null</code>.</p>\n *\n * <p>This method does not trim the input string, i.e., strings with leading\n * or trailing spaces will generate NumberFormatExceptions.</p>\n *\n * @param str  String containing a number, may be null\n * @return Number created from the string (or null if the input is null)\n * @throws NumberFormatException if the value cannot be converted\n */\npublic static Number createNumber(final String str) throws NumberFormatException {\n    if (str == null) {\n        return null;\n    }\n    if (StringUtils.isBlank(str)) {\n        throw new NumberFormatException(\"A blank string is not a valid number\");\n    }\n    // Need to deal with all possible hex prefixes here\n    final String[] hex_prefixes = {\"0x\", \"0X\", \"-0x\", \"-0X\", \"#\", \"-#\"};\n    int pfxLen = 0;\n    for(final String pfx : hex_prefixes) {\n        if (str.startsWith(pfx)) {\n            pfxLen = pfx.length(); // corrected\n            break;\n        }\n    }\n    if (pfxLen > 0) { // we have a hex number\n        final String number = str.substring(pfxLen); // strip the prefix\n        final int hexDigits = number.length();\n        if (hexDigits > 16) { // too many for Long\n            return new BigInteger(number, 16);\n        }\n        if (hexDigits > 8) { // too many for an int\n            return Long.parseLong(number, 16);\n        }\n        return Integer.parseInt(number, 16);\n    }\n    // Rest of the original function...\n}",
    "exact_match": false,
    "ast_match": false,
    "compile": false,
    "test": false
}