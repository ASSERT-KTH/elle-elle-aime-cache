{
    "generation": "protected double acceptStep(final AbstractStepInterpolator interpolator,\n                            final double[] y, final double[] yDot, final double tEnd)\n    throws MaxCountExceededException, DimensionMismatchException, NoBracketingException {\n\n    double previousT = interpolator.getGlobalPreviousTime();\n    final double currentT = interpolator.getGlobalCurrentTime();\n\n    // Initialize the events states if needed\n    if (!statesInitialized) {\n        for (EventState state : eventsStates) {\n            state.reinitializeBegin(interpolator);\n        }\n        statesInitialized = true;\n    }\n\n    // Search for next events that may occur during the step\n    final int orderingSign = interpolator.isForward() ? +1 : -1;\n    SortedSet<EventState> occurringEvents = new TreeSet<>(new Comparator<EventState>() {\n        public int compare(EventState es0, EventState es1) {\n            int cmp = orderingSign * Double.compare(es0.getEventTime(), es1.getEventTime());\n            if (cmp == 0) {\n                // If events occur at the same time, maintain insertion order\n                return Integer.compare(eventsStates.indexOf(es0), eventsStates.indexOf(es1));\n            }\n            return cmp;\n        }\n    });\n\n    for (final EventState state : eventsStates) {\n        if (state.evaluateStep(interpolator)) {\n            occurringEvents.add(state);\n        }\n    }\n\n    double eventT = previousT;\n    boolean stop = false;\n    boolean resetOccurred = false;\n    while (!occurringEvents.isEmpty() && !stop) {\n        // Handle the chronologically first event\n        final Iterator<EventState> iterator = occurringEvents.iterator();\n        final EventState currentEvent = iterator.next();\n        iterator.remove();\n\n        // Restrict the interpolator to the first part of the step, up to the event\n        eventT = currentEvent.getEventTime();\n        interpolator.setSoftPreviousTime(previousT);\n        interpolator.setSoftCurrentTime(eventT);\n\n        // Get state at event time\n        interpolator.setInterpolatedTime(eventT);\n        final double[] eventY = interpolator.getInterpolatedState().clone();\n\n        // Advance all event states to current time\n        for (EventState state : eventsStates) {\n            state.stepAccepted(eventT, eventY);\n        }\n\n        stop = currentEvent.stop();\n\n        // Handle the first part of the step, up to the event\n        for (final StepHandler handler : stepHandlers) {\n            handler.handleStep(interpolator, stop || Precision.equals(eventT, tEnd, 1));\n        }\n\n        if (stop) {\n            // The event asked to stop integration\n            System.arraycopy(eventY, 0, y, 0, y.length);\n            return eventT;\n        }\n\n        boolean needReset = currentEvent.reset(eventT, eventY);\n        if (needReset) {\n            // Some event handler has triggered changes that invalidate the derivatives\n            System.arraycopy(eventY, 0, y, 0, y.length);\n            computeDerivatives(eventT, y, yDot);\n            resetOccurred = true;\n            previousT = eventT;\n            interpolator.setSoftPreviousTime(eventT);\n            interpolator.setSoftCurrentTime(currentT);\n            interpolator.setInterpolatedTime(eventT);\n\n            // Re-evaluate all events after reset\n            occurringEvents.clear();\n            for (final EventState state : eventsStates) {\n                if (state.evaluateStep(interpolator)) {\n                    occurringEvents.add(state);\n                }\n            }\n        } else {\n            // Prepare handling of the remaining part of the step\n            previousT = eventT;\n            interpolator.setSoftPreviousTime(eventT);\n            interpolator.setSoftCurrentTime(currentT);\n\n            // Check if the same event occurs again in the remaining part of the step\n            if (currentEvent.evaluateStep(interpolator)) {\n                occurringEvents.add(currentEvent);\n            }\n        }\n    }\n\n    // Last part of the step, after the last event\n    interpolator.setInterpolatedTime(currentT);\n    final double[] currentY = interpolator.getInterpolatedState();\n    for (final EventState state : eventsStates) {\n        state.stepAccepted(currentT, currentY);\n        stop = stop || state.stop();\n    }\n    stop = stop || Precision.equals(currentT, tEnd, 1);\n\n    // Handle the remaining part of the step, after all events if any\n    for (StepHandler handler : stepHandlers) {\n        handler.handleStep(interpolator, stop);\n    }\n\n    if (resetOccurred) {\n        System.arraycopy(currentY, 0, y, 0, y.length);\n        computeDerivatives(currentT, y, yDot);\n    }\n\n    return currentT;\n}",
    "exact_match": false,
    "ast_match": false,
    "compile": false,
    "test": false
}