{
    "generation": "protected double acceptStep(final AbstractStepInterpolator interpolator,\n                            final double[] y, final double[] yDot, final double tEnd)\n    throws MaxCountExceededException, DimensionMismatchException, NoBracketingException {\n\n    double previousT = interpolator.getGlobalPreviousTime();\n    final double currentT = interpolator.getGlobalCurrentTime();\n\n    // initialize the events states if needed\n    if (!statesInitialized) {\n        for (EventState state : eventsStates) {\n            state.reinitializeBegin(interpolator);\n        }\n        statesInitialized = true;\n    }\n\n    // search for next events that may occur during the step\n    final int orderingSign = interpolator.isForward() ? +1 : -1;\n    SortedSet<EventState> occuringEvents = new TreeSet<EventState>(new Comparator<EventState>() {\n\n        public int compare(EventState es0, EventState es1) {\n            return orderingSign * Double.compare(es0.getEventTime(), es1.getEventTime());\n        }\n\n    });\n\n    for (final EventState state : eventsStates) {\n        if (state.evaluateStep(interpolator)) {\n            occuringEvents.add(state);\n        }\n    }\n\n    while (!occuringEvents.isEmpty()) {\n\n        final Iterator<EventState> iterator = occuringEvents.iterator();\n        final EventState currentEvent = iterator.next();\n        iterator.remove();\n\n        final double eventT = currentEvent.getEventTime();\n        interpolator.setSoftPreviousTime(previousT);\n        interpolator.setSoftCurrentTime(eventT);\n\n        interpolator.setInterpolatedTime(eventT);\n        final double[] eventY = interpolator.getInterpolatedState().clone();\n\n        currentEvent.stepAccepted(eventT, eventY);\n        isLastStep = currentEvent.stop();\n\n        for (final StepHandler handler : stepHandlers) {\n            handler.handleStep(interpolator, isLastStep);\n        }\n\n        if (isLastStep) {\n            System.arraycopy(eventY, 0, y, 0, y.length);\n            for (final EventState remaining : occuringEvents) {\n                remaining.stepAccepted(eventT, eventY);\n            }\n            return eventT;\n        }\n\n        boolean needReset = currentEvent.reset(eventT, eventY);\n        if (needReset) {\n            System.arraycopy(eventY, 0, y, 0, y.length);\n            computeDerivatives(eventT, y, yDot);\n            resetOccurred = true;\n            for (final EventState remaining : occuringEvents) {\n                remaining.stepAccepted(eventT, eventY);\n            }\n            return eventT;\n        }\n\n        previousT = eventT;\n        interpolator.setSoftPreviousTime(eventT);\n        interpolator.setSoftCurrentTime(currentT);\n\n        // Re-evaluate the current event for the remaining part of the step.\n        // This was missing in the original code.\n        if (new TmpEventState(currentEvent, interpolator).evaluateStep(interpolator)) {\n            occuringEvents.add(currentEvent);\n        }\n    }\n\n    interpolator.setInterpolatedTime(currentT);\n    final double[] currentY = interpolator.getInterpolatedState();\n    for (final EventState state : eventsStates) {\n        state.stepAccepted(currentT, currentY);\n        isLastStep = isLastStep || state.stop();\n    }\n    isLastStep = isLastStep || Precision.equals(currentT, tEnd, 1);\n\n    for (StepHandler handler : stepHandlers) {\n        handler.handleStep(interpolator, isLastStep);\n    }\n\n    return currentT;\n}\n\n// Temporary helper class to re-evaluate an event after it has been handled.\nprivate static class TmpEventState implements EventState {\n    private final EventState state;\n    private final AbstractStepInterpolator interpolator;\n\n    TmpEventState(EventState state, AbstractStepInterpolator interpolator) {\n        this.state = state;\n        this.interpolator = interpolator;\n    }\n\n    public boolean evaluateStep(AbstractStepInterpolator interpolator) {\n        return this.state.evaluateStep(interpolator);\n    }\n\n    public void reset(double t, double[] y) {\n        this.state.reset(t, y);\n    }\n\n    public double getEventTime() {\n        return this.state.getEventTime();\n    }\n\n    public void stepAccepted(double t, double[] y) {\n        this.state.stepAccepted(t, y);\n    }\n\n    public boolean stop() {\n        return this.state.stop();\n    }\n\n    @Override\n    public void reinitializeBegin(final AbstractStepInterpolator interpolator) {\n        this.state.reinitializeBegin(interpolator);\n    }\n\n    // Include any other missing or necessary methods here.\n}",
    "exact_match": false,
    "ast_match": false,
    "compile": false,
    "test": false
}