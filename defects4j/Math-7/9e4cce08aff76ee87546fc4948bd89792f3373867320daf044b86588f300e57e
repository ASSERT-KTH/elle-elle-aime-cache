{
    "generation": "    protected double acceptStep(final AbstractStepInterpolator interpolator,\n                                final double[] y, final double[] yDot, final double tEnd)\n            throws MaxCountExceededException, DimensionMismatchException, NoBracketingException {\n\n        double previousT = interpolator.getGlobalPreviousTime();\n        final double currentT = interpolator.getGlobalCurrentTime();\n\n        // initialize the events states if needed\n        if (!statesInitialized) {\n            for (EventState state : eventsStates) {\n                state.reinitializeBegin(interpolator);\n            }\n            statesInitialized = true;\n        }\n\n        // search for next events that may occur during the step\n        final int orderingSign = interpolator.isForward()? +1 : -1;\n        SortedSet<EventState> occurringEvents = new TreeSet<EventState>(new Comparator<EventState>() {\n\n            public int compare(EventState es0, EventState es1) {\n                return orderingSign * Double.compare(es0.getEventTime(), es1.getEventTime());\n            }\n        });\n\n        for (final EventState state : eventsStates) {\n            if (state.evaluateStep(interpolator)) {\n                // the event occurs during the current step\n                occurringEvents.add(state);\n            }\n        }\n\n        while (!occurringEvents.isEmpty()) {\n\n            // handle the chronologically first event\n            final Iterator<EventState> iterator = occurringEvents.iterator();\n            final EventState currentEvent = iterator.next();\n            iterator.remove();\n\n            // restrict the interpolator to the first part of the step, up to the event\n            final double eventT = currentEvent.getEventTime();\n            interpolator.setSoftPreviousTime(previousT);\n            interpolator.setSoftCurrentTime(eventT);\n\n            // get state at event time\n            interpolator.setInterpolatedTime(eventT);\n            final double[] eventY = interpolator.getInterpolatedState().clone();\n\n            // advance all event states to current time\n            currentEvent.stepAccepted(eventT, eventY);\n            isLastStep = currentEvent.stop();\n\n            // handle the first part of the step, up to the event\n            for (final StepHandler handler : stepHandlers) {\n                handler.handleStep(interpolator, isLastStep);\n            }\n\n            if (isLastStep) {\n                // the event asked to stop integration\n                System.arraycopy(eventY, 0, y, 0, y.length);\n                for (final EventState remaining : occurringEvents) {\n                    remaining.stepAccepted(eventT, eventY);\n                }\n                for (EventState statei : eventsStates) { \n                    if (!currentEvent.equals(statei)){\n                        statei.stepAccepted(eventT, eventY);\n                    }\n                }\n\n                return eventT;\n            }\n\n            boolean needReset = currentEvent.reset(eventT, eventY);\n\n            if (needReset) {\n                // some event handler has triggered changes that\n                // invalidate the derivatives, we need to recompute them\n                System.arraycopy(eventY, 0, y, 0, y.length);\n                computeDerivatives(eventT, y, yDot);\n                resetOccurred = true;\n\n                for (EventState statei : eventsStates) { \n                    statei.stepAccepted(eventT, eventY);\n                    if (!currentEvent.equals(statei) && interpolator.isForward()) {\n                    occurringEvents.add(statei);\n                    }\n                }                \n                return eventT;\n            }\n\n            for (EventState state : eventsStates) {      \n                if (state.hasEventOccured()) continue;      \n                state.reschedule(eventT);\n               if (state.evaluateStep(interpolator) &&!(state instanceof ReappearsLater)) {            \n                           occurringEvents.add(state);\n\n                    \n       occurringEvents.add(currentEvent);           \n        }\n\n                }\n                  \n\n            // prepare handling of the remaining part of the step\n            previousT = eventT;      \n            interpolator.setSoftPreviousTime(eventT);\n\n            interpolator.setSoftCurrentTime(currentT);\n\n\n        }\n\n        // handle the last part of the step, after all events \n        for (final StepHandler handler : stepHandlers) {\n            handler.handleStep(interpolator, (isLastStep || shouldLastStepBeHanddeledManually(tEnd)));\n        }\n        \n if (shouldLastStepBeHanddeledManually(tEnd)){\n      tEnd=handleManaulLastStep(previousT);     \n   }\n    void updateStepAndYOnManualStop(previousTdouble previousT);{\n computeDerivatives(previousT, y, ydot);      \n return tPrevios\n      return setSoftCurrenttime(StopValue)\n\n   \n}\n}    \n\nreturn  getcorrectEndtInterPolandReturnEnd(currentT)}\n} \n\n private void onStepFinalPartInterHandManuallyStop(){ finalPartEndEvent} updateFinalpartcurrentime}\n",
    "exact_match": false,
    "ast_match": false,
    "compile": false,
    "test": false
}