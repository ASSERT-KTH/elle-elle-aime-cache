{
    "generation": "/**\n * Fixed version of the _parseIndex function to handle scientific notation.\n *\n * @param str the input string to parse as an index\n * @return the parsed index, or -1 if parsing fails\n */\nprivate final static int _parseIndex(String str) {\n    final int len = str.length();\n    // [Issue#133]: beware of super long indexes; assume we never\n    // have arrays over 2 billion entries so ints are fine.\n    if (len == 0 || len > 10) {\n        return -1;\n    }\n    try {\n        // Attempt to parse the entire string as an integer\n        // This will fail for scientific notation (e.g., 1e0)\n        return Integer.parseInt(str);\n    } catch (NumberFormatException e) {\n        // If parsing as integer fails, check for scientific notation\n        for (int i = 0; i < len; ++i) {\n            char c = str.charAt(i);\n            if (c > '9' || c < '0' || c == 'e' || c == 'E') {\n                // If 'e' or 'E' is found, or if non-digit, fail parsing\n                if (c == 'e' || c == 'E') {\n                    // Special handling for scientific notation: check if it evaluates to an integer\n                    try {\n                        double d = Double.parseDouble(str);\n                        if (d >= Integer.MIN_VALUE && d <= Integer.MAX_VALUE && d == Math.floor(d)) {\n                            return (int) d; // successfully parsed as integer\n                        }\n                    } catch (NumberFormatException ex) {\n                        // Ignore, already knowing it's not a simple integer\n                    }\n                }\n                return -1; // failed parsing\n            }\n        }\n        // This point should not be reachable due to initial parseInt attempt\n        return -1;\n    }\n}",
    "exact_match": false,
    "ast_match": false,
    "compile": true,
    "test": true
}