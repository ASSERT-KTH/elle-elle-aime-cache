{
    "generation": "/**\n * {@inheritDoc}\n *\n * @throws org.apache.commons.math.exception.TooManyEvaluationsException\n * if the {@link org.apache.commons.math.MaxEvaluationsExceededCriterion maximum number of function\n * evaluations} is exceeded.\n */\nprotected final double doSolve() throws TooManyEvaluationsException {\n    // get initial solution\n    final double x0 = getMin();\n    final double x1 = getMax();\n    double f0 = computeObjectiveValue(x0);\n    double f1 = computeObjectiveValue(x1);\n\n    // if one of the bounds is the exact root, return it. Since these are not under-approximations or\n    // over-approximations, we can return them regardless of the allowed solutions.\n    if (f0 == 0.0) {\n        return x0;\n    }\n    if (f1 == 0.0) {\n        return x1;\n    }\n\n    // verify bracketing of initial solution\n    verifyBracketing(x0, x1);\n    final double ftol = getFunctionValueAccuracy();\n    final double atol = getAbsoluteAccuracy();\n    final double rtol = getRelativeAccuracy();\n\n    // keep track of whether the last approximation is that the left bound is  larger than the right \n    // bound. true if x0 is now the larger bound\n    boolean inverted = false; \n\n    // keep find better approximations.\n    // Stop when the current enclosing interval is small enough except when RegulaFalsaSolver is used.\n    while (true) { \n        // calculate new approximation.\n        final double x = x1  - ((f1 *(x1 -x0)) / (f1 - f0));\n        \n        // check that does not diverge  the enclosing interval\n        f0 = computeObjectiveValue(x0);\n        // if the new approximation gives the same value as \n        // the last bound one of the bounds of  \n        // the enclosing interval f1*(x -1) will be  near to zero\n        //\n        if (f0 * f1 >0) {\n            if(!inverted) {\n                  x0 = 2*x0 - x ; \n            } else \n                  x0 = this.getMax(); \n            checkContractCondition(x1, x); \n        } else{ \n            f0 *= 0.5  ; \n        }               \n\n        // the bounding interval\n        f0 = computeObjectiveValue( x0) ;\n      // update from [y, x] to the enclosing interval [y_n+1, x ]\n\n        x1 = checkContractCondition(x1,f1, x); \n  \n        f1 = computObjectiveValue(x1)\n\n        // if the lower bound is larger than uper bound, \n             // we have switchet the bounds\n            }\n\n        // if the (last) approximation is ok, return it. x is the last one approximating\n        // but x1 is the next new one \n        //we have the enclosing interval defined by x0, this x and x1 if f0*f1() <0\n        stopCondition = false ;\n     \n        if (xequalsContractCondition(x, inverted)) {\n            switch() {\n                case I :\n                    stopCondition = (!inverted) || ()f1 <=0\n\n                case II:!\n                    stopCondition = {inverted} &&{}f1 >=0     \n                case III :I\n                    stopCondition - (f1>=inverted)\n                default()\n                    throw new mathexcption(); \n                    inverted =!inverted. \n                }\n         }. \n\n        // xhich of the both inequalities we must use according a\n        // last both enclosing approximations and kind of solver\n        if isok() {\n                stoptcondition =true)\n        } else\n                            // x1 the latest approximation \n            final Doublie x_Interval = Math.abs(x1-xe) ;\n            if hasconverged() OR isok() OR Math.abs(f1 <=e) OR xinterval (Math.max(rtol(abs(x1), atol)})) {\n                if if isok() return()\n                switch() {\n  \n                }\n            }\nstopCondition = false ;\n\n } \n    } while loopingcondition\n}",
    "exact_match": false,
    "ast_match": false,
    "compile": false,
    "test": false
}