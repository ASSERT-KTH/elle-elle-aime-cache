{
    "generation": "protected final double doSolve() {\n    // Get initial solution\n    double x0 = getMin();\n    double x1 = getMax();\n    double f0 = computeObjectiveValue(x0);\n    double f1 = computeObjectiveValue(x1);\n\n    // If one of the bounds is the exact root, return it. Since these are\n    // not under-approximations or over-approximations, we can return them\n    // regardless of the allowed solutions.\n    if (f0 == 0.0) {\n        return x0;\n    }\n    if (f1 == 0.0) {\n        return x1;\n    }\n\n    // Verify bracketing of initial solution.\n    verifyBracketing(x0, x1);\n\n    // Get accuracies.\n    final double ftol = getFunctionValueAccuracy();\n    final double atol = getAbsoluteAccuracy();\n    final double rtol = getRelativeAccuracy();\n\n    // Keep track of inverted intervals, meaning that the left bound is\n    // larger than the right bound.\n    boolean inverted = false;\n\n    // Keep finding better approximations.\n    while (true) {\n        // Calculate the next approximation.\n        final double x = x1 - ((f1 * (x1 - x0)) / (f1 - f0));\n        final double fx = computeObjectiveValue(x);\n\n        // If the new approximation is the exact root, return it. Since\n        // this is not an under-approximation or an over-approximation,\n        // we can return it regardless of the allowed solutions.\n        if (fx == 0.0) {\n            return x;\n        }\n\n        // Check if f0 and fx have different signs\n        boolean haveDifferentSigns = (f0 < 0) ^ (fx < 0);\n\n        // Update the bounds with the new approximation.\n        if (!haveDifferentSigns) {\n            f0 *= 0.5; // Illinois' f0 adjustment\n            switch (method) {\n                case ILLINOIS:\n                    break;\n                case PEGASUS:\n                    f0 = f0 * f1 / (f1 + fx);\n                    break;\n                case REGULA_FALSI:\n                    break;\n                default:\n                    // Should never happen.\n                    throw new MathInternalError();\n            }\n            // keep x0 in range, don't let new approx fall outside of min max values\n            double possibleX0 = x - f0 * (x1 - x0) / (f1 - f0);\n            double truncatedX0 = Math.max(Math.min(possibleX0, getMax()), getMin());\n            x0 = truncatedX0;\n            f0 = computeObjectiveValue(x0);\n\n            x1 = x;\n            f1 = fx;\n\n        } else {\n            x0 = x;\n            f0 = fx;\n        }\n        if (FastMath.abs(x1 - x0) < FastMath.max(rtol * FastMath.abs(x1),\n                atol)) {\n            // Handle \"allowed\" enum according to original code or requirement in the task or leave your comment.\n        }\n        if (increaseCpt(maxEvaluationsExceeded)) {\n            //handle TooManyEvaluationsException\n            break;\n        }\n    }\n}",
    "exact_match": false,
    "ast_match": false,
    "compile": false,
    "test": false
}