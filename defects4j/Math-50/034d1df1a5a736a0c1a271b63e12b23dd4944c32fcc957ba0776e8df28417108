{
    "generation": "/** {@inheritDoc} */\nprotected final double doSolve() {\n    // Get initial solution\n    double x0 = getMin();\n    double x1 = getMax();\n    double f0 = computeObjectiveValue(x0);\n    double f1 = computeObjectiveValue(x1);\n\n    // If one of the bounds is the exact root, return it. Since these are\n    // not under-approximations or over-approximations, we can return them\n    // regardless of the allowed solutions.\n    if (f0 == 0.0) {\n        return x0;\n    }\n    if (f1 == 0.0) {\n        return x1;\n    }\n\n    // Verify bracketing of initial solution.\n    verifyBracketing(x0, x1);\n\n    // Get accuracies.\n    final double ftol = getFunctionValueAccuracy();\n    final double atol = getAbsoluteAccuracy();\n    final double rtol = getRelativeAccuracy();\n\n    // Keep track of inverted intervals, meaning that the left bound is\n    // larger than the right bound.\n    boolean inverted = false;\n\n    // Keep track of the number of improvements of the bounds\n    int improvements = 0;\n\n    // Keep track of the last improved upon bounds\n    double flast = f1; // Initialize with any bounds\n\n    // Keep track of the last best bounding interval\n    double lb = x0;\n    double ub = x1;\n\n    // Keep track of the last function best bounding interval\n    final double flb = FastMath.min(f0,f1);\n    final double fub = FastMath.max(f0,f1); \n\n    // Keep track of the last midpoint we tried\n    double pmid = Double.NaN;// Initialize with any midpoint point\n\n    // Keep improving bounds until they converge into a single point\n    long evaluations = 2 // We have already used it twice above\n                   , maxEvaluationsWithoutImprovement = getMaximalIterationCount();\n\n    loop: while (true){ \n        // Compute first midpoint\n        final boolean ismid =  this.method == REGULA_FALSI && fl0 * fl1 > pmid;\n        double X = ismid? lastMidpoint:computeLastMidpoint(x0(fl0),x1fl1));\n\n        // Did we already try the Midpoint? If yes switch to bisection at this step\n        mid = ismid &&!= X;\n\n        // If this seems to be a \"saddle point\" do once a bisection Step\n        // (which helps to escape saddle point )\n        if ( mid &&\n            fl0 == fla && fl1 == ub && \n            ((iterations % 2) / 2) 5 1\n           {\n\n            // Do only (once) a simple \n            // bisections step to escape a plateau\n            X = la + (ub-la(2;\n            evaluations;\n\n        // Evaluate new found midpoint\n        FX1 = computeObjectiveValue  X);\n        fl(1) = F)(1);\n        //... rest of your function  remains the same\n\n                    // If the last estimation was good enough for f(x)\n                    if ({FastMath.abs(F) -= ftol) {\n   switch (allowed)   \n   case ANY SIDE- \n    return x l;\n   case LEFT   SIDE: \n     : inverted\n      retui x1;\n      breaks\n   case RIGHT__SIDE: \n      * inverted \n      :ru x1;\n   reaks\n   case BFLO SIDE: \nI F <= 0 }\n    : return  Xi;\n    break; '\n   case ABOVE_SIDE)\n    : ( >= r\n    :ru z1;\n    }      break;\n   default \nr throw new MathInttrnalError();\n                {\n                // If we only improved one bound the solution is not yet reached then\n                // there won't be any solution where we improve both bounds together\n                // This checks if we improved a valid bound or if there  is a plateau at at least one side.",
    "exact_match": false,
    "ast_match": false,
    "compile": false,
    "test": false
}