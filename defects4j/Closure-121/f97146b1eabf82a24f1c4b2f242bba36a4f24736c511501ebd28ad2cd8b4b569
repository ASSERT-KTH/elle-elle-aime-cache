{
    "generation": "private void inlineNonConstants(\n    Var v, ReferenceCollection referenceInfo,\n    boolean maybeModifiedArguments) {\n  if (referenceInfo.isAssignedOnceInLifetime() || checkOnlyInitializedOnce(referenceInfo)) {\n    // rest of the function\n\n    // If this variable was not inlined normally, check if we can\n    // inline an alias of it.\n    if (!maybeModifiedArguments &&\n        !staleVars.contains(v) &&\n        referenceInfo.isWellDefined()) {\n      List<Reference> refs = referenceInfo.references;\n      for (int i = 1 /* start from a read */; i < refs.size(); i++) {\n        Node nameNode = refs.get(i).getNode();\n        if (aliasCandidates.containsKey(nameNode)) {\n          AliasCandidate candidate = aliasCandidates.get(nameNode);\n          if (!staleVars.contains(candidate.alias) &&\n              !isVarInlineForbidden(candidate.alias) &&\n              checkOnlyInitializedOnce(candidate.refInfo)) { // added this line\n            Reference aliasInit;\n            aliasInit = candidate.refInfo.getInitializingReference();\n            Node value = aliasInit.getAssignedValue();\n            Preconditions.checkNotNull(value);\n            inlineWellDefinedVariable(candidate.alias,\n                value,\n                candidate.refInfo.references);\n            staleVars.add(candidate.alias);\n          }\n        }\n      }\n    }\n  }\n}\n\n// new method to check if a variable is initialized only once\nprivate boolean checkOnlyInitializedOnce(ReferenceCollection referenceInfo) {\n  Reference initializingReference = referenceInfo.getInitializingReference();\n  return initializingReference != null && referenceInfo.references.size() == 2\n      && referenceInfo.references.contains(initializingReference);\n}",
    "exact_match": false,
    "ast_match": false,
    "compile": true,
    "test": false
}