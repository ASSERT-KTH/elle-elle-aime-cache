{
    "generation": "private void inlineNonConstants(\n    Var v, ReferenceCollection referenceInfo,\n    boolean maybeModifiedArguments) {\n  int refCount = referenceInfo.references.size();\n  Reference declaration = referenceInfo.references.get(0);\n  Reference init = referenceInfo.getInitializingReference();\n  int firstRefAfterInit = (declaration == init)? 2 : 3;\n\n  if (refCount > 1 &&\n      isImmutableAndWellDefinedVariable(v, referenceInfo)) {\n    Node value;\n    if (init!= null) {\n      value = init.getAssignedValue();\n    } else {\n      Node srcLocation = declaration.getNode();\n      value = NodeUtil.newUndefinedNode(srcLocation);\n    }\n    Preconditions.checkNotNull(value);\n    inlineWellDefinedVariable(v, value, referenceInfo.references);\n    staleVars.add(v);\n  } else if (refCount == firstRefAfterInit) {\n    Reference reference = referenceInfo.references.get(\n        firstRefAfterInit - 1);\n    if (canInline(declaration, init, reference)) {\n      inline(v, declaration, init, reference);\n      staleVars.add(v);\n    }\n  } else if (declaration!= init && refCount == 2) {\n    if (isValidDeclaration(declaration) && isValidInitialization(init)) {\n      Node value = init.getAssignedValue();\n      Preconditions.checkNotNull(value);\n      inlineWellDefinedVariable(v, value, referenceInfo.references);\n      staleVars.add(v);\n    }\n  }\n\n  // FIX: Check if the variable is aliased and the alias is mutable\n  // before attempting to inline based solely on well-defined and assigned once\n  if (!maybeModifiedArguments &&\n     !staleVars.contains(v) &&\n      referenceInfo.isWellDefined() &&\n      referenceInfo.isAssignedOnceInLifetime()) {\n    if (v.isConstant() ||!hasMutableAlias(v, referenceInfo)) {\n      List<Reference> refs = referenceInfo.references;\n      for (int i = 1 /* start from a read */; i < refs.size(); i++) {\n        Node nameNode = refs.get(i).getNode();\n        if (aliasCandidates.containsKey(nameNode)) {\n          AliasCandidate candidate = aliasCandidates.get(nameNode);\n          if (!staleVars.contains(candidate.alias) &&\n             !isVarInlineForbidden(candidate.alias)) {\n            Reference aliasInit;\n            aliasInit = candidate.refInfo.getInitializingReference();\n            Node value = aliasInit.getAssignedValue();\n            Preconditions.checkNotNull(value);\n            inlineWellDefinedVariable(candidate.alias,\n                value,\n                candidate.refInfo.references);\n            staleVars.add(candidate.alias);\n          }\n        }\n      }\n    }\n  }\n}\n\n// Added helper method to check for mutable aliases\nprivate boolean hasMutableAlias(Var v, ReferenceCollection referenceInfo) {\n  List<Reference> refs = referenceInfo.references;\n  for (Reference ref : refs) {\n    Node nameNode = ref.getNode();\n    if (aliasCandidates.containsKey(nameNode)) {\n      AliasCandidate candidate = aliasCandidates.get(nameNode);\n      if (!candidate.alias.isConstant() && \n         !candidate.refInfo.isImmutableAndWellDefinedVariable()) {\n        return true;\n      }\n    }\n  }\n  return false;\n}",
    "exact_match": false,
    "ast_match": false,
    "compile": false,
    "test": false
}