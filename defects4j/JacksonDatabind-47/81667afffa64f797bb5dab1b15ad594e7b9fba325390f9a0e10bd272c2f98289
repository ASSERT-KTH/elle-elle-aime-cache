{
    "generation": "public JavaType refineSerializationType(final MapperConfig<?> config,\n        final Annotated a, final JavaType baseType) throws JsonMappingException\n{\n    JavaType type = baseType;\n    final TypeFactory tf = config.getTypeFactory();\n\n    //... (rest of the function remains the same)\n\n    // Then further processing for container types\n\n    JavaType contentType = type.getContentType();\n    if (contentType!= null) { \n        // And then value types for all containers:\n       Class<?> contentClass = findSerializationContentType(a, contentType);\n       if (contentClass!= null) {\n           if (contentType.hasRawClass(contentClass)) {\n               contentType = contentType.withStaticTyping();\n           } else {\n               Class<?> currRaw = contentType.getRawClass();\n               try {\n                   // Fix: we should swap the order of the conditions here\n                   if (currRaw.isAssignableFrom(contentClass)) { \n                       contentType = tf.constructSpecializedType(contentType, contentClass);\n                   } else if (contentClass.isAssignableFrom(currRaw)) { \n                       contentType = tf.constructGeneralizedType(contentType, contentClass);\n                   } else {\n                       throw new JsonMappingException(null,\n                               String.format(\"Can not refine serialization content type %s into %s; types not related\",\n                                       contentType, contentClass.getName()));\n                   }\n               } catch (IllegalArgumentException iae) { \n                   throw new JsonMappingException(null,\n                           String.format(\"Internal error: failed to refine value type of %s with concrete-type annotation (value %s), from '%s': %s\",\n                                   type, contentClass.getName(), a.getName(), iae.getMessage()),\n                                   iae);\n               }\n           }\n           type = type.withContentType(contentType);\n       }\n    }\n    return type;\n}",
    "exact_match": false,
    "ast_match": false,
    "compile": true,
    "test": false
}