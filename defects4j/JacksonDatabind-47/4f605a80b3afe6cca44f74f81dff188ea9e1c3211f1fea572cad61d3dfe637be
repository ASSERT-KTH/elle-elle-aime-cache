{
    "generation": "/**\n * Method called to find out possible type refinements to use\n * for deserialization.\n *\n * @since 2.7\n */\npublic JavaType refineSerializationType(final MapperConfig<?> config,\n        final Annotated a, final JavaType baseType) throws JsonMappingException\n{\n    JavaType type = baseType;\n    final TypeFactory tf = config.getTypeFactory();\n    \n    //... (rest of the function remains the same until here)\n\n    // Then further processing for non-container types\n    if (!type.isContainerType()) {\n        Class<?> serClass = findSerializationType(a);\n        if (serClass!= null) {\n            if (type.hasRawClass(serClass)) {\n                type = type.withStaticTyping();\n            } else {\n                Class<?> rawClass = type.getRawClass();\n                if (rawClass.isAssignableFrom(serClass)) {\n                    // Introduce fix: Allow widening from a subclass to its superclass\n                    type = tf.constructGeneralizedType(type, serClass);\n                } else if (serClass.isAssignableFrom(rawClass)) {\n                    // Specialization, ok as well\n                    type = tf.constructSpecializedType(type, serClass);\n                } else {\n                    throw new JsonMappingException(null,\n                            String.format(\"Can not refine serialization type %s into %s; types not related\",\n                                    type, serClass.getName()));\n                }\n            }\n        }\n    }\n\n    // Then further processing for container types (rest of the function remains the same)\n    //... (rest of the function remains the same)\n}",
    "exact_match": false,
    "ast_match": false,
    "compile": false,
    "test": false
}