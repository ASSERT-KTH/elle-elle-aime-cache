{
    "generation": "/**\n * Internal calculation method.\n *\n * @param val  the calendar\n * @param field  the field constant\n * @param round  true to round, false to truncate\n * @throws ArithmeticException if the year is over 280 million\n */\nprivate static void modify(Calendar val, int field, boolean round) {\n    if (val.get(Calendar.YEAR) > 280000000) {\n        throw new ArithmeticException(\"Calendar value too large for accurate calculations\");\n    }\n\n    if (field == Calendar.MILLISECOND) {\n        return;\n    }\n\n    Date date = val.getTime();\n    long time = date.getTime();\n    boolean done = false;\n\n    // truncate milliseconds\n    int millisecs = val.get(Calendar.MILLISECOND);\n    if (!round || millisecs < 500) {\n        time = time - millisecs;\n        if (field == Calendar.SECOND) {\n            done = true;\n        }\n    }\n\n    // truncate seconds\n    int seconds = val.get(Calendar.SECOND);\n    if (!done) {\n        time = time - (seconds * 1000L);\n        if (!round || seconds < 30) {\n            if (field == Calendar.MINUTE) {\n                done = true;\n            }\n        } else {\n            time += 60 * 1000L;\n        }\n    }\n\n    // truncate minutes\n    int minutes = val.get(Calendar.MINUTE);\n    if (!done && field == Calendar.HOUR_OF_DAY) {\n        time = time - (minutes * 60000L);\n        if (round && minutes >= 30) {\n            time += 60 * 60 * 1000L;\n        }\n        done = true;\n    }\n\n    // reset time\n    if (date.getTime() != time) {\n        date.setTime(time);\n        val.setTime(date);\n    }\n\n    // ... the rest of your function remains the same\n}",
    "exact_match": false,
    "ast_match": false,
    "compile": true,
    "test": false
}