{
    "generation": "/**\n * Creates a printer that will print values to the given stream following the CSVFormat.\n * <p>\n * Currently, only a pure encapsulation format or a pure escaping format is supported. Hybrid formats (encapsulation\n * and escaping with a different character) are not supported.\n * </p>\n * \n * @param out\n *        stream to which to print. Must not be null.\n * @param format\n *        the CSV format. Must not be null.\n * @throws IOException\n *         thrown if the optional header cannot be printed.\n * @throws IllegalArgumentException\n *         thrown if the parameters of the format are inconsistent or if either out or format are null.\n */\npublic CSVPrinter(final Appendable out, final CSVFormat format) throws IOException {\n    Assertions.notNull(out, \"out\");\n    Assertions.notNull(format, \"format\");\n\n    this.out = out;\n    this.format = format;\n    this.format.validate();\n\n    // Automatically print the header if it's defined in the format\n    if (format.getHeaders()!= null &&!format.getHeaders().isEmpty()) {\n        printHeader(format.getHeaders());\n    }\n}\n\n// Assuming the printHeader method is already defined elsewhere in the class\n// If not, here's a simple implementation for reference\n// private void printHeader(String[] headers) throws IOException {\n//     for (int i = 0; i < headers.length; i++) {\n//         if (i > 0) {\n//             out.append(format.getDelimiter());\n//         }\n//         out.append(format.printHeader(headers[i]));\n//     }\n//     out.append(format.getRecordSeparator());\n// }",
    "exact_match": false,
    "ast_match": false,
    "compile": false,
    "test": false
}