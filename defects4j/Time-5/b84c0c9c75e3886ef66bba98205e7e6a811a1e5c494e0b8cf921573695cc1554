{
    "generation": "public Period normalizedStandard(PeriodType type) {\n    type = DateTimeUtils.getPeriodType(type);\n    boolean supportsYears = type.hasYears();\n    boolean supportsMonths = type.hasMonths();\n    boolean supportsWeeks = type.hasWeeks();\n    boolean supportsDays = type.hasDays();\n    boolean supportsHours = type.hasHours();\n    boolean supportsMinutes = type.hasMinutes();\n    boolean supportsSeconds = type.hasSeconds();\n    boolean supportsMillis = type.hasMillis();\n\n    int years = getYears();\n    int months = getMonths();\n    int weeks = getWeeks();\n    int days = getDays();\n    int hours = getHours();\n    int minutes = getMinutes();\n    int seconds = getSeconds();\n    int millis = getMillis();\n\n    // Normalize years and months if supported, or convert years to months if only months are supported\n    if (supportsYears && supportsMonths) {\n        years = FieldUtils.safeAdd(years, months / 12);\n        months = months % 12;\n    } else if (!supportsYears && supportsMonths) {\n        months = FieldUtils.safeAdd(months, years * 12);\n        years = 0;\n    }\n\n    // Convert days to weeks and days if weeks are supported\n    if (supportsWeeks && supportsDays) {\n        weeks = FieldUtils.safeAdd(weeks, days / 7);\n        days = days % 7;\n    } else if (supportsWeeks && !supportsDays) {\n        weeks = FieldUtils.safeAdd(weeks, days / 7);\n        days = 0;\n    }\n\n    // Create the result period with the adjusted values for supported fields\n    return new Period(\n            supportsYears ? years : 0,\n            supportsMonths ? months : 0,\n            supportsWeeks ? weeks : 0,\n            supportsDays ? days : 0,\n            supportsHours ? hours : 0,\n            supportsMinutes ? minutes : 0,\n            supportsSeconds ? seconds : 0,\n            supportsMillis ? millis : 0,\n            type);\n}",
    "exact_match": false,
    "ast_match": false,
    "compile": false,
    "test": false
}