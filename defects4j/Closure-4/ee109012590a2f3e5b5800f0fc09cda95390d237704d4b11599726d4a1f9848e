{
    "generation": "/**\n * Resolve the referenced type within the enclosing scope.\n */\n@Override\nJSType resolveInternal(ErrorReporter t, StaticScope<JSType> enclosing) {\n    // Check if the type is already being resolved to avoid infinite recursion\n    if (isResolved() || registry.isInResolution(this)) {\n        return registry.isLastGeneration() ? getReferencedType() : this;\n    }\n\n    // Mark the type as currently being resolved\n    registry.markInResolution(this);\n\n    try {\n        // First, try resolving via the registry\n        boolean resolved = resolveViaRegistry(t, enclosing);\n        if (detectImplicitPrototypeCycle()) {\n            handleTypeCycle(t);\n        }\n\n        if (resolved) {\n            super.resolveInternal(t, enclosing);\n            finishPropertyContinuations();\n            return registry.isLastGeneration() ? getReferencedType() : this;\n        }\n\n        // If resolution via registry failed, try resolving via properties\n        resolveViaProperties(t, enclosing);\n        if (detectImplicitPrototypeCycle()) {\n            handleTypeCycle(t);\n        }\n\n        super.resolveInternal(t, enclosing);\n        if (isResolved()) {\n            finishPropertyContinuations();\n        }\n    } finally {\n        // Unmark the type as being resolved\n        registry.unmarkInResolution(this);\n    }\n\n    return registry.isLastGeneration() ? getReferencedType() : this;\n}",
    "exact_match": false,
    "ast_match": false,
    "compile": false,
    "test": false
}