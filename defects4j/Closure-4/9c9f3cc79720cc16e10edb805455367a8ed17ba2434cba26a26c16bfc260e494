{
    "generation": "/**\n * Resolve the referenced type within the enclosing scope.\n */\n@Override\nJSType resolveInternal(ErrorReporter t, StaticScope<JSType> enclosing) {\n    // Use a Set to keep track of visited types to detect cycles\n    Set<JSType> visited = new HashSet<>();\n\n    // Recursive helper function to resolve types and detect cycles\n    JSType resolveHelper(JSType type) {\n        if (type == null || visited.contains(type)) {\n            return type; // Cycle detected or type already resolved\n        }\n        visited.add(type);\n\n        boolean resolvedViaRegistry = type.resolveViaRegistry(t, enclosing);\n        if (resolvedViaRegistry) {\n            type.finishPropertyContinuations();\n            return registry.isLastGeneration() ? type.getReferencedType() : type;\n        }\n\n        type.resolveViaProperties(t, enclosing);\n        type.finishPropertyContinuations();\n        return registry.isLastGeneration() ? type.getReferencedType() : type;\n    }\n\n    JSType resolvedType = resolveHelper(this);\n    if (resolvedType != null) {\n        super.resolveInternal(t, enclosing);\n        return resolvedType;\n    }\n\n    // Handle type cycle\n    if (detectImplicitPrototypeCycle()) {\n        handleTypeCycle(t);\n    }\n\n    // If still unresolved, try resolving super type\n    super.resolveInternal(t, enclosing);\n    return registry.isLastGeneration() ? getReferencedType() : this;\n}",
    "exact_match": false,
    "ast_match": false,
    "compile": false,
    "test": false
}