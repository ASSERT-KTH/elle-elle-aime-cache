{
    "generation": "private void injectMockCandidate(Class<?> awaitingInjectionClazz, Set<Object> mocks, Object fieldInstance) {\n    List<Field> fields = orderedInstanceFieldsFrom(awaitingInjectionClazz);\n    for (Field field : fields) {\n        List<Object> matchingMocks = new ArrayList<>();\n        for (Object mock : mocks) {\n            if (field.getType().isAssignableFrom(mock.getClass())) {\n                matchingMocks.add(mock);\n            }\n        }\n        \n        if (!matchingMocks.isEmpty()) {\n            // Sort matching mocks by type specificity (more specific types first)\n            matchingMocks.sort((a, b) -> {\n                int depthA = getInheritanceDepth(a.getClass(), field.getType());\n                int depthB = getInheritanceDepth(b.getClass(), field.getType());\n                return Integer.compare(depthA, depthB);\n            });\n            \n            // Inject the most specific mock\n            try {\n                field.setAccessible(true);\n                field.set(fieldInstance, matchingMocks.get(0));\n            } catch (IllegalAccessException e) {\n                throw new RuntimeException(\"Failed to set field value\", e);\n            }\n        }\n    }\n}\n\n// Helper method to calculate inheritance depth\nprivate int getInheritanceDepth(Class<?> from, Class<?> to) {\n    if (from == to) {\n        return 0;\n    }\n    if (from == null || from == Object.class) {\n        return Integer.MAX_VALUE;\n    }\n    return 1 + getInheritanceDepth(from.getSuperclass(), to);\n}",
    "exact_match": false,
    "ast_match": false,
    "compile": false,
    "test": false
}