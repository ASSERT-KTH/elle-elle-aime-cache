{
    "generation": "    private void injectMockCandidate(Class<?> awaitingInjectionClazz, Set<Object> mocks, Object fieldInstance) {\n        // Use a map to track the best matching mock for each field\n        Map<Field, Injectable> bestMatches = new HashMap<>();\n\n        for(Field field : orderedInstanceFieldsFrom(awaitingInjectionClazz)) {\n            Injectable bestCandidate = null;\n            for (Object mock : mocks) {\n                if (field.getType().isInstance(mock)) {\n                    if (bestCandidate == null || isBetterMatch(bestCandidate, mock, field)) {\n                        bestCandidate = new Injectable(mock, field);\n                    }\n                }\n            }\n            if (bestCandidate != null) {\n                bestMatches.put(field, bestCandidate);\n            }\n        }\n\n        for (Injectable injectable : bestMatches.values()) {\n            injectable.inject();\n        }\n    }\n\n    private class Injectable {\n        private final Object mock;\n        private final Field field;\n\n        public Injectable(Object mock, Field field) {\n            this.mock = mock;\n            this.field = field;\n        }\n\n        public void inject() {\n            mockCandidateFilter.filterCandidate(Collections.singleton(mock), field, fieldInstance).thenInject();\n        }\n    }\n\n    private boolean isBetterMatch(Injectable currentBest, Object newCandidate, Field field) {\n        return field.getType().equals(newCandidate.getClass());\n    }",
    "exact_match": false,
    "ast_match": false,
    "compile": false,
    "test": false
}