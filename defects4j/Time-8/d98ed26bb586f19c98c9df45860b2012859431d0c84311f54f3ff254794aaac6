{
    "generation": "/**\n * Gets a time zone instance for the specified offset to UTC in hours and minutes.\n * This method assumes 60 minutes in an hour, and standard length minutes.\n * <p>\n * This factory is a convenient way of constructing zones with a fixed offset.\n * The hours value must be in the range -23 to +23.\n * The minutes value must be in the range -59 to +59.\n * The following combinations of sign for the hour and minute are possible:\n * <pre>\n *  Hour    Minute    Example    Result\n * \n *  +ve     +ve       (2, 15)    +02:15\n *  +ve     zero      (2, 0)     +02:00\n *  +ve     -ve       (2, -15)   IllegalArgumentException\n * \n *  zero    +ve       (0, 15)    +00:15\n *  zero    zero      (0, 0)     +00:00\n *  zero    -ve       (0, -15)   -00:15\n * \n *  -ve     +ve       (-2, 15)   -02:15\n *  -ve     zero      (-2, 0)    -02:00\n *  -ve     -ve       (-2, -15)  -02:15\n * </pre>\n * Note that in versions before 2.3, the minutes had to be zero or positive.\n * \n * @param hoursOffset  the offset in hours from UTC, from -23 to +23\n * @param minutesOffset  the offset in minutes from UTC, from -59 to +59\n * @return the DateTimeZone object for the offset\n * @throws IllegalArgumentException if any value is out of range, the minutes are negative\n *  when the hours are positive, or the resulting offset exceeds +/- 23:59:59.000\n */\npublic static DateTimeZone forOffsetHoursMinutes(int hoursOffset, int minutesOffset) throws IllegalArgumentException {\n    if (hoursOffset == 0 && minutesOffset == 0) {\n        return DateTimeZone.UTC;\n    }\n    if (hoursOffset < -23 || hoursOffset > 23) {\n        throw new IllegalArgumentException(\"Hours out of range: \" + hoursOffset);\n    }\n    if (minutesOffset < -59 || minutesOffset > 59) {\n        throw new IllegalArgumentException(\"Minutes out of range: \" + minutesOffset);\n    }\n    if (hoursOffset > 0 && minutesOffset < 0) {\n        throw new IllegalArgumentException(\" \u043c\u0438\u043d\u0443\u0442\u044b \u0434\u043e\u043b\u0436\u043d\u044b \u0431\u044b\u0442\u044c \u043d\u0435\u043e\u0442\u0440\u0438\u0446\u0430\u0442\u0435\u043b\u044c\u043d\u044b, \u0435\u0441\u043b\u0438 \u0447\u0430\u0441\u044b \u043f\u043e\u043b\u043e\u0436\u0438\u0442\u0435\u043b\u044c\u043d\u044b\");\n    }\n    int offset = 0;\n    try {\n        offset = FieldUtils.safeMultiply(hoursOffset * 60 + minutesOffset, DateTimeConstants.MILLIS_PER_MINUTE);\n        if (offset < -23 * 60 * 60 * 1000 || offset > 23 * 60 * 60 * 1000 + 59 * 60 * 1000) {\n            throw new IllegalArgumentException(\"Offset is too large\");\n        }\n    } catch (ArithmeticException ex) {\n        throw new IllegalArgumentException(\"Offset is too large\");\n    }\n    return forOffsetMillis(offset);\n}",
    "exact_match": false,
    "ast_match": false,
    "compile": true,
    "test": false
}