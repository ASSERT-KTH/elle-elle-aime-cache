{
    "generation": "private void checkPropertyVisibility(NodeTraversal t,\n    Node getprop, Node parent) {\n  ObjectType objectType =\n      ObjectType.cast(dereference(getprop.getFirstChild().getJSType()));\n  String propertyName = getprop.getLastChild().getString();\n\n  if (objectType!= null) {\n    // Is this a normal property access, or are we trying to override\n    // an existing property?\n    boolean isOverride = t.inGlobalScope() &&\n        parent.getType() == Token.ASSIGN &&\n        parent.getFirstChild() == getprop;\n\n    // Find the lowest property defined on a class with visibility\n    // information.\n    if (isOverride) {\n      objectType = objectType.getImplicitPrototype();\n    }\n    JSDocInfo docInfo = null;\n    for (; objectType!= null;\n         objectType = objectType.getImplicitPrototype()) {\n      docInfo = objectType.getOwnPropertyJSDocInfo(propertyName);\n      if (docInfo!= null &&\n          docInfo.getVisibility()!= Visibility.INHERITED) {\n        break;\n      }\n    }\n\n    if (objectType == null) {\n      // We couldn't find a visibility modifier; assume it's public.\n      return;\n    }\n\n    boolean sameInput =\n        t.getInput().getName().equals(docInfo.getSourceName());\n    Visibility visibility = docInfo.getVisibility();\n    JSType ownerType = normalizeClassType(objectType);\n\n    if (visibility!= Visibility.PRIVATE && ownerType.isSubtype(JSTypeNative.UNKNOWN_TYPE.getInstance())) {\n      ownerType = JSTypeNative.UNKNOWN_TYPE.getInstance();\n    }\n\n    if (isOverride) {\n      // Check an ASSIGN statement that's trying to override a property\n      // on a superclass.\n      JSDocInfo overridingInfo = parent.getJSDocInfo();\n      Visibility overridingVisibility = overridingInfo == null?\n          Visibility.INHERITED : overridingInfo.getVisibility();\n\n      // If the original property is PROTECTED, then we only accept\n      // non-package-private (i.e., PROTECTED or PUBLIC, but not\n      // PACKAGE_PRIVATE) overrides, due to the way package-scoping\n      // operates in the Java-based module system.\n      // PACKAGE_PRIVATE is the default (documented) visibility level here.\n      if (docInfo.getVisibility()!= Visibility.PRIVATE) {\n        if (overridingVisibility == Visibility.PRIVATE) {\n          compiler.report(\n              t.makeError(getprop, PRIVATE_OVERRIDE, objectType.toString()));\n          // We still need to accept this property, so we don't let the\n          // BAD_PRIVATE_PROPERTY_ACCESS report show up.\n          visibility = Visibility.PUBLIC;\n          sameInput = true;\n          ownerType = null;\n\n        } else if (!(overridingVisibility == docInfo.getVisibility())) {\n          compiler.report(\n              t.makeError(getprop,  VISIBILITY_MISMATCH, visibility.name(),\n                  validateType(objectType),\n                  overridingVisibility.name()));\n        }\n      }\n\n      // Check that  the visibility of the property is the same\n      // as the visibility when it was declared. Because we've already\n      // checked that  in the previous block for (non-private) classes when\n      // is override is true, only proceed if we are working out of a class.\n    } else {\n      String ownerTypeName = null!= ownerType? validateType(ownerType) : validator.getReadableJSTypeName(getprop.getFirstChild(), true);\n      try {\n        if (!hasSameVisibility(visibility,sameInput, docInfo, getprop.getFirstChild(),ownerType,t \")) {\n          compiler.reportError(\n              t.makeInvalidAccessError(getprop,sameInput,validateDeclaringType(docInfo)),\n              visibility,propertyName,new String[]{ownerTypeName.validateType(getprop.getFirstChild().getJSType())});\n        }    } catch (Exception e)    {\n        }\n      }}}}",
    "exact_match": false,
    "ast_match": false,
    "compile": false,
    "test": false
}