{
    "generation": "private boolean isInlinableObject(List<Reference> refs) {\n  int assignmentCount = 0;\n  Node assignmentValue = null;\n  Set<String> properties = new HashSet<>();\n\n  for (Reference ref : refs) {\n    Node name = ref.getNode();\n    Node parent = ref.getParent();\n    Node gramps = ref.getGrandparent();\n\n    // Check for assignments\n    if (isVarOrAssignExprLhs(name)) {\n      assignmentCount++;\n      assignmentValue = ref.getAssignedValue();\n      if (assignmentValue != null && assignmentValue.isObjectLit()) {\n        // Collect properties from the object literal\n        for (Node child = assignmentValue.getFirstChild(); child != null; child = child.getNext()) {\n          if (child.isStringKey()) {\n            properties.add(child.getString());\n          }\n        }\n      }\n    }\n\n    // Ignore indirect references, like x.y (except x.y(), since the function referenced by y might reference 'this').\n    if (parent.isGetProp()) {\n      Preconditions.checkState(parent.getFirstChild() == name);\n      // A call target may be using the object as a 'this' value.\n      if (gramps.isCall() && gramps.getFirstChild() == parent) {\n        return false;\n      }\n\n      // Check if property is defined in the object literal\n      String propertyName = parent.getString();\n      if (!properties.contains(propertyName)) {\n        return false;\n      }\n    }\n  }\n\n  // Only proceed if there is exactly one assignment\n  if (assignmentCount != 1) {\n    return false;\n  }\n\n  // Additional checks for the assignment\n  if (assignmentValue == null || !assignmentValue.isObjectLit()) {\n    return false;\n  }\n\n  // Check for self-referential assignments\n  for (Reference ref : refs) {\n    Node val = ref.getAssignedValue();\n    if (val != null && val.isObjectLit()) {\n      for (Node child = val.getFirstChild(); child != null; child = child.getNext()) {\n        if (child.isGetterDef() || child.isSetterDef()) {\n          return false;\n        }\n        Node childVal = child.getFirstChild();\n        for (Reference t : refs) {\n          Node refNode = t.getParent();\n          while (!NodeUtil.isStatementBlock(refNode)) {\n            if (refNode == childVal) {\n              return false;\n            }\n            refNode = refNode.getParent();\n          }\n        }\n      }\n    }\n  }\n\n  return true;\n}",
    "exact_match": false,
    "ast_match": false,
    "compile": false,
    "test": false
}