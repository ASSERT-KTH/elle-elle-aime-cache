{
    "generation": "/**\n * Parses the externs and main inputs.\n *\n * @return A synthetic root node whose two children are the externs root\n *     and the main root\n */\nNode parseInputs() {\n    boolean devMode = options.devMode != DevMode.OFF;\n\n    // If old roots exist (we are parsing a second time), detach each of the\n    // individual file parse trees.\n    if (externsRoot != null) {\n        externsRoot.detachChildren();\n    }\n    if (jsRoot != null) {\n        jsRoot.detachChildren();\n    }\n\n    // Parse main js sources.\n    jsRoot = IR.block();\n    jsRoot.setIsSyntheticBlock(true);\n\n    externsRoot = IR.block();\n    externsRoot.setIsSyntheticBlock(true);\n\n    externAndJsRoot = IR.block(externsRoot, jsRoot);\n    externAndJsRoot.setIsSyntheticBlock(true);\n\n    if (options.tracer.isOn()) {\n        tracker = new PerformanceTracker(jsRoot, options.tracer);\n        addChangeHandler(tracker.getCodeChangeHandler());\n    }\n\n    Tracer tracer = newTracer(\"parseInputs\");\n\n    try {\n        // Parse externs sources.\n        for (CompilerInput input : externs) {\n            Node n = input.getAstRoot(this);\n            if (hasErrors()) {\n                return null;\n            }\n            externsRoot.addChildToBack(n);\n        }\n\n        // Modules inferred in ProcessCommonJS pass.\n        if (options.transformAMDToCJSModules || options.processCommonJSModules) {\n            processAMDAndCommonJSModules();\n        }\n\n        // Check if inputs need to be rebuilt from modules.\n        boolean staleInputs = false;\n\n        // Check if the sources need to be re-ordered.\n        if (options.dependencyOptions.needsManagement() &&\n            !options.skipAllPasses &&\n            options.closurePass) {\n            for (CompilerInput input : inputs) {\n                // Forward-declare all the provided types, so that they\n                // are not flagged even if they are dropped from the process.\n                for (String provide : input.getProvides()) {\n                    getTypeRegistry().forwardDeclareType(provide);\n                }\n            }\n\n            try {\n                inputs =\n                    (moduleGraph == null ? new JSModuleGraph(modules) : moduleGraph)\n                    .manageDependencies(options.dependencyOptions, inputs);\n                staleInputs = true;\n            } catch (CircularDependencyException e) {\n                report(JSError.make(\n                    JSModule.CIRCULAR_DEPENDENCY_ERROR, e.getMessage()));\n\n                // If in IDE mode, we ignore the error and keep going.\n                if (hasErrors()) {\n                    return null;\n                }\n            } catch (MissingProvideException e) {\n                report(JSError.make(\n                    MISSING_ENTRY_ERROR, e.getMessage()));\n\n                // If in IDE mode, we ignore the error and keep going.\n                if (hasErrors()) {\n                    return null;\n                }\n            }\n        }\n\n        // Ensure that inputs are rebuilt from modules if necessary.\n        if (staleInputs) {\n            fillEmptyModules(modules);\n            rebuildInputsFromModules();\n        }\n\n        // Process provided and required modules to ensure correct order.\n        List<CompilerInput> orderedInputs = ordersByProvidedAndRequired(inputs);\n\n        for (CompilerInput input : orderedInputs) {\n            Node n = input.getAstRoot(this);\n\n            // Inputs can have a null AST during initial parse.\n            if (n == null) {\n                continue;\n            }\n\n            if (n.getJSDocInfo() != null) {\n                JSDocInfo info = n.getJSDocInfo();\n                if (info.isExterns()) {\n                    // If the input file is explicitly marked as an externs file, then\n                    // assume the programmer made a mistake and throw it into\n                    // the externs pile anyways.\n                    externsRoot.addChildToBack(n);\n                    input.setIsExtern(true);\n\n                    input.getModule().remove(input);\n\n                    externs.add(input);\n                    staleInputs = true;\n                } else if (info.isNoCompile()) {\n                    input.getModule().remove(input);\n                    staleInputs = true;\n                }\n            }\n        }\n\n        if (staleInputs) {\n            fillEmptyModules(modules);\n            rebuildInputsFromModules();\n        }\n\n        // Build the AST.\n        for (CompilerInput input : orderedInputs) {\n            Node n = input.getAstRoot(this);\n            if (n == null) {\n                continue;\n            }\n\n            if (devMode) {\n                runSanityCheck();\n                if (hasErrors()) {\n                    return null;\n                }\n            }\n\n            if (options.sourceMapOutputPath != null ||\n                options.nameReferenceReportPath != null) {\n\n                // Annotate the nodes in the tree with information from the\n                // input file. This information is used to construct the SourceMap.\n                SourceInformationAnnotator sia =\n                    new SourceInformationAnnotator(\n                        input.getName(), options.devMode != DevMode.OFF);\n                NodeTraversal.traverse(this, n, sia);\n            }\n\n            jsRoot.addChildToBack(n);\n        }\n\n        if (hasErrors()) {\n            return null;\n        }\n        return externAndJsRoot;\n    } finally {\n        stopTracer(tracer, \"parseInputs\");\n    }\n}\n\n/**\n * Orders inputs by their provided and required modules.\n * @param inputs The list of compiler inputs.\n * @return A list of compiler inputs ordered by provided and required modules.\n */\nprivate List<CompilerInput> ordersByProvidedAndRequired(List<CompilerInput> inputs) {\n    // Create a map from provides to inputs\n    Map<String, CompilerInput> providesToInput = new HashMap<>();\n    for (CompilerInput input : inputs) {\n        for (String provide : input.getProvides()) {\n            providesToInput.put(provide, input);\n        }\n    }\n\n    // Create a list of inputs ordered by dependencies\n    List<CompilerInput> orderedInputs = new ArrayList<>();\n    Set<CompilerInput> addedInputs = new HashSet<>();\n\n    for (CompilerInput input : inputs) {\n        // Perform a depth-first search to add inputs based on their dependencies\n        addInputAndDependencies(input, orderedInputs, addedInputs, providesToInput);\n    }\n\n    return orderedInputs;\n}\n\n/**\n * Recursively adds an input and its dependencies to the ordered list.\n * @param input The input to add.\n * @param orderedInputs The list of ordered inputs.\n * @param addedInputs A set to track inputs that have already been added.\n * @param providesToInput A map from provides to inputs.\n */\nprivate void addInputAndDependencies(CompilerInput input, List<CompilerInput> orderedInputs,\n                                    Set<CompilerInput> addedInputs,\n                                    Map<String, CompilerInput> providesToInput) {\n    if (addedInputs.contains(input)) {\n        return;\n    }\n\n    for (String require : input.getRequires()) {\n        CompilerInput requiredInput = providesToInput.get(require);\n        if (requiredInput != null) {\n            addInputAndDependencies(requiredInput, orderedInputs, addedInputs, providesToInput);\n        }\n    }\n\n    orderedInputs.add(input);\n    addedInputs.add(input);\n}",
    "exact_match": false,
    "ast_match": false,
    "compile": false,
    "test": false
}