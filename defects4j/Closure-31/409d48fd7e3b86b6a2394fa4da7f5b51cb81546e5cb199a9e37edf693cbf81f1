{
    "generation": "/**\n * Parses the externs and main inputs.\n *\n * @return A synthetic root node whose two children are the externs root\n *     and the main root\n */\nNode parseInputs() {\n    boolean devMode = options.devMode!= DevMode.OFF;\n\n    // If old roots exist (we are parsing a second time), detach each of the\n    // individual file parse trees.\n    if (externsRoot!= null) {\n      externsRoot.detachChildren();\n    }\n    if (jsRoot!= null) {\n      jsRoot.detachChildren();\n    }\n\n    // Parse main js sources.\n    jsRoot = IR.block();\n    jsRoot.setIsSyntheticBlock(true);\n\n    externsRoot = IR.block();\n    externsRoot.setIsSyntheticBlock(true);\n\n    externAndJsRoot = IR.block(externsRoot, jsRoot);\n    externAndJsRoot.setIsSyntheticBlock(true);\n\n    if (options.tracer.isOn()) {\n      tracker = new PerformanceTracker(jsRoot, options.tracer);\n      addChangeHandler(tracker.getCodeChangeHandler());\n    }\n\n    Tracer tracer = newTracer(\"parseInputs\");\n\n    try {\n      // Parse externs sources.\n      for (CompilerInput input : externs) {\n        Node n = input.getAstRoot(this);\n        if (hasErrors()) {\n          return null;\n        }\n        externsRoot.addChildToBack(n);\n      }\n\n      // Modules inferred in ProcessCommonJS pass.\n      if (options.transformAMDToCJSModules || options.processCommonJSModules) {\n        processAMDAndCommonJSModules();\n      }\n\n      // Check if inputs need to be rebuilt from modules.\n      boolean staleInputs = false;\n\n      // Check if the sources need to be re-ordered.\n      if (options.dependencyOptions.needsManagement() &&\n         !options.skipAllPasses &&\n          options.closurePass) {\n        for (CompilerInput input : inputs) {\n          // Forward-declare all the provided types, so that they\n          // are not flagged even if they are dropped from the process.\n          for (String provide : input.getProvides()) {\n            getTypeRegistry().forwardDeclareType(provide);\n          }\n        }\n\n        try {\n          inputs =\n              (moduleGraph == null? new JSModuleGraph(modules) : moduleGraph)\n             .manageDependencies(options.dependencyOptions, inputs);\n          staleInputs = true;\n        } catch (CircularDependencyException e) {\n          report(JSError.make(\n              JSModule.CIRCULAR_DEPENDENCY_ERROR, e.getMessage()));\n\n          // If in IDE mode, we ignore the error and keep going.\n          if (hasErrors()) {\n            return null;\n          }\n        } catch (MissingProvideException e) {\n          report(JSError.make(\n              MISSING_ENTRY_ERROR, e.getMessage()));\n\n          // If in IDE mode, we ignore the error and keep going.\n          if (hasErrors()) {\n            return null;\n          }\n        }\n      }\n\n      for (CompilerInput input : inputs) {\n        Node n = input.getAstRoot(this);\n\n        // Inputs can have a null AST during initial parse.\n        if (n == null) {\n          continue;\n        }\n\n        if (n.getJSDocInfo()!= null) {\n          JSDocInfo info = n.getJSDocInfo();\n          if (info.isExterns()) {\n            // If the input file is explicitly marked as an externs file, then\n            // assume the programmer made a mistake and throw it into\n            // the externs pile anyways.\n            externsRoot.addChildToBack(n);\n            input.setIsExtern(true);\n\n            input.getModule().remove(input);\n\n            externs.add(input);\n            staleInputs = true;\n          } else if (info.isNoCompile()) {\n            input.getModule().remove(input);\n            staleInputs = true;\n          }\n        }\n      }\n\n      if (staleInputs) {\n        fillEmptyModules(modules);\n        rebuildInputsFromModules();\n      }\n\n      // Build the AST.\n      for (CompilerInput input : inputs) {\n        Node n = input.getAstRoot(this);\n        if (n == null) {\n          continue;\n        }\n\n        if (devMode) {\n          runSanityCheck();\n          if (hasErrors()) {\n            return null;\n          }\n        }\n\n        if (options.sourceMapOutputPath!= null ||\n            options.nameReferenceReportPath!= null) {\n\n          // Annotate the nodes in the tree with information from the\n          // input file. This information is used to construct the SourceMap.\n          SourceInformationAnnotator sia =\n              new SourceInformationAnnotator(\n                  input.getName(), options.devMode!= DevMode.OFF);\n          NodeTraversal.traverse(this, n, sia);\n        }\n\n        jsRoot.addChildToBack(n);\n      }\n\n      // Re-order the inputs to satisfy closure dependencies\n      if (options.dependencyOptions.needsManagement() &&\n         !options.skipAllPasses &&\n          options.closurePass) {\n        jsRoot = reorderByClosureDependencies(jsRoot);\n      }\n\n      if (hasErrors()) {\n        return null;\n      }\n      return externAndJsRoot;\n    } finally {\n      stopTracer(tracer, \"parseInputs\");\n    }\n}\n\n// New method to re-order the inputs to satisfy closure dependencies\nprivate Node reorderByClosureDependencies(Node jsRoot) {\n    ArrayList<Node> orderedChildren = new ArrayList<>();\n    for (CompilerInput input : inputs) {\n        Node n = input.getAstRoot(this);\n        if (n!= null) {\n            orderedChildren.add(n);\n        }\n    }\n\n    // Use a topological sorting algorithm to order the children\n    // based on their closure dependencies\n    orderedChildren = topologicalSort(orderedChildren);\n\n    Node newJsRoot = IR.block();\n    newJsRoot.setIsSyntheticBlock(true);\n\n    for (Node child : orderedChildren) {\n        newJsRoot.addChildToBack(child);\n    }\n\n    return newJsRoot;\n}\n\n// Topological sorting algorithm\nprivate ArrayList<Node> topologicalSort(ArrayList<Node> nodes) {\n    // Create a graph where each node is a CompilerInput and each edge\n    // represents a closure dependency\n    Graph<Node> graph = new Graph<>();\n\n    for (Node node : nodes) {\n        graph.addNode(node);\n    }\n\n    for (CompilerInput input : inputs) {\n        Node n = input.getAstRoot(this);\n        if (n!= null) {\n            for (String provide : input.getProvides()) {\n                for (CompilerInput otherInput : inputs) {\n                    if (otherInput.getRequires().contains(provide)) {\n                        graph.addEdge(n, otherInput.getAstRoot(this));\n                    }\n                }\n            }\n        }\n    }\n\n    // Perform a topological sort on the graph\n    ArrayList<Node> sortedNodes = new ArrayList<>();\n    boolean[] visited = new boolean[nodes.size()];\n\n    for (Node node : nodes) {\n        if (!visited[nodes.indexOf(node)]) {\n            visit(node, visited, sortedNodes, graph);\n        }\n    }\n\n    return sortedNodes;\n}\n\n// Recursive function to visit each node in the graph\nprivate void visit(Node node, boolean[] visited, ArrayList<Node> sortedNodes, Graph<Node> graph) {\n    visited[inputs.indexOf(node)] = true;\n\n    for (Node child : graph.getChildren(node)) {\n        if (!visited[inputs.indexOf(child)]) {\n            visit(child, visited, sortedNodes, graph);\n        }\n    }\n\n    sortedNodes.add(node);\n}\n\n// Simple graph class\nclass Graph<T> {\n    private Map<T, List<T>> edges;\n\n    public Graph() {\n        edges = new HashMap<>();\n    }\n\n    public void addNode(T node) {\n        edges.put(node, new ArrayList<>());\n    }\n\n    public void addEdge(T from, T to) {\n        edges.get(from).add(to);\n    }\n\n    public List<T> getChildren(T node) {\n        return edges.get(node);\n    }\n}",
    "exact_match": false,
    "ast_match": false,
    "compile": false,
    "test": false
}