{
    "generation": "/**\n * Parses the externs and main inputs.\n *\n * @return A synthetic root node whose two children are the externs root\n *     and the main root\n */\nNode parseInputs() {\n  boolean devMode = options.devMode != DevMode.OFF;\n\n  // If old roots exist (we are parsing a second time), detach each of the\n  // individual file parse trees.\n  if (externsRoot != null) {\n    externsRoot.detachChildren();\n  }\n  if (jsRoot != null) {\n    jsRoot.detachChildren();\n  }\n\n  // Parse main js sources.\n  jsRoot = IR.block();\n  jsRoot.setIsSyntheticBlock(true);\n\n  externsRoot = IR.block();\n  externsRoot.setIsSyntheticBlock(true);\n\n  externAndJsRoot = IR.block(externsRoot, jsRoot);\n  externAndJsRoot.setIsSyntheticBlock(true);\n\n  if (options.tracer.isOn()) {\n    tracker = new PerformanceTracker(jsRoot, options.tracer);\n    addChangeHandler(tracker.getCodeChangeHandler());\n  }\n\n  Tracer tracer = newTracer(\"parseInputs\");\n\n  try {\n    // Parse externs sources.\n    for (CompilerInput input : externs) {\n      Node n = input.getAstRoot(this);\n      if (hasErrors()) {\n        return null;\n      }\n      externsRoot.addChildToBack(n);\n    }\n\n    if (options.transformAMDToCJSModules || options.processCommonJSModules) {\n      processAMDAndCommonJSModules();\n    }\n\n    boolean staleInputs = false;\n\n    if (options.dependencyOptions.needsManagement() && !options.skipAllPasses && options.closurePass) {\n      for (CompilerInput input : inputs) {\n        for (String provide : input.getProvides()) {\n          getTypeRegistry().forwardDeclareType(provide);\n        }\n      }\n\n      inputs = manageDependencies();\n      staleInputs = true;\n    }\n\n    for (CompilerInput input : inputs) {\n      Node n = input.getAstRoot(this);\n\n      if (n == null || n.getJSDocInfo() == null) {\n        continue;\n      }\n\n      if (n.getJSDocInfo().isExterns()) {\n        externsRoot.addChildToBack(n);\n        input.setIsExtern(true);\n        input.getModule().remove(input);\n        externs.add(input);\n        staleInputs = true;\n      } else if (n.getJSDocInfo().isNoCompile()) {\n        input.getModule().remove(input);\n        staleInputs = true;\n      } else {\n        jsRoot.addChildToBack(n);\n\n        if (devMode) {\n          runSanityCheck();\n          if (hasErrors()) {\n            return null;\n          }\n        }\n\n        if (options.sourceMapOutputPath != null || options.nameReferenceReportPath != null) {\n          SourceInformationAnnotator sia = new SourceInformationAnnotator(input.getName(), options.devMode != DevMode.OFF);\n          NodeTraversal.traverse(this, n, sia);\n        }\n      }\n    }\n\n    if (staleInputs) {\n      fillEmptyModules(modules);\n      rebuildInputsFromModules();\n    }\n\n    if (hasErrors()) {\n      return null;\n    }\n    return externAndJsRoot;\n  } finally {\n    stopTracer(tracer, \"parseInputs\");\n  }\n}\n\nprivate CompilerOptions.DependencyOptionsManagedOption manageDependencies() {\n  try {\n    JSModuleGraph moduleGraph = this.moduleGraph == null ? new JSModuleGraph(modules) : this.moduleGraph;\n    return moduleGraph.manageDependencies(options.dependencyOptions, inputs);\n  } catch (CircularDependencyException e) {\n    report(JSError.make(JSModule.CIRCULAR_DEPENDENCY_ERROR, e.getMessage()));\n  } catch (MissingProvideException e) {\n    report(JSError.make(MISSING_ENTRY_ERROR, e.getMessage()));\n  }\n\n  if (hasErrors()) {\n    throw new RuntimeException(\"There were errors while managing dependencies.\");\n  }\n\n  return null;\n}",
    "exact_match": false,
    "ast_match": false,
    "compile": false,
    "test": false
}