{
    "generation": "Node parseInputs() {\n    boolean devMode = options.devMode != DevMode.OFF;\n\n    // If old roots exist (we are parsing a second time), detach each of the\n    // individual file parse trees.\n    if (externsRoot != null) {\n        externsRoot.detachChildren();\n    }\n    if (jsRoot != null) {\n        jsRoot.detachChildren();\n    }\n\n    // Parse main js sources.\n    jsRoot = IR.block();\n    jsRoot.setIsSyntheticBlock(true);\n\n    externsRoot = IR.block();\n    externsRoot.setIsSyntheticBlock(true);\n\n    externAndJsRoot = IR.block(externsRoot, jsRoot);\n    externAndJsRoot.setIsSyntheticBlock(true);\n\n    if (options.tracer.isOn()) {\n        tracker = new PerformanceTracker(jsRoot, options.tracer);\n        addChangeHandler(tracker.getCodeChangeHandler());\n    }\n\n    Tracer tracer = newTracer(\"parseInputs\");\n\n    try {\n        // Parse externs sources.\n        for (CompilerInput input : externs) {\n            Node n = input.getAstRoot(this);\n            if (hasErrors()) {\n                return null;\n            }\n            externsRoot.addChildToBack(n);\n        }\n\n        // Modules inferred in ProcessCommonJS pass.\n        if (options.transformAMDToCJSModules || options.processCommonJSModules) {\n            processAMDAndCommonJSModules();\n        }\n\n        // Check if inputs need to be rebuilt from modules.\n        boolean staleInputs = false;\n\n        // Check if the sources need to be re-ordered.\n        if (options.dependencyOptions.needsManagement() &&\n            !options.skipAllPasses &&\n            options.closurePass) {\n            for (CompilerInput input : inputs) {\n                // Forward-declare all the provided types, so that they\n                // are not flagged even if they are dropped from the process.\n                for (String provide : input.getProvides()) {\n                    getTypeRegistry().forwardDeclareType(provide);\n                }\n            }\n\n            try {\n                inputs = (moduleGraph == null ? new JSModuleGraph(modules) : moduleGraph)\n                        .manageDependencies(options.dependencyOptions, inputs);\n                staleInputs = true;\n            } catch (CircularDependencyException e) {\n                report(JSError.make(JSModule.CIRCULAR_DEPENDENCY_ERROR, e.getMessage()));\n                if (hasErrors()) {\n                    return null;\n                }\n            } catch (MissingProvideException e) {\n                report(JSError.make(MISSING_ENTRY_ERROR, e.getMessage()));\n                if (hasErrors()) {\n                    return null;\n                }\n            }\n        }\n\n        // Handle inputs and their metadata.\n        for (CompilerInput input : inputs) {\n            Node n = input.getAstRoot(this);\n\n            // Inputs can have a null AST during initial parse.\n            if (n == null) {\n                continue;\n            }\n\n            if (n.getJSDocInfo() != null) {\n                JSDocInfo info = n.getJSDocInfo();\n                if (info.isExterns()) {\n                    // Add explicitly marked externs to the externs root.\n                    externsRoot.addChildToBack(n);\n                    input.setIsExtern(true);\n\n                    input.getModule().remove(input);\n\n                    externs.add(input);\n                    staleInputs = true;\n                } else if (info.isNoCompile()) {\n                    input.getModule().remove(input);\n                    staleInputs = true;\n                }\n            }\n        }\n\n        if (staleInputs) {\n            fillEmptyModules(modules);\n            rebuildInputsFromModules();\n        }\n\n        // Build the AST.\n        for (CompilerInput input : inputs) {\n            Node n = input.getAstRoot(this);\n            if (n == null) {\n                continue;\n            }\n\n            if (devMode) {\n                runSanityCheck();\n                if (hasErrors()) {\n                    return null;\n                }\n            }\n\n            if (options.sourceMapOutputPath != null ||\n                options.nameReferenceReportPath != null) {\n                // Annotate the nodes in the tree with information from the input file.\n                SourceInformationAnnotator sia = new SourceInformationAnnotator(\n                    input.getName(), options.devMode != DevMode.OFF);\n                NodeTraversal.traverse(this, n, sia);\n            }\n\n            jsRoot.addChildToBack(n);\n        }\n\n        // Reorder the AST nodes based on dependencies, if needed.\n        if (options.dependencyOptions.needsManagement() && options.dependencyOptions.shouldSortDependencies()) {\n            try {\n                List<Node> nodes = new ArrayList<>();\n                for (Node child : jsRoot.children()) {\n                    nodes.add(child);\n                }\n                jsRoot.detachChildren(); // Clear current children\n                DependencySorter sorter = new DependencySorter(nodes);\n                List<Node> sortedNodes = sorter.sort();\n                for (Node sortedNode : sortedNodes) {\n                    jsRoot.addChildToBack(sortedNode);\n                }\n            } catch (DependencySorter.SortingException e) {\n                report(JSError.make(DEPENDENCY_SORT_ERROR, e.getMessage()));\n                if (hasErrors()) {\n                    return null;\n                }\n            }\n        }\n\n        if (hasErrors()) {\n            return null;\n        }\n        return externAndJsRoot;\n    } finally {\n        stopTracer(tracer, \"parseInputs\");\n    }\n}",
    "exact_match": false,
    "ast_match": false,
    "compile": false,
    "test": false
}