{
    "generation": "/**\n * Visits a CALL node.\n *\n * @param t The node traversal object that supplies context, such as the\n * scope chain to use in name lookups as well as error reporting.\n * @param n The node being visited.\n */\nprivate void visitCall(NodeTraversal t, Node n) {\n    Node child = n.getFirstChild();\n    JSType childType = getJSType(child).restrictByNotNullOrUndefined();\n\n    if (!childType.canBeCalled()) {\n      report(t, n, NOT_CALLABLE, childType.toString());\n      ensureTyped(t, n);\n      return;\n    }\n\n    if (childType instanceof FunctionType) {\n      FunctionType functionType = (FunctionType) childType;\n      ...\n      // If the function type has a 'this' type, ensure that the function is called\n      // with a 'this' type that matches the specified 'this' type for the function.\n      if (functionType.hasThisType()) {\n        Node thisNode = child.getParent();\n        if (thisNode != null && thisNode.isGetprop()) {\n          JSType thisType = getJSType(thisNode.getFirstChild());\n          if (!thisType.isSubtype(functionType.getThisType())) {\n            report(t, n, THIS_TYPE_MISMATCH,\n                functionType.getThisType().toString(), thisType.toString());\n            ensureTyped(t, n);\n            return;\n          }\n        } else {\n          report(t, n, MISSING_THIS_TYPE, functionType.getThisType().toString());\n          ensureTyped(t, n);\n          return;\n        }\n      }\n      ...\n    } else {\n      ensureTyped(t, n);\n    }\n    ...\n}",
    "exact_match": false,
    "ast_match": false,
    "compile": false,
    "test": false
}