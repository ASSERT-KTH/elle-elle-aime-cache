{
    "generation": "/**\n * {@inheritDoc}\n */\n@Override\nprotected double doSolve() {\n\n    //... (unchanged code up to the search loop)\n\n    // search loop\n    int evaluations = 0; // <--- **Added evaluation counter**\n    while (true) {\n\n        //... (unchanged code up to the convergence check)\n\n        // check convergence of bracketing interval\n        final double xTol = getAbsoluteAccuracy() +\n                            getRelativeAccuracy() * FastMath.max(FastMath.abs(xA), FastMath.abs(xB));\n        if (((xB - xA) <= xTol) || (FastMath.max(absYA, absYB) < getFunctionValueAccuracy())) {\n            switch (allowed) {\n            case ANY_SIDE :\n                return absYA < absYB? xA : xB;\n            case LEFT_SIDE :\n                return xA;\n            case RIGHT_SIDE :\n                return xB;\n            case BELOW_SIDE :\n                return (yA <= 0)? xA : xB;\n            case ABOVE_SIDE :\n                return (yA <  0)? xB : xA;\n            default :\n                // this should never happen\n                throw new MathInternalError(null);\n            }\n        }\n\n        //... (unchanged code up to the function evaluation)\n\n        // evaluate the function at the guessed root\n        final double nextY = computeObjectiveValue(nextX);\n        evaluations++; // <--- **Increment evaluation counter**\n        if (evaluations > getMaxEvaluations()) { // <--- **Check maximum evaluations**\n            throw new TooManyEvaluationsException(getMaxEvaluations());\n        }\n        if (Precision.equals(nextY, 0.0, 1)) {\n            // we have found an exact root, since it is not an approximation\n            // we don't need to bother about the allowed solutions setting\n            return nextX;\n        }\n\n        //... (unchanged code for the rest of the function)",
    "exact_match": false,
    "ast_match": false,
    "compile": false,
    "test": false
}