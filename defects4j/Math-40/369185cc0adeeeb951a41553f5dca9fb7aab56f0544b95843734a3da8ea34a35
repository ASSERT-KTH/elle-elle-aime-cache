{
    "generation": "@Override\nprotected double doSolve() {\n    //...\n\n    // limit the number of times bisection is used\n    int bisectionCount = 0;\n    int maxBisectionCount = 3;\n\n    // search loop\n    while (true) {\n        //...\n\n        // target for the next evaluation point\n        double targetY;\n        if (agingA >= MAXIMAL_AGING) {\n            //...\n        } else if (agingB >= MAXIMAL_AGING) {\n            //...\n        } else {\n            // bracketing is balanced, try to find the root itself\n            targetY = 0;\n        }\n\n        // make a few attempts to guess a root\n        double nextX;\n        int start = 0;\n        int end = nbPoints;\n        do {\n            //...\n        } while (Double.isNaN(nextX) && (end - start > 1));\n\n        if (Double.isNaN(nextX)) {\n            // fall back to bisection, but limit its usage\n            if (bisectionCount < maxBisectionCount) {\n                nextX = xA + 0.5 * (xB - xA);\n                bisectionCount++;\n            } else {\n                // Switch to inverse polynomial interpolation if bisection has been used too many times\n                System.arraycopy(x, start, tmpX, start, end - start);\n                nextX = guessX(0, tmpX, y, start, end);\n                bisectionCount = 0; // reset bisection count when switching to IP interpolation\n            }\n\n            start = signChangeIndex - 1;\n            end = signChangeIndex;\n        }\n\n        //...\n    }\n}",
    "exact_match": false,
    "ast_match": false,
    "compile": false,
    "test": false
}