{
    "generation": "@Override\nprotected double doSolve() {\n\n    // prepare arrays with the first points\n    final double[] x = new double[maximalOrder + 1];\n    final double[] y = new double[maximalOrder + 1];\n    x[0] = getMin();\n    x[1] = getStartValue();\n    x[2] = getMax();\n    verifySequence(x[0], x[1], x[2]);\n\n    // evaluate initial guess\n    y[1] = computeObjectiveValue(x[1]);\n    if (Precision.equals(y[1], 0.0, 1)) {\n        // return the initial guess if it is a perfect root.\n        return x[1];\n    }\n\n    // evaluate first endpoint\n    y[0] = computeObjectiveValue(x[0]);\n    if (Precision.equals(y[0], 0.0, 1)) {\n        // return the first endpoint if it is a perfect root.\n        return x[0];\n    }\n\n    int nbPoints;\n    int signChangeIndex;\n    if (y[0] * y[1] < 0) {\n        // reduce interval if it brackets the root\n        nbPoints = 2;\n        signChangeIndex = 1;\n    } else {\n        // evaluate second endpoint\n        y[2] = computeObjectiveValue(x[2]);\n        if (Precision.equals(y[2], 0.0, 1)) {\n            // return the second endpoint if it is a perfect root.\n            return x[2];\n        }\n\n        if (y[1] * y[2] < 0) {\n            // use all computed point as a start sampling array for solving\n            nbPoints = 3;\n            signChangeIndex = 2;\n        } else {\n            throw new NoBracketingException(x[0], x[2], y[0], y[2]);\n        }\n    }\n\n    // prepare a work array for inverse polynomial interpolation\n    final double[] tmpX = new double[x.length];\n\n    // current tightest bracketing of the root\n    double xA = x[signChangeIndex - 1];\n    double yA = y[signChangeIndex - 1];\n    double absYA = FastMath.abs(yA);\n    int agingA = 0;\n    double xB = x[signChangeIndex];\n    double yB = y[signChangeIndex];\n    double absYB = FastMath.abs(yB);\n    int agingB = 0;\n\n    // search loop\n    int evaluationCount = 0; // Add a counter for function evaluations\n    while (evaluationCount < getMaxEvaluations()) { // Limit the number of evaluations\n        evaluationCount++; // Increment the counter for each function evaluation\n\n        // check convergence of bracketing interval\n        final double xTol = getAbsoluteAccuracy() + getRelativeAccuracy() * FastMath.max(FastMath.abs(xA), FastMath.abs(xB));\n        if (((xB - xA) <= xTol) || (FastMath.max(absYA, absYB) < getFunctionValueAccuracy())) {\n            switch (allowed) {\n            case ANY_SIDE:\n                return absYA < absYB ? xA : xB;\n            case LEFT_SIDE:\n                return xA;\n            case RIGHT_SIDE:\n                return xB;\n            case BELOW_SIDE:\n                return (yA <= 0) ? xA : xB;\n            case ABOVE_SIDE:\n                return (yA < 0) ? xB : xA;\n            default:\n                // this should never happen\n                throw new MathInternalError(null);\n            }\n        }\n\n        // Rest of the function remains the same\n    }\n\n    // If the maximum number of evaluations is reached, throw an exception\n    throw new TooManyEvaluationsException(getMaxEvaluations());\n}",
    "exact_match": false,
    "ast_match": false,
    "compile": false,
    "test": false
}