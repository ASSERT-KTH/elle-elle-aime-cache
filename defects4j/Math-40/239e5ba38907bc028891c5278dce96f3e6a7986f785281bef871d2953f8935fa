{
    "generation": "@Override\nprotected double doSolve() {\n    final int maxEval = getMaxEvaluations();\n    final double initial = getStartValue();\n    final double min = getMin();\n    final double max = getMax();\n\n    verifySequence(min, initial, max);\n\n    // Return the initial guess if it is a root.\n    double yInitial = computeObjectiveValue(initial);\n    if (Precision.equals(yInitial, 0.0, 1)) {\n        return initial;\n    }\n\n    // Return the first endpoint if it is a root.\n    double yMin = computeObjectiveValue(min);\n    if (Precision.equals(yMin, 0.0, 1)) {\n        return min;\n    }\n\n    // Return the second endpoint if it is a root.\n    double yMax = computeObjectiveValue(max);\n    if (Precision.equals(yMax, 0.0, 1)) {\n        return max;\n    }\n\n    double xA = min;\n    double yA = yMin;\n    double xB = max;\n    double yB = yMax;\n\n    if (yA * yInitial < 0) {\n        xB = initial;\n        yB = yInitial;\n    } else if (yInitial * yB < 0) {\n        xA = initial;\n        yA = yInitial;\n    } else {\n        throw new NoBracketingException(min, max, yMin, yMax);\n    }\n\n    final double absoluteAccuracy = getAbsoluteAccuracy();\n    final double relativeAccuracy = getRelativeAccuracy();\n    final double functionValueAccuracy = getFunctionValueAccuracy();\n\n    while (getEvaluations() < maxEval) {\n        double xMid = 0.5 * (xA + xB);\n        double yMid = computeObjectiveValue(xMid);\n\n        if (Precision.equals(yMid, 0.0, functionValueAccuracy)) {\n            return xMid;\n        }\n\n        if (yA * yMid < 0) {\n            xB = xMid;\n            yB = yMid;\n        } else {\n            xA = xMid;\n            yA = yMid;\n        }\n\n        double xTol = absoluteAccuracy + relativeAccuracy * Math.max(Math.abs(xA), Math.abs(xB));\n        if (Math.abs(xB - xA) <= xTol) {\n            switch (allowed) {\n                case ANY_SIDE:\n                    return Math.abs(yA) < Math.abs(yB) ? xA : xB;\n                case LEFT_SIDE:\n                    return xA;\n                case RIGHT_SIDE:\n                    return xB;\n                case BELOW_SIDE:\n                    return yA <= 0 ? xA : xB;\n                case ABOVE_SIDE:\n                    return yA < 0 ? xB : xA;\n                default:\n                    throw new MathInternalError();\n            }\n        }\n    }\n\n    throw new TooManyEvaluationsException(maxEval);\n}",
    "exact_match": false,
    "ast_match": false,
    "compile": false,
    "test": false
}