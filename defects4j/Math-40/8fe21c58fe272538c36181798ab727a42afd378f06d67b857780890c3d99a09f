{
    "generation": "/**\n * {@inheritDoc}\n */\n@Override\nprotected double doSolve() {\n\n    //... (unchanged code up to the search loop)\n\n    // search loop\n    int evaluationCount = 0; // NEW: track evaluation count\n    while (true) {\n\n        //... (unchanged code up to the convergence check)\n\n        // check convergence of bracketing interval\n        final double xTol = getAbsoluteAccuracy() +\n                            getRelativeAccuracy() * FastMath.max(FastMath.abs(xA), FastMath.abs(xB));\n        if (((xB - xA) <= xTol) || (FastMath.max(absYA, absYB) < getFunctionValueAccuracy())) {\n            //... (unchanged code for solution selection)\n\n        }\n\n        //... (unchanged code up to the function evaluation)\n\n        // evaluate the function at the guessed root\n        final double nextY = computeObjectiveValue(nextX);\n        evaluationCount++; // NEW: increment evaluation count\n        if (evaluationCount > getMaxEvaluations()) { // NEW: check for too many evaluations\n            throw new TooManyEvaluationsException(getMaxEvaluations());\n        }\n        if (Precision.equals(nextY, 0.0, 1)) {\n            //... (unchanged code for exact root found)\n\n        }\n\n        //... (unchanged code for interval update and aging)\n\n        // update the bracketing interval\n        if (nextY * yA <= 0) {\n            //... (unchanged code)\n\n        } else {\n            //... (unchanged code)\n\n        }\n\n    }\n\n}",
    "exact_match": false,
    "ast_match": false,
    "compile": false,
    "test": false
}