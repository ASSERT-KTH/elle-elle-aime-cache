{
    "generation": "@Override\nprotected double doSolve() {\n    final int maxEval = getMaxEvaluations();\n    final double absoluteAccuracy = getAbsoluteAccuracy();\n    final double relativeAccuracy = getRelativeAccuracy();\n    final double functionValueAccuracy = getFunctionValueAccuracy();\n\n    verifySequence(getMin(), getStartValue(), getMax());\n\n    // prepare arrays with the first points\n    final double[] x = new double[maximalOrder + 1];\n    final double[] y = new double[maximalOrder + 1];\n    x[0] = getMin();\n    x[1] = getStartValue();\n    x[2] = getMax();\n\n    // evaluate initial guess\n    y[1] = computeObjectiveValue(x[1]);\n    if (Precision.equals(y[1], 0.0, absoluteAccuracy)) {\n        return x[1];\n    }\n\n    // evaluate first endpoint\n    y[0] = computeObjectiveValue(x[0]);\n    if (Precision.equals(y[0], 0.0, absoluteAccuracy)) {\n        return x[0];\n    }\n\n    // evaluate second endpoint\n    y[2] = computeObjectiveValue(x[2]);\n    if (Precision.equals(y[2], 0.0, absoluteAccuracy)) {\n        return x[2];\n    }\n\n    // prepare a work array for inverse polynomial interpolation\n    final double[] tmpX = new double[x.length];\n\n    int nbPoints = 3;\n    int signChangeIndex;\n    if (y[0] * y[1] < 0) {\n        signChangeIndex = 1;\n    } else if (y[1] * y[2] < 0) {\n        signChangeIndex = 2;\n    } else {\n        throw new NoBracketingException(x[0], x[2], y[0], y[2]);\n    }\n\n    // current tightest bracketing of the root\n    double xA = x[signChangeIndex - 1];\n    double yA = y[signChangeIndex - 1];\n    double xB = x[signChangeIndex];\n    double yB = y[signChangeIndex];\n    \n    int iterations = 0;\n    while (true) {\n        ++iterations;\n        \n        // check convergence\n        final double xTol = absoluteAccuracy + relativeAccuracy * FastMath.max(FastMath.abs(xA), FastMath.abs(xB));\n        if (FastMath.abs(xB - xA) <= xTol || FastMath.abs(yB) <= functionValueAccuracy) {\n            switch (allowed) {\n                case ANY_SIDE:\n                    return FastMath.abs(yA) < FastMath.abs(yB) ? xA : xB;\n                case LEFT_SIDE:\n                    return xA;\n                case RIGHT_SIDE:\n                    return xB;\n                case BELOW_SIDE:\n                    return yA <= 0 ? xA : xB;\n                case ABOVE_SIDE:\n                    return yA < 0 ? xB : xA;\n                default:\n                    throw new MathInternalError();\n            }\n        }\n\n        if (iterations > maxEval) {\n            throw new TooManyEvaluationsException(maxEval);\n        }\n\n        // calculate next point\n        final double nextX = UnivariateSolverUtils.midpoint(xA, xB);\n        final double nextY = computeObjectiveValue(nextX);\n        \n        // update bracketing interval\n        if (nextY * yA < 0) {\n            xB = nextX;\n            yB = nextY;\n        } else {\n            xA = nextX;\n            yA = nextY;\n        }\n    }\n}",
    "exact_match": false,
    "ast_match": false,
    "compile": false,
    "test": false
}