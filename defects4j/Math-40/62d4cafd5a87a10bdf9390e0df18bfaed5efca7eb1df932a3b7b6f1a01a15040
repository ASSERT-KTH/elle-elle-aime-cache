{
    "generation": "@Override\nprotected double doSolve() {\n    final int maxEval = getMaxEvaluations();\n    final double relativeAccuracy = getRelativeAccuracy();\n    final double absoluteAccuracy = getAbsoluteAccuracy();\n    final double functionValueAccuracy = getFunctionValueAccuracy();\n\n    verifySequence(getMin(), getStartValue(), getMax());\n\n    // prepare arrays with the first points\n    final double[] x = new double[maximalOrder + 1];\n    final double[] y = new double[maximalOrder + 1];\n    x[0] = getMin();\n    x[1] = getStartValue();\n    x[2] = getMax();\n\n    // evaluate initial guess\n    y[1] = computeObjectiveValue(x[1]);\n    if (Precision.equals(y[1], 0.0, functionValueAccuracy)) {\n        return x[1];\n    }\n\n    // evaluate first endpoint\n    y[0] = computeObjectiveValue(x[0]);\n    if (Precision.equals(y[0], 0.0, functionValueAccuracy)) {\n        return x[0];\n    }\n\n    // evaluate second endpoint\n    y[2] = computeObjectiveValue(x[2]);\n    if (Precision.equals(y[2], 0.0, functionValueAccuracy)) {\n        return x[2];\n    }\n\n    // prepare a work array for inverse polynomial interpolation\n    final double[] tmpX = new double[x.length];\n\n    int nbPoints = 3;\n    int signChangeIndex;\n    if (y[0] * y[1] < 0) {\n        signChangeIndex = 1;\n    } else if (y[1] * y[2] < 0) {\n        signChangeIndex = 2;\n    } else {\n        throw new NoBracketingException(x[0], x[2], y[0], y[2]);\n    }\n\n    // current tightest bracketing of the root\n    double xA = x[signChangeIndex - 1];\n    double yA = y[signChangeIndex - 1];\n    double xB = x[signChangeIndex];\n    double yB = y[signChangeIndex];\n    \n    int evaluations = 3;\n\n    while (evaluations < maxEval) {\n        double xTol = absoluteAccuracy + relativeAccuracy * FastMath.max(FastMath.abs(xA), FastMath.abs(xB));\n        if ((xB - xA) <= xTol || FastMath.abs(yA) <= functionValueAccuracy || FastMath.abs(yB) <= functionValueAccuracy) {\n            switch (allowed) {\n                case ANY_SIDE:\n                    return FastMath.abs(yA) < FastMath.abs(yB) ? xA : xB;\n                case LEFT_SIDE:\n                    return xA;\n                case RIGHT_SIDE:\n                    return xB;\n                case BELOW_SIDE:\n                    return (yA <= 0) ? xA : xB;\n                case ABOVE_SIDE:\n                    return (yA < 0) ? xB : xA;\n                default:\n                    throw new MathInternalError();\n            }\n        }\n\n        // calculate the next evaluation point using Brent's method\n        double delta = (xB - xA) / 2;\n        double nextX;\n        if (FastMath.abs(yA) < FastMath.abs(yB)) {\n            nextX = xA + delta;\n        } else {\n            nextX = xB - delta;\n        }\n\n        // evaluate function at the new point\n        double nextY = computeObjectiveValue(nextX);\n        evaluations++;\n\n        if (nextY * yA < 0) {\n            // sign change between xA and nextX\n            xB = nextX;\n            yB = nextY;\n        } else {\n            // sign change between nextX and xB\n            xA = nextX;\n            yA = nextY;\n        }\n    }\n\n    throw new TooManyEvaluationsException(maxEval);\n}",
    "exact_match": false,
    "ast_match": false,
    "compile": false,
    "test": false
}