{
    "generation": "@Override\nprotected double doSolve() {\n    // ...\n\n    // search loop\n    while (true) {\n        // ...\n\n        // make a few attempts to guess a root,\n        double nextX;\n        int start = 0;\n        int end   = nbPoints;\n        do {\n            // guess a value for current target, using inverse polynomial interpolation\n            System.arraycopy(x, start, tmpX, start, end - start);\n            nextX = guessX(targetY, tmpX, y, start, end);\n\n            if (!((nextX > xA) && (nextX < xB))) {\n                // the guessed root is not strictly inside of the tightest bracketing interval\n\n                // the guessed root is either not strictly inside the interval or it\n                // is a NaN (which occurs when some sampling points share the same y)\n                // we try again with a lower interpolation order\n                if (signChangeIndex - start >= end - signChangeIndex) {\n                    // we have more points before the sign change, drop the lowest point\n                    ++start;\n                } else {\n                    // we have more points after sign change, drop the highest point\n                    --end;\n                }\n\n                // we need to do one more attempt\n                nextX = Double.NaN;\n            }\n        } while (Double.isNaN(nextX) && (end - start > 1));\n\n        // ...\n\n        if ((nbPoints > 2) && (end - start > 1)) {\n            // we have been forced to ignore some points to keep bracketing,\n            // they are probably too far from the root, drop them from now on\n            nbPoints = end - start;\n            System.arraycopy(x, start, x, 0, nbPoints);\n            System.arraycopy(y, start, y, 0, nbPoints);\n            signChangeIndex -= start;\n        }\n\n        // ...\n    }\n}",
    "exact_match": false,
    "ast_match": false,
    "compile": false,
    "test": false
}