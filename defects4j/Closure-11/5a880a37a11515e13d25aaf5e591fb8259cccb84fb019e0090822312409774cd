{
    "generation": "private void visitGetProp(NodeTraversal t, Node n, Node parent) {\n    Node property = n.getLastChild();\n    Node objNode = n.getFirstChild();\n    JSType childType = getJSType(objNode);\n\n    if (childType.isDict()) {\n        report(t, property, TypeValidator.ILLEGAL_PROPERTY_ACCESS, \"'.'\", \"dict\");\n    } else if (readsSameValueButNotSameType(childType)) {\n        // The same value might be read from a variable of different types.\n        // As a workaround, don't check property access here.\n        // Issue: https://github.com/google/closure-compiler/issues/2008\n        return;\n    } else if (n.getJSType() != null && parent.isAssign()) {\n        // If the node already has a type and its parent is an assignment,\n        // no need for further type checking.\n        return;\n    } else if (validator.expectNotNullOrUndefined(t, n, childType,\n        \"No properties on this expression\", getNativeType(OBJECT_TYPE))) {\n        checkPropertyAccess(childType, property.getString(), t, n);\n    }\n    ensureTyped(t, n);\n}\n\nprivate boolean readsSameValueButNotSameType(JSType childType) {\n    // This is a workaround for a known issue where the same value might be\n    // read from a variable of different types.\n    // Issue: https://github.com/google/closure-compiler/issues/2008\n    if (!childType.isUnionType()) {\n        return false;\n    }\n    UnionType unionType = childType.toMaybeUnionType();\n    for (JSType altType : unionType.getAlternates()) {\n        if (!altType.isUnknownType() && !altType.isVoidType()) {\n            return false;\n        }\n    }\n    return true;\n}",
    "exact_match": false,
    "ast_match": false,
    "compile": false,
    "test": false
}