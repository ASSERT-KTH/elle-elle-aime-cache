{
    "generation": "@Override public void visit(NodeTraversal t, Node n, Node parent) {\n  if (t.inGlobalScope()) {\n    return;\n  }\n\n  if (n.isReturn() && n.getFirstChild() != null) {\n    data.get(t.getScopeRoot()).recordNonEmptyReturn();\n  }\n\n  int scopeDepth = t.getScopeDepth();\n  if (scopeDepth <= 2) {\n    // Skip global and top-level functions for this analysis\n    return;\n  }\n\n  if (n.isName() && NodeUtil.isLValue(n) && !NodeUtil.isBleedingFunctionName(n)) {\n    String name = n.getString();\n    Scope scope = t.getScope();\n    Var var = scope.getVar(name);\n    if (var != null) {\n      Scope ownerScope = var.getScope();\n      if (ownerScope.isLocal()) {\n        data.get(ownerScope.getRootNode()).recordAssignedName(name);\n        // Record the type of the assignment\n        Node rhs = NodeUtil.getAssignRightHandSide(n, parent);\n        if (rhs != null) {\n          Type type = t.getTypeOfNode(rhs);\n          data.get(ownerScope.getRootNode()).recordAssignedType(name, type);\n        }\n      }\n\n      if (scope != ownerScope && ownerScope.isLocal()) {\n        data.get(ownerScope.getRootNode()).recordEscapedVarName(name);\n      }\n    }\n  } else if (n.isGetProp() && n.isUnscopedQualifiedName() && NodeUtil.isLValue(n)) {\n    String name = NodeUtil.getRootOfQualifiedName(n).getString();\n    Scope scope = t.getScope();\n    Var var = scope.getVar(name);\n    if (var != null) {\n      Scope ownerScope = var.getScope();\n      if (scope != ownerScope && ownerScope.isLocal()) {\n        data.get(ownerScope.getRootNode()).recordEscapedQualifiedName(n.getQualifiedName());\n      }\n    }\n  } else if (n.isCall() && n.getFirstChild().isGetProp()) {\n    // Check if the call is to a method with known type signatures\n    Node receiver = n.getFirstChild().getFirstChild();\n    Node methodName = n.getFirstChild().getSecondChild();\n    if (receiver != null && methodName != null) {\n      Type receiverType = t.getTypeOfNode(receiver);\n      String methodNameStr = methodName.getString();\n      JSTypeInfo methodType = receiverType.getRestrictableType()\n          .getMemberType(methodNameStr);\n      if (methodType != null && methodType.isFunctionType()) {\n        FunctionType funcType = (FunctionType) methodType;\n        NodeList<Node> args = n.getChildren();\n        for (int i = 1, len = args.getLength(); i < len; i++) {\n          Node arg = args.get(i);\n          Type argType = t.getTypeOfNode(arg);\n          Type formalType = funcType.getParameterType(i - 1);\n          if (!formalType.isAssignableFrom(argType)) {\n            t.report(n, \"actual parameter %d of %s does not match formal parameter\\n\" +\n                \"found   : %s\\n\" +\n                \"required: %s\", i, methodNameStr, argType, formalType);\n          }\n        }\n      }\n    }\n  }\n}",
    "exact_match": false,
    "ast_match": false,
    "compile": false,
    "test": false
}