{
    "generation": "protected void registerTypeVariablesOn(Type classType) {\n    if (!(classType instanceof ParameterizedType)) {\n        return;\n    }\n    ParameterizedType parameterizedType = (ParameterizedType) classType;\n    Type[] actualTypeArguments = parameterizedType.getActualTypeArguments();\n    Type rawType = parameterizedType.getRawType();\n    if (!(rawType instanceof Class)) {\n        return;\n    }\n    TypeVariable[] typeParameters = ((Class<?>) rawType).getTypeParameters();\n\n    // Check for self-referential types\n    if (typeParameters.length == actualTypeArguments.length) {\n        for (int i = 0; i < actualTypeArguments.length; i++) {\n            TypeVariable typeParameter = typeParameters[i];\n            Type actualTypeArgument = actualTypeArguments[i];\n\n            // Avoid infinite recursion with self-referential types\n            if (isSelfReferential(typeParameter, actualTypeArgument)) {\n                contextualActualTypeParameters.put(typeParameter, typeParameter);\n            } else if (actualTypeArgument instanceof WildcardType) {\n                contextualActualTypeParameters.put(typeParameter, boundsOf((WildcardType) actualTypeArgument));\n            } else if (actualTypeArgument instanceof TypeVariable) {\n                // Handle nested type variables\n                TypeVariable nestedTypeVariable = (TypeVariable) actualTypeArgument;\n                if (contextualActualTypeParameters.containsKey(nestedTypeVariable)) {\n                    contextualActualTypeParameters.put(typeParameter, contextualActualTypeParameters.get(nestedTypeVariable));\n                } else {\n                    contextualActualTypeParameters.put(typeParameter, actualTypeArgument);\n                }\n            } else {\n                contextualActualTypeParameters.put(typeParameter, actualTypeArgument);\n            }\n        }\n    }\n}\n\nprivate boolean isSelfReferential(TypeVariable typeParameter, Type actualTypeArgument) {\n    if (actualTypeArgument instanceof TypeVariable) {\n        return typeParameter.equals(actualTypeArgument);\n    }\n    return false;\n}\n\nprivate Type boundsOf(WildcardType wildcardType) {\n    Type[] upperBounds = wildcardType.getUpperBounds();\n    return upperBounds.length > 0 ? upperBounds[0] : Object.class;\n}",
    "exact_match": false,
    "ast_match": false,
    "compile": false,
    "test": false
}