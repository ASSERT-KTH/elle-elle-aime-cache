{
    "generation": "private static void modify(Calendar val, int field, boolean round) {\n    if (val.get(Calendar.YEAR) > 280000000) {\n        throw new ArithmeticException(\"Calendar value too large for accurate calculations\");\n    }\n\n    // truncate milliseconds\n    if (round && val.get(Calendar.MILLISECOND) > 499) {\n        val.add(Calendar.SECOND, 1);\n        val.set(Calendar.MILLISECOND, 0);\n    } else {\n        val.set(Calendar.MILLISECOND, 0);\n    }\n\n    // truncate seconds\n    if (round && val.get(Calendar.SECOND) > 29) {\n        val.add(Calendar.MINUTE, 1);\n        val.set(Calendar.SECOND, 0);\n    } else {\n        val.set(Calendar.SECOND, 0);\n    }\n\n    // truncate minutes\n    if (round && val.get(Calendar.MINUTE) > 29) {\n        val.add(Calendar.HOUR_OF_DAY, 1);\n        val.set(Calendar.MINUTE, 0);\n    } else {\n        val.set(Calendar.MINUTE, 0);\n    }\n\n    // reset time\n    if (field == SEMI_MONTH) {\n        //This is a special case that's hard to generalize\n        //If the date is 1, we round up to 16, otherwise\n        //  we subtract 15 days and add 1 month\n        if (val.get(Calendar.DATE) == 1) {\n            val.add(Calendar.DATE, 15);\n        } else {\n            val.add(Calendar.DATE, -15);\n            val.add(Calendar.MONTH, 1);\n        }\n        return;\n    }\n\n    boolean roundUp = false;\n    for (int i = 0; i < fields.length; i++) {\n        for (int j = 0; j < fields[i].length; j++) {\n            if (fields[i][j] == field) {\n                //This is our field... we stop looping\n                if (round) {\n                    val.add(field, 1);\n                    val.set(field, val.getActualMinimum(field));\n                }\n                return;\n            }\n        }\n        //We have various fields that are not easy roundings\n        int offset = 0;\n        boolean offsetSet = false;\n        //These are special types of fields that require different rounding rules\n        switch (field) {\n            case DATE:\n                if (fields[i][0] == DAY_OF_WEEK) {\n                    val.set(DAY_OF_WEEK, val.getActualMinimum(DAY_OF_WEEK));\n                    continue;\n                }\n            case MONTH:\n                break;\n            case SEMI_MONTH:\n                if (fields[i][0] == CALENDAR_DATE) {\n                    //If we're going to drop the DAY_OF_MONTH field's value,\n                    //  we want to do this our own way.\n                    offset = val.get(CALENDAR_DATE) - 1;\n                    //If we're above 15 days adjustment, that means we're in the\n                    //  bottom half of the month and should stay accordingly.\n                    if (offset > 15) {\n                        offset -= 15;\n                    }\n                    //Record whether we're in the top or bottom half of that range\n                    roundUp = offset > 8;\n                    offsetSet = true;\n                }\n                break;\n            case CAL_AM_PM:\n                break;\n            case CAL_DOW:\n                break;\n            case CALERA_YEAR:\n                break;\n        }\n        if (!offsetSet) {\n            int min = val.getActualMinimum(fields[i][0]);\n            offset = val.get(fields[i][0]) - min;\n            roundUp = offset > ((val.getActualMaximum(fields[i][0]) - min) / 2);\n        }\n\n        //We need to remove this field\n            val.set(fields[i][0], val.get(fields[i][0]) - offset);\n    }\n}",
    "exact_match": false,
    "ast_match": false,
    "compile": false,
    "test": false
}