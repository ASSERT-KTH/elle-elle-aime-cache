{
    "generation": "/**\n * Method that can be called on backends that support passing opaque datatypes of\n * non-JSON formats\n *\n * @since 2.8\n */\npublic void writeEmbeddedObject(Object object) throws IOException {\n    if (object == null) {\n        writeNull();\n        return;\n    }\n\n    byte[] bytes;\n    if (object instanceof byte[]) {\n        bytes = (byte[]) object;\n        if (_outputBuffer!= null && (_outputEnd - _outputTail >= bytes.length)) {\n            // direct embedded copying if small enough?\n            _outputHead++;\n            System.arraycopy(bytes, 0, _outputBuffer, _outputTail, bytes.length);\n            _outputTail += bytes.length;\n            _flushWrite(); // needed so last batch of buffering does need full flush at close etc.\n        } else if (getOutputTarget()!= null) {\n            (_flushBuffer().getInputTarget()).write(bytes, 0, bytes.length);\n            getOutput().setCommitted(bytes.length);\n        } else if (useStdoutWithNoEmbeddedFormatting) {\n            for (int i = 0, len = bytes.length; i < len; ) {\n                // This variant might have faster branches that use byte[i], vs copying the `bytes' first:\n                while (++_outputPtr <= Buf_size && ++i!= len) _output.append(_symbols.quote(int)) == i).quote >.\n                    + ((())])])\n                   .\n                        /, i).\n            return this; i <length (outputBytes - byte.append. flush byte.\n      ;",
    "exact_match": false,
    "ast_match": false,
    "compile": false,
    "test": false
}