{
    "generation": "  /** {@inheritDoc} */\n  @Override\n  public void integrate(final ExpandableStatefulODE equations, final double t)\n      throws MathIllegalStateException, MathIllegalArgumentException {\n\n    sanityChecks(equations, t);\n    setEquations(equations);\n    final boolean forward = t > equations.getTime();\n\n    // create some internal working arrays\n    final double[] y0 = equations.getCompleteState();\n    final double[] y = y0.clone();\n    final int stages = c.length + 1;\n    final double[][] yDotK = new double[stages][y.length];\n    final double[] yTmp = y0.clone();\n    final double[] yDotTmp = new double[y.length];\n\n    // set up an interpolator sharing the integrator arrays\n    final RungeKuttaStepInterpolator interpolator = (RungeKuttaStepInterpolator) prototype.copy();\n    interpolator.reinitialize(this, yTmp, yDotK, forward,\n                              equations.getPrimaryMapper(), equations.getSecondaryMappers());\n    interpolator.storeTime(equations.getTime());\n\n    // set up integration control objects\n    stepStart = equations.getTime();\n    double hNew = 0;\n    boolean firstTime = true;\n    initIntegration(stepStart, y0, t);\n\n    // main integration loop\n    isLastStep = false;\n    do {\n      interpolator.shift();\n\n      // iterate over step size, ensuring local normalized error is smaller than 1\n      double error = 10;\n      while (error >= 1.0) {\n        if (firstTime || !fsal) {\n          // first stage\n          computeDerivatives(stepStart, y, yDotK[0]);\n        }\n\n        if (firstTime) {\n          final double[] scale = vecAbsoluteTolerance == null\n                                    ? vecRelativeTolerance.mapMultiply(FastMath.abs(y[0]))\n                                    : ArrayRealVector.add(ArrayRealVector.ebeMultiply(vecAbsoluteTolerance, FastMath.abs(y[0]), vecRelativeTolerance), 1.0);\n          double scaledHNew = initializeStep(forward, getOrder(), scale,\n                                            stepStart, y, yDotK[0], yTmp, yDotK[1]);\n\n          // Adjust the step size to make sure it's within the acceptable range\n          scaledHNew = Math.min(scaledHNew, filterStep(scaledHNew, forward, false));\n          scaledHNew = Math.min(scaledHNew, t - stepStart);\n          hNew = scaledHNew;\n          firstTime = false;\n        }\n\n        stepSize = hNew;\n\n        // remaining part of the function omitted for brevity\n      }\n\n      // remaining part of the function omitted for brevity\n    } while (!isLastStep);\n\n    // dispatch results\n    equations.setTime(stepStart);\n    equations.setCompleteState(y);\n\n    resetInternalState();\n  }",
    "exact_match": false,
    "ast_match": false,
    "compile": false,
    "test": false
}