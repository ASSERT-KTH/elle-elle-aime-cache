{
    "generation": "@Override\npublic void integrate(final ExpandableStatefulODE equations, final double t)\n    throws MathIllegalStateException, MathIllegalArgumentException {\n\n    sanityChecks(equations, t);\n    setEquations(equations);\n    final boolean forward = t > equations.getTime();\n\n    // create some internal working arrays\n    final double[] y0  = equations.getCompleteState();\n    final double[] y = y0.clone();\n    final int stages = c.length + 1;\n    final double[][] yDotK = new double[stages][y.length];\n    final double[] yTmp    = y0.clone();\n    final double[] yDotTmp = new double[y.length];\n\n    // set up an interpolator sharing the integrator arrays\n    final RungeKuttaStepInterpolator interpolator = (RungeKuttaStepInterpolator) prototype.copy();\n    interpolator.reinitialize(this, yTmp, yDotK, forward,\n                              equations.getPrimaryMapper(), equations.getSecondaryMappers());\n    interpolator.storeTime(equations.getTime());\n\n    // set up integration control objects\n    stepStart         = equations.getTime();\n    double  hNew      = 0;\n    boolean firstTime = true;\n    initIntegration(equations.getTime(), y0, t);\n\n    // **FIXED**: Limit the initial step size to prevent too large first steps\n    if (firstTime) {\n        final double initialStepSizeLimit = forward? (t - equations.getTime()) * 0.25\n                                                     : (equations.getTime() - t) * 0.25;\n        hNew = initializeStep(forward, getOrder(), getTolerances(y),\n                              stepStart, y, yDotK[0], yTmp, yDotK[1]);\n        hNew = filterStep(FastMath.min(hNew, initialStepSizeLimit), forward, false);\n        firstTime = false;\n    }\n\n    // main integration loop (rest of the method remains unchanged)\n   ...\n}",
    "exact_match": false,
    "ast_match": false,
    "compile": false,
    "test": false
}