{
    "generation": "import com.google.common.collect.Sets;\nimport java.util.HashSet;\nimport java.util.Arrays;\nimport java.util.Set;\n\npublic class FunctionSideEffectChecker {\n\n    private static final Set<String> BUILTIN_FUNCTIONS_WITHOUT_SIDEEFFECTS = Sets.newHashSet(\"escape\", \"unescape\");\n    private static final Set<String> OBJECT_METHODS_WITHOUT_SIDEEFFECTS = Sets.newHashSet(\"toSource\", \"toString\", \"valueOf\");\n    private static final Set<String> REGEXP_METHODS = Sets.newHashSet(\"exec\", \"test\");\n    private static final Set<String> STRING_REGEXP_METHODS = Sets.newHashSet(\"match\", \"search\", \"replace\", \"split\");\n\n    /**\n     * Returns true if calls to this function have side effects.\n     *\n     * @param callNode The call node to inspected.\n     * @param compiler A compiler object to provide program state changing\n     *     context information. Can be null.\n     */\n    static boolean functionCallHasSideEffects(Node callNode, @Nullable AbstractCompiler compiler) {\n        if (callNode.getType() != Token.CALL) {\n            throw new IllegalStateException(\n                    \"Expected CALL node, got \" + Token.name(callNode.getType()));\n        }\n\n        if (callNode.isNoSideEffectsCall()) {\n            return false;\n        }\n\n        Node nameNode = callNode.getFirstChild();\n\n        // Built-in functions with no side effects.\n        if (nameNode.getType() == Token.NAME) {\n            String name = nameNode.getString();\n            if (BUILTIN_FUNCTIONS_WITHOUT_SIDEEFFECTS.contains(name)) {\n                return false;\n            }\n        } else if (nameNode.getType() == Token.GETPROP) {\n            Node receiver = nameNode.getFirstChild();\n            if (receiver.getType() == Token.NAME && receiver.getString().equals(\"Math\")) {\n                String methodName = nameNode.getLastChild().getString();\n                if (MATH_METHODS_WITHOUT_SIDEEFFECTS.contains(methodName)) {\n                    return false;\n                }\n            }\n\n            if (callNode.hasOneChild()\n                    && OBJECT_METHODS_WITHOUT_SIDEEFFECTS.contains(\n                            nameNode.getLastChild().getString())) {\n                return false;\n            }\n\n            if (callNode.isOnlyModifiesThisCall()\n                    && evaluatesToLocalValue(nameNode.getFirstChild())) {\n                return false;\n            }\n\n            // Functions in the \"Math\" namespace have no side effects.\n            if (compiler != null && !compiler.hasRegExpGlobalReferences()) {\n                if (receiver.getType() == Token.REGEXP\n                        && REGEXP_METHODS.contains(nameNode.getLastChild().getString())) {\n                    return false;\n                } else if (receiver.getType() == Token.STRING\n                        && STRING_REGEXP_METHODS.contains(\n                                nameNode.getLastChild().getString())) {\n                    Node param = nameNode.getNext();\n                    if (param != null &&\n                            (param.getType() == Token.STRING\n                                    || param.getType() == Token.REGEXP)) {\n                        return false;\n                    }\n                }\n            }\n        }\n\n        return true;\n    }\n\n    private static final Set<String> MATH_METHODS_WITHOUT_SIDEEFFECTS = Sets.newHashSet(\n            \"sin\", \"cos\", \"tan\", \"asin\", \"acos\", \"atan\", \"atan2\", \"exp\", \"log\",\n            \"pow\", \"sqrt\", \"ceil\", \"floor\", \"round\", \"abs\", \"sign\", \"imag\", \"real\",\n            \"fround\", \"cbrt\", \"clz32\", \"hypot\", \"imul\", \"log10\", \"log1p\", \"log2\",\n            \"max\", \"min\", \"random\", \"trunc\"\n    );\n\n    // Helper methods and classes would go here, but are omitted for brevity.\n}",
    "exact_match": false,
    "ast_match": false,
    "compile": false,
    "test": false
}