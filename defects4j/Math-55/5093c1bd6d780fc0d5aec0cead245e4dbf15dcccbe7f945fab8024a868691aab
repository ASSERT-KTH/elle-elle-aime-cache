{
    "generation": "  /** Compute the cross-product of two vectors.\n   * @param v1 first vector\n   * @param v2 second vector\n   * @return the cross product v1 ^ v2 as a new Vector\n   */\n  public static Vector3D crossProduct(final Vector3D v1, final Vector3D v2) {\n\n      // Compute the norm of the vectors\n      double norm1 = v1.getNorm();\n      double norm2 = v2.getNorm();\n\n      // Compute the scale factor to rescale vectors to the same order of magnitude\n      double scaleFactor = FastMath.sqrt(norm1 / norm2);\n\n      // Rescale the vectors\n      Vector3D v1Rescaled = v1.scalarMultiply(scaleFactor);\n      Vector3D v2Rescaled = v2.scalarMultiply(1.0 / scaleFactor);\n\n      // Compute rho as an 8 bits approximation of v1Rescaled.v2Rescaled / v2Rescaled.v2Rescaled\n      double dotProductV1V2 = v1Rescaled.dotProduct(v2Rescaled);\n      double dotProductV2V2 = v2Rescaled.getNormSq();\n      double rho = (int) (128.0 * dotProductV1V2 / dotProductV2V2) / 128.0;\n\n      // Compute v3 = v1Rescaled - rho * v2Rescaled\n      Vector3D v3 = v1Rescaled.subtract(v2Rescaled.scalarMultiply(rho));\n\n      // Compute the cross product from v3 and v2Rescaled instead of v1Rescaled and v2Rescaled\n      return new Vector3D(v3.getY() * v2Rescaled.getZ() - v3.getZ() * v2Rescaled.getY(),\n                          v3.getZ() * v2Rescaled.getX() - v3.getX() * v2Rescaled.getZ(),\n                          v3.getX() * v2Rescaled.getY() - v3.getY() * v2Rescaled.getX());\n\n  }",
    "exact_match": false,
    "ast_match": false,
    "compile": false,
    "test": false
}