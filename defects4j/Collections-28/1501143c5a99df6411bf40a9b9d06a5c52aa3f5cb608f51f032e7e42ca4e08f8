{
    "generation": "@Override\npublic SortedMap<K, V> prefixMap(final K prefix) {\n    final Node<K, V> root = rootNode;\n    final Node<K, V> node = findNode(root, prefix, 0);\n    if (node == null) {\n        return Collections.emptySortedMap();\n    }\n\n    final TrieMap<K, V> subMap = new TrieMap<>(root, node, prefix);\n    return new TreeMap<>(subMap);\n}\n\nprivate static final class TrieMap<K, V> extends AbstractSortedMap<K, V> {\n    private final Node<K, V> root;\n    private final Node<K, V> node;\n    private final K prefix;\n\n    TrieMap(final Node<K, V> root, final Node<K, V> node, final K prefix) {\n        this.root = root;\n        this.node = node;\n        this.prefix = prefix;\n    }\n\n    @Override\n    public Set<Map.Entry<K, V>> entrySet() {\n        return new AbstractSet<Map.Entry<K, V>>() {\n            @Override\n            public Iterator<Map.Entry<K, V>> iterator() {\n                return new Iterator<Map.Entry<K, V>>() {\n                    private final NodeIterator<K, V> it = new NodeIterator<>(root, node, root.comp, prefix);\n\n                    @Override\n                    public boolean hasNext() {\n                        return it.hasNext();\n                    }\n\n                    @Override\n                    public Map.Entry<K, V> next() {\n                        return it.next();\n                    }\n\n                    @Override\n                    public void remove() {\n                        it.remove();\n                    }\n                };\n            }\n\n            @Override\n            public int size() {\n                int size = 0;\n                for (final NodeIterator<K, V> it = new NodeIterator<>(root, node, root.comp, prefix); it.hasNext(); ) {\n                    it.next();\n                    size++;\n                }\n                return size;\n            }\n        };\n    }\n\n    @Override\n    public V put(final K key, final V value) {\n        final V oldValue = root.put(root, key, value, 0, root.comp, null);\n        if (oldValue == null && comp.compare(key, prefix) >= 0) {\n            node.put(node, key, value, 0, comp, null);\n        }\n        return oldValue;\n    }\n\n    @Override\n    public V remove(final Object key) {\n        final V oldValue = root.remove(root, (K) key, 0, root.comp, null);\n        if (oldValue != null && comp.compare((K) key, prefix) >= 0) {\n            node.remove(node, (K) key, 0, comp, null);\n        }\n        return oldValue;\n    }\n\n    @Override\n    public void clear() {\n        for (final Iterator<Map.Entry<K, V>> it = entrySet().iterator(); it.hasNext(); ) {\n            it.next();\n            it.remove();\n        }\n    }\n\n    @Override\n    public Comparator<? super K> comparator() {\n        return root.comp;\n    }\n\n    @Override\n    public K firstKey() {\n        final NodeIterator<K, V> it = new NodeIterator<>(root, node, root.comp, prefix);\n        if (!it.hasNext()) {\n            throw new NoSuchElementException();\n        }\n        return it.next().key();\n    }\n\n    @Override\n    public K lastKey() {\n        final NodeIterator<K, V> it = new NodeIterator<>(root, node, root.comp, prefix);\n        K last = null;\n        while (it.hasNext()) {\n            last = it.next().key();\n        }\n        if (last == null) {\n            throw new NoSuchElementException();\n        }\n        return last;\n    }\n\n    @Override\n    public SortedMap<K, V> subMap(final K fromKey, final K toKey) {\n        final Node<K, V> fromNode = findNode(root, fromKey, 0);\n        final Node<K, V> toNode = findNode(root, toKey, 0);\n        if (fromNode == null || toNode == null || comp.compare(fromKey, toKey) >= 0) {\n            return Collections.emptySortedMap();\n        }\n        return new TrieMap<>(root, fromNode, fromKey).headMap(toKey);\n    }\n\n    @Override\n    public SortedMap<K, V> headMap(final K toKey) {\n        final Node<K, V> toNode = findNode(root, toKey, 0);\n        if (toNode == null) {\n            return Collections.emptySortedMap();\n        }\n        return new TrieMap<>(root, node, prefix).subMap(prefix, toKey);\n    }\n\n    @Override\n    public SortedMap<K, V> tailMap(final K fromKey) {\n        final Node<K, V> fromNode = findNode(root, fromKey, 0);\n        if (fromNode == null) {\n            return Collections.emptySortedMap();\n        }\n        return new TrieMap<>(root, fromNode, fromKey);\n    }\n}",
    "exact_match": false,
    "ast_match": false,
    "compile": false,
    "test": false
}