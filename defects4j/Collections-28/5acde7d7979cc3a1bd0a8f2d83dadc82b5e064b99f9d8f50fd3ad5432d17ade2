{
    "generation": "public class PatriciaTrie<K, V> implements Trie<K, V> {\n    // other methods and fields...\n\n    @Override\n    public SortedMap<K, V> prefixMap(final K prefixKey) {\n        if (prefixKey == null) {\n            throw new NullPointerException(\"Prefix key must not be null\");\n        }\n        @SuppressWarnings(\"unchecked\")\n        K prefix = (K) prefixKey;\n        // Find the starting and ending keys for the prefix\n        K start = prefix;\n        K end = (K) ((NavigableMap<String, V>) this).higherKey(prefix);\n        if (end == null || !end.startsWith((String) prefix)) {\n            end = (K) ((NavigableMap<String, V>) this).navigableKeySet().higher(prefix);\n            if (end != null && end.startsWith((String) prefix)) {\n                end = (K) ((NavigableMap<String, V>) this).navigableKeySet().higher(end);\n            } else {\n                end = (K) ((NavigableMap<String, V>) this).navigableKeySet().higher(prefix);\n            }\n        }\n        // Create a submap with the appropriate range\n        NavigableMap<K, V> subMap = (NavigableMap<K, V>) ((NavigableMap<String, V>) this).subMap(start, true, end, false);\n        return new SortedMap<K, V>() {\n            @Override\n            public K lowerKey(K key) {\n                return subMap.lowerKey(key);\n            }\n\n            @Override\n            public K floorKey(K key) {\n                return subMap.floorKey(key);\n            }\n\n            @Override\n            public K ceilingKey(K key) {\n                return subMap.ceilingKey(key);\n            }\n\n            @Override\n            public K higherKey(K key) {\n                return subMap.higherKey(key);\n            }\n\n            @Override\n            public K firstKey() {\n                return subMap.firstKey();\n            }\n\n            @Override\n            public K lastKey() {\n                return subMap.lastKey();\n            }\n\n            @Override\n            public V get(Object key) {\n                return subMap.get(key);\n            }\n\n            @Override\n            public V put(K key, V value) {\n                if (!((String) key).startsWith((String) prefix)) {\n                    throw new IllegalArgumentException(\"Key does not have the required prefix\");\n                }\n                return subMap.put(key, value);\n            }\n\n            @Override\n            public V remove(Object key) {\n                if (!((String) key).startsWith((String) prefix)) {\n                    throw new IllegalArgumentException(\"Key does not have the required prefix\");\n                }\n                return subMap.remove(key);\n            }\n\n            @Override\n            public void putAll(Map<? extends K, ? extends V> m) {\n                for (Entry<? extends K, ? extends V> entry : m.entrySet()) {\n                    put(entry.getKey(), entry.getValue());\n                }\n            }\n\n            @Override\n            public void clear() {\n                subMap.keySet().removeIf(k -> ((String) k).startsWith((String) prefix));\n            }\n\n            @Override\n            public int size() {\n                return subMap.size();\n            }\n\n            @Override\n            public boolean isEmpty() {\n                return subMap.isEmpty();\n            }\n\n            @Override\n            public boolean containsKey(Object key) {\n                return subMap.containsKey(key);\n            }\n\n            @Override\n            public Set<Entry<K, V>> entrySet() {\n                return subMap.entrySet();\n            }\n\n            @Override\n            public Collection<V> values() {\n                return subMap.values();\n            }\n\n            @Override\n            public Set<K> keySet() {\n                return subMap.keySet();\n            }\n        };\n    }\n}",
    "exact_match": false,
    "ast_match": false,
    "compile": false,
    "test": false
}