{
    "generation": "@Override\npublic SortedMap<K, V> prefixMap(K prefix) {\n    NavigableSet<K> keySet = new TreeSet<>();\n    for (K key : this.keySet()) {\n        if (key.toString().startsWith(prefix.toString())) {\n            keySet.add(key);\n        }\n    }\n    return new SortedMap<K, V>() {\n        @Override\n        public int size() {\n            return keySet.size();\n        }\n\n        @Override\n        public boolean isEmpty() {\n            return keySet.isEmpty();\n        }\n\n        @Override\n        public boolean containsKey(Object key) {\n            return keySet.contains(key);\n        }\n\n        @Override\n        public boolean containsValue(Object value) {\n            for (K key : keySet) {\n                if (get(key).equals(value)) {\n                    return true;\n                }\n            }\n            return false;\n        }\n\n        @Override\n        public V get(Object key) {\n            return PatriciaTrie.this.get(key);\n        }\n\n        @Override\n        public V put(K key, V value) {\n            return PatriciaTrie.this.put(key, value);\n        }\n\n        @Override\n        public V remove(Object key) {\n            return PatriciaTrie.this.remove(key);\n        }\n\n        @Override\n        public void putAll(Map<? extends K,? extends V> m) {\n            PatriciaTrie.this.putAll(m);\n        }\n\n        @Override\n        public void clear() {\n            for (K key : new ArrayList<>(keySet)) {\n                PatriciaTrie.this.remove(key);\n            }\n        }\n\n        @Override\n        public Set<K> keySet() {\n            return keySet;\n        }\n\n        @Override\n        public Collection<V> values() {\n            Collection<V> values = new ArrayList<>();\n            for (K key : keySet) {\n                values.add(PatriciaTrie.this.get(key));\n            }\n            return values;\n        }\n\n        @Override\n        public Set<Entry<K, V>> entrySet() {\n            Set<Entry<K, V>> entrySet = new HashSet<>();\n            for (K key : keySet) {\n                entrySet.add(new SimpleEntry<>(key, PatriciaTrie.this.get(key)));\n            }\n            return entrySet;\n        }\n\n        @Override\n        public Comparator<? super K> comparator() {\n            return keySet.comparator();\n        }\n\n        @Override\n        public SortedMap<K, V> subMap(K fromKey, K toKey) {\n            NavigableSet<K> subKeySet = new TreeSet<>();\n            for (K key : keySet) {\n                if (key.compareTo(fromKey) >= 0 && key.compareTo(toKey) < 0) {\n                    subKeySet.add(key);\n                }\n            }\n            return new SortedMap<K, V>() {\n                // implement other methods similarly\n            };\n        }\n\n        @Override\n        public SortedMap<K, V> headMap(K toKey) {\n            NavigableSet<K> headKeySet = new TreeSet<>();\n            for (K key : keySet) {\n                if (key.compareTo(toKey) < 0) {\n                    headKeySet.add(key);\n                }\n            }\n            return new SortedMap<K, V>() {\n                // implement other methods similarly\n            };\n        }\n\n        @Override\n        public SortedMap<K, V> tailMap(K fromKey) {\n            NavigableSet<K> tailKeySet = new TreeSet<>();\n            for (K key : keySet) {\n                if (key.compareTo(fromKey) >= 0) {\n                    tailKeySet.add(key);\n                }\n            }\n            return new SortedMap<K, V>() {\n                // implement other methods similarly\n            };\n        }\n\n        @Override\n        public K firstKey() {\n            return keySet.first();\n        }\n\n        @Override\n        public K lastKey() {\n            return keySet.last();\n        }\n    };\n}\n",
    "exact_match": false,
    "ast_match": false,
    "compile": false,
    "test": false
}