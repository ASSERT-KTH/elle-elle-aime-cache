{
    "generation": "public SortedMap<String, Integer> prefixMap(String prefix) {\n    Node<Integer> rootNode = findNode(prefix);\n    if (rootNode != null) {\n        return new SubMap<>(rootNode, false, true);\n    }\n    return new TreeMap<>();\n}\n\nprivate Node<Integer> findNode(String prefix) {\n    Node<Integer> currentNode = root;\n    int level = 0;\n    while (currentNode != null && level < prefix.length()) {\n        int index = prefix.charAt(level) - 'a';\n        Node<Integer> nextNode = currentNode.transitions[index];\n        if (nextNode == null) {\n            return null;\n        }\n        currentNode = nextNode;\n        level++;\n    }\n    if (level == prefix.length()) {\n        return currentNode;\n    }\n    return null;\n}\n\nprivate static class SubMap<V> extends AbstractMap<String, V> implements SortedMap<String, V> {\n    private final Node<V> rootNode;\n    private final boolean fromStart;\n    private final boolean toEnd;\n\n    public SubMap(Node<V> rootNode, boolean fromStart, boolean toEnd) {\n        this.rootNode = rootNode;\n        this.fromStart = fromStart;\n        this.toEnd = toEnd;\n    }\n\n    @Override\n    public Set<Entry<String, V>> entrySet() {\n        return new AbstractSet<Entry<String, V>>() {\n            @Override\n            public Iterator<Entry<String, V>> iterator() {\n                return new EntrySetIterator();\n            }\n\n            @Override\n            public int size() {\n                return rootNode.size;\n            }\n        };\n    }\n\n    @Override\n    public Comparator<? super String> comparator() {\n        return null;\n    }\n\n    @Override\n    public SortedMap<String, V> subMap(String fromKey, String toKey) {\n        return new SubMap<>(rootNode, false, false);\n    }\n\n    @Override\n    public SortedMap<String, V> headMap(String toKey) {\n        return new SubMap<>(rootNode, fromStart, false);\n    }\n\n    @Override\n    public SortedMap<String, V> tailMap(String fromKey) {\n        return new SubMap<>(rootNode, false, toEnd);\n    }\n\n    @Override\n    public String firstKey() {\n        return null; // Implement based on your requirements\n    }\n\n    @Override\n    public String lastKey() {\n        return null; // Implement based on your requirements\n    }\n\n    public void clear() {\n        if (rootNode != null) {\n            rootNode.transitions = new Node[26];\n        }\n    }\n\n    private class EntrySetIterator implements Iterator<Entry<String, V>> {\n        private final LinkedList<Node.Entry<String, V>> entries = new LinkedList<>();\n        private Iterator<Node.Entry<String, V>> currentIterator;\n\n        public EntrySetIterator() {\n            if (rootNode != null) {\n                entries.addAll(rootNode.entries());\n            }\n            if (!entries.isEmpty()) {\n                currentIterator = entries.iterator();\n            }\n        }\n\n        @Override\n        public boolean hasNext() {\n            return currentIterator != null && currentIterator.hasNext();\n        }\n\n        @Override\n        public Entry<String, V> next() {\n            if (currentIterator != null && currentIterator.hasNext()) {\n                return currentIterator.next();\n            }\n            throw new NoSuchElementException();\n        }\n    }\n}",
    "exact_match": false,
    "ast_match": false,
    "compile": false,
    "test": false
}