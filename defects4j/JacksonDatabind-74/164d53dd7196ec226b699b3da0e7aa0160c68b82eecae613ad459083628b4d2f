{
    "generation": "protected Object _deserializeTypedUsingDefaultImpl(JsonParser p, DeserializationContext ctxt, TokenBuffer tb) throws IOException\n{\n    if (p.getCurrentToken() == JsonToken.START_OBJECT) {\n        // Look ahead to check for the \"type\" property\n        String fieldName = p.nextFieldName();\n        if (\"type\".equals(fieldName)) {\n            p.nextToken(); // Move the parser to the value of the \"type\" property\n            JsonDeserializer<Object> deser = _findDefaultImplDeserializer(ctxt);\n            if (deser != null) {\n                if (tb != null) {\n                    tb.writeEndObject();\n                    p = tb.asParser(p);\n                    // Must move to point to the first token:\n                    p.nextToken();\n                }\n                return deser.deserialize(p, ctxt);\n            }\n            // If \"type\" property exists but we don't have a deserializer, throw an exception\n            ctxt.reportWrongTokenException(p, JsonToken.FIELD_NAME,\n                    \"Unexpected value for 'type' property, expected a value that can be deserialized by a default implementation of class \" + baseTypeName());\n        }\n        // If \"type\" property does not exist, treat it as a \"natural\" value (boolean/int/double/String) or use the default implementation\n        p.nextToken(); // Move the parser to the value of the \"value\" property\n    }\n\n    Object result = TypeDeserializer.deserializeIfNatural(p, ctxt, _baseType);\n    if (result != null) {\n        return result;\n    }\n\n    // Empty string handling as per ACCEPT_EMPTY_STRING_AS_NULL_OBJECT feature\n    if (p.getCurrentToken() == JsonToken.VALUE_STRING && p.getText().isEmpty()) {\n        return null;\n    }\n\n    // For other cases, try to use the default implementation\n    JsonDeserializer<Object> deser = _findDefaultImplDeserializer(ctxt);\n    if (deser != null) {\n        if (tb != null) {\n            tb.writeEndObject();\n            p = tb.asParser(p);\n            // Must move to point to the first token:\n            p.nextToken();\n        }\n        return deser.deserialize(p, ctxt);\n    }\n\n    // If no default implementation is found, throw an exception\n    ctxt.reportWrongTokenException(p, JsonToken.FIELD_NAME,\n            \"missing property '\"+_typePropertyName+\"' that is to contain type id  (for class \"+baseTypeName()+\")\");\n    return null;\n}",
    "exact_match": false,
    "ast_match": false,
    "compile": true,
    "test": false
}