{
    "generation": "    /**\n     * Visit a node in a local scope, and add any local variables or catch\n     * parameters into the local symbol table.\n     *\n     * @param t The node traversal.\n     * @param n The node being visited.\n     * @param parent The parent of n\n     */\n    @Override public void visit(NodeTraversal t, Node n, Node parent) {\n      if (n == scope.getRootNode()) return;\n\n      if (n.getType() == Token.LP && parent.getType() == Token.FUNCTION) {\n        handleFunctionInputs(parent);\n        return;\n      }\n\n      attachLiteralTypes(n);\n      switch (n.getType()) {\n        case Token.FUNCTION:\n          if (parent.getType() == Token.NAME) {\n            defineNamedFunction(n, parent);\n          } else {\n            defineDeclaredFunction(n, parent);\n          }\n          break;\n        case Token.CATCH:\n          defineCatch(n, parent);\n          break;\n        case Token.VAR:\n          defineVar(n, parent);\n          break;\n        case Token.LET:\n        case Token.CONST:\n          defineBlockScopedVar(n, parent);\n          break;\n      }\n    }\n\n    private void defineNamedFunction(Node n, Node parent) {\n      Node nameNode = parent;\n      String name = nameNode.getString();\n      JSType type = getFunctionType(n);\n      Var var = scope.declare(nameNode, name, type, n, Var.Variance.UNKNOWN);\n      var.markAsHoistedFunction();\n    }\n\n    private void defineDeclaredFunction(Node n, Node parent) {\n      Node nameNode = n.getFirstChild();\n      String name = nameNode.getString();\n      JSType type = getFunctionType(n);\n      Var var = scope.declare(nameNode, name, type, n, Var.Variance.UNKNOWN);\n      var.markAsHoistedFunction();\n    }\n\n    private void defineVar(Node n, Node parent) {\n      for (Node c = n.getFirstChild(); c != null; c = c.getNext()) {\n        String name = c.getString();\n        JSType type = getType(c);\n        Var var = scope.declare(c, name, type, c, Var.Variance.UNKNOWN);\n        attachExpressionTypes(c.getFirstChild(), var);\n      }\n    }\n\n    private void defineBlockScopedVar(Node n, Node parent) {\n      for (Node c = n.getFirstChild(); c != null; c = c.getNext()) {\n        String name = c.getString();\n        JSType type = getType(c);\n        Var var = scope.declare(c, name, type, c, Var.Variance.UNKNOWN);\n        var.markAsBlockScoped();\n        attachExpressionTypes(c.getFirstChild(), var);\n      }\n    }\n\n    private void defineCatch(Node n, Node parent) {\n      Node catchVar = n.getFirstChild();\n      String name = catchVar.getString();\n      JSType type = getType(catchVar);\n      scope.declare(catchVar, name, type, catchVar, Var.Variance.UNKNOWN);\n    }\n\n    private JSType getFunctionType(Node n) {\n      // Implement logic to determine the function type\n      return registry.getNativeType(JSTypeNative.UNKNOWN_TYPE);\n    }\n\n    private JSType getType(Node n) {\n      // Implement logic to determine the type of a node\n      return registry.getNativeType(JSTypeNative.UNKNOWN_TYPE);\n    }\n\n    private void attachExpressionTypes(Node n, Var var) {\n      // Implement logic to attach types to expressions\n    }",
    "exact_match": false,
    "ast_match": false,
    "compile": false,
    "test": false
}