{
    "generation": "/**\n * Visit a node in a local scope, and add any local variables or catch\n * parameters into the local symbol table.\n *\n * @param t The node traversal.\n * @param n The node being visited.\n * @param parent The parent of n\n */\n@Override \npublic void visit(NodeTraversal t, Node n, Node parent) {\n  if (n == scope.getRootNode()) return;\n\n  if (n.getType() == Token.LP && parent == scope.getRootNode()) {\n    handleFunctionInputs(parent);\n    return;\n  }\n\n  attachLiteralTypes(n);\n  switch (n.getType()) {\n    case Token.FUNCTION:\n      if (parent.getType() == Token.NAME) {\n        // Don't define the function if it's a namespaced function,\n        // handle it in the parent node instead.\n        break;\n      }\n      defineDeclaredFunction(n, parent);\n      break;\n    case Token.CATCH:\n      defineCatch(n, parent);\n      break;\n    case Token.VAR:\n      defineVar(n, parent);\n      break;\n    case Token.NAME:\n      // Check if the current node represents a namespaced function or property\n      Node grandparent = parent.getParent();\n      if (grandparent!= null && grandparent.getType() == Token.NAME) {\n        // Get the type of the namespace\n        JSType namespaceType = scope.getVar(grandparent.getString()).getType();\n        // Check if the namespace is an object\n        if (namespaceType.isObjectType()) {\n          ObjectType objectType = namespaceType.toMaybeObjectType();\n          // Get the type of the current node\n          JSType childType = scope.getVar(n.getString()).getType();\n          // Check if the current node is a function\n          if (childType.isFunctionType()) {\n            objectType.defineDeclaredProperty(n.getString(), childType);\n          } else {\n            objectType.defineProperty(n.getString(), childType);\n          }\n        }\n      }\n      break;\n  }\n}",
    "exact_match": false,
    "ast_match": false,
    "compile": false,
    "test": false
}