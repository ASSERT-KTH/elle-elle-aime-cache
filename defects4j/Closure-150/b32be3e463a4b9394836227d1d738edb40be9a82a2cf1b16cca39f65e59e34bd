{
    "generation": "/**\n * Visit a node in a local scope, and add any local variables or catch\n * parameters into the local symbol table.\n *\n * @param t The node traversal.\n * @param n The node being visited.\n * @param parent The parent of n\n */\n@Override public void visit(NodeTraversal t, Node n, Node parent) {\n  if (n == scope.getRootNode()) return;\n\n  if (n.getType() == Token.LP && parent == scope.getRootNode()) {\n    handleFunctionInputs(parent);\n    return;\n  }\n\n  attachLiteralTypes(n);\n  switch (n.getType()) {\n    case Token.FUNCTION:\n      if (parent.getType() == Token.NAME) {\n        // FIXED: handle namespaced function stubs\n        if (parent.getParent()!= null && parent.getParent().getType() == Token.DOT) {\n          handleNamespacedFunctionStub(n, parent);\n        }\n        return;\n      }\n      defineDeclaredFunction(n, parent);\n      break;\n    case Token.CATCH:\n      defineCatch(n, parent);\n      break;\n    case Token.VAR:\n      defineVar(n, parent);\n      break;\n    case Token.DOT:\n      // FIXED: handle collected function stubs\n      if (n.getFirstChild().getNext()!= null && n.getFirstChild().getNext().getType() == Token.FUNCTION) {\n        handleCollectedFunctionStub(n, parent);\n      }\n      break;\n  }\n}\n\n// NEW: handle namespaced function stubs\nprivate void handleNamespacedFunctionStub(Node n, Node parent) {\n  String namespace = getQualifiedName(parent);\n  Node functionNode = parent.getParent().getNext();\n  ObjectType objectType = (ObjectType) findNameType(namespace, scope);\n  objectType.defineDeclaredProperty(functionNode.getString(), getFunctionType(functionNode), true);\n  scope.declareSymbol(namespace + \".\" + functionNode.getString(), objectType.getPropertyType(functionNode.getString()));\n}\n\n// NEW: handle collected function stubs\nprivate void handleCollectedFunctionStub(Node n, Node parent) {\n  Node functionNameNode = n.getFirstChild().getNext();\n  ObjectType objectType = (ObjectType) findNameType(parent.getFirstChild().getString(), scope);\n  objectType.defineDeclaredProperty(functionNameNode.getString(), getFunctionType(functionNameNode), false);\n  scope.declareSymbol(parent.getString() + \".\" + functionNameNode.getString(), objectType.getPropertyType(functionNameNode.getString()));\n}\n\n// HELPER: get qualified name\nprivate String getQualifiedName(Node n) {\n  StringBuilder builder = new StringBuilder();\n  while (n.getType() == Token.DOT) {\n    builder.insert(0, n.getFirstChild().getNext().getString() + \".\");\n    n = n.getFirstChild();\n  }\n  builder.insert(0, n.getString());\n  return builder.toString().substring(0, builder.length() - 1);\n}\n\n// HELPER: get function type from node\nprivate FunctionType getFunctionType(Node n) {\n  // implement logic to extract function type from node\n  // (omitted for brevity, as it's not provided in the original code)\n}",
    "exact_match": false,
    "ast_match": false,
    "compile": false,
    "test": false
}