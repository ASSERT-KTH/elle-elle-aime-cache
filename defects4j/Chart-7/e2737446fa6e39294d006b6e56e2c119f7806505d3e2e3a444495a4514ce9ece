{
    "generation": "private void updateBounds(TimePeriod period, int index) {\n    long start = period.getStart().getTime();\n    long end = period.getEnd().getTime();\n    long middle = start + ((end - start) / 2);\n\n    // Update minStartIndex and maxStartIndex\n    updateIndex(this.minStartIndex, start, index, period, true);\n    updateIndex(this.maxStartIndex, start, index, period, false);\n\n    // Update minMiddleIndex and maxMiddleIndex\n    long minMiddle = (this.minMiddleIndex < 0) ? Long.MAX_VALUE : getMiddle(this.minMiddleIndex);\n    long maxMiddle = (this.maxMiddleIndex < 0) ? Long.MIN_VALUE : getMiddle(this.maxMiddleIndex);\n    if (middle < minMiddle) {\n        this.minMiddleIndex = index;\n    }\n    if (middle > maxMiddle) {\n        this.maxMiddleIndex = index;\n    }\n\n    // Update minEndIndex and maxEndIndex\n    updateIndex(this.minEndIndex, end, index, period, true);\n    updateIndex(this.maxEndIndex, end, index, period, false);\n}\n\nprivate long getMiddle(int index) {\n    TimePeriod period = getDataItem(index).getPeriod();\n    long s = period.getStart().getTime();\n    long e = period.getEnd().getTime();\n    return s + ((e - s) / 2);\n}\n\nprivate void updateIndex(int currentIndex, long currentValue, int newIndex, TimePeriod newPeriod, boolean isMin) {\n    if (currentIndex < 0) {\n        if (isMin) {\n            currentValue = Long.MAX_VALUE;\n        } else {\n            currentValue = Long.MIN_VALUE;\n        }\n    } else {\n        currentValue = isMin ? newPeriod.getStart().getTime() : newPeriod.getEnd().getTime();\n    }\n\n    if ((isMin && newValue < currentValue) || (!isMin && newValue > currentValue)) {\n        if (isMin) {\n            this.minStartIndex = newIndex;\n            this.minEndIndex = newIndex;\n        } else {\n            this.maxStartIndex = newIndex;\n            this.maxEndIndex = newIndex;\n        }\n    }\n}",
    "exact_match": false,
    "ast_match": false,
    "compile": false,
    "test": false
}