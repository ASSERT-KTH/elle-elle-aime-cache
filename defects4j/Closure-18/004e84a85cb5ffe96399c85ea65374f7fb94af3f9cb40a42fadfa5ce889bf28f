{
    "generation": "/**\n * Parses the externs and main inputs.\n *\n * @return A synthetic root node whose two children are the externs root\n *     and the main root\n */\nNode parseInputs() {\n    boolean devMode = options.devMode!= DevMode.OFF;\n\n    // If old roots exist (we are parsing a second time), detach each of the\n    // individual file parse trees.\n    if (externsRoot!= null) {\n        externsRoot.detachChildren();\n    }\n    if (jsRoot!= null) {\n        jsRoot.detachChildren();\n    }\n\n    // Parse main JS sources.\n    jsRoot = IR.block();\n    jsRoot.setIsSyntheticBlock(true);\n\n    externsRoot = IR.block();\n    externsRoot.setIsSyntheticBlock(true);\n\n    externAndJsRoot = IR.block(externsRoot, jsRoot);\n    externAndJsRoot.setIsSyntheticBlock(true);\n\n    if (options.tracer.isOn()) {\n        tracker = new PerformanceTracker(jsRoot, options.tracer);\n        addChangeHandler(tracker.getCodeChangeHandler());\n    }\n\n    Tracer tracer = newTracer(\"parseInputs\");\n\n    try {\n        // Parse externs sources.\n        for (CompilerInput input : externs) {\n            Node n = input.getAstRoot(this);\n            if (hasErrors()) {\n                return null;\n            }\n            externsRoot.addChildToBack(n);\n        }\n\n        // Modules inferred in ProcessCommonJS pass.\n        if (options.transformAMDToCJSModules || options.processCommonJSModules) {\n            processAMDAndCommonJSModules();\n        }\n\n        hoistExterns(externsRoot);\n\n        // Check if the sources need to be re-ordered.\n        boolean staleInputs = false;\n        if (options.dependencyOptions.needsManagement() && options.closurePass) {\n            for (CompilerInput input : inputs) {\n                // Forward-declare all the provided types, so that they\n                // are not flagged even if they are dropped from the process.\n                for (String provide : input.getProvides()) {\n                    getTypeRegistry().forwardDeclareType(provide);\n                }\n            }\n\n            try {\n                inputs =\n                        (moduleGraph == null? new JSModuleGraph(modules) : moduleGraph)\n                       .manageDependencies(options.dependencyOptions, inputs);\n                staleInputs = true;\n            } catch (CircularDependencyException e) {\n                report(JSError.make(\n                        JSModule.CIRCULAR_DEPENDENCY_ERROR, e.getMessage()));\n\n                // If in IDE mode, we ignore the error and keep going.\n                if (hasErrors()) {\n                    return null;\n                }\n            } catch (MissingProvideException e) {\n                report(JSError.make(\n                        MISSING_ENTRY_ERROR, e.getMessage()));\n\n                // If in IDE mode, we ignore the error and keep going.\n                if (hasErrors()) {\n                    return null;\n                }\n            }\n        }\n\n        hoistNoCompileFiles();\n\n        if (staleInputs) {\n            repartitionInputs();\n        }\n\n        // Build the AST in the correct order.\n        if (options.dependencyOptions.isDependencySortingEnabled()) {\n            // Create a temporary list to hold the sorted inputs.\n            List<CompilerInput> sortedInputs = new ArrayList<>();\n\n            // Sort the inputs based on their dependencies.\n            sortedInputs.addAll(inputs);\n            Collections.sort(sortedInputs, new InputDependencyComparator());\n\n            // Use the sorted inputs to build the AST.\n            for (CompilerInput input : sortedInputs) {\n                Node n = input.getAstRoot(this);\n                if (n == null) {\n                    continue;\n                }\n\n                if (devMode) {\n                    runSanityCheck();\n                    if (hasErrors()) {\n                        return null;\n                    }\n                }\n\n                if (options.sourceMapOutputPath!= null ||\n                        options.nameReferenceReportPath!= null) {\n\n                    // Annotate the nodes in the tree with information from the\n                    // input file. This information is used to construct the SourceMap.\n                    SourceInformationAnnotator sia =\n                            new SourceInformationAnnotator(\n                                    input.getName(), options.devMode!= DevMode.OFF);\n                    NodeTraversal.traverse(this, n, sia);\n                }\n\n                jsRoot.addChildToBack(n);\n            }\n        } else {\n            // Build the AST in the original order.\n            for (CompilerInput input : inputs) {\n                Node n = input.getAstRoot(this);\n                if (n == null) {\n                    continue;\n                }\n\n                if (devMode) {\n                    runSanityCheck();\n                    if (hasErrors()) {\n                        return null;\n                    }\n                }\n\n                if (options.sourceMapOutputPath!= null ||\n                        options.nameReferenceReportPath!= null) {\n\n                    // Annotate the nodes in the tree with information from the\n                    // input file. This information is used to construct the SourceMap.\n                    SourceInformationAnnotator sia =\n                            new SourceInformationAnnotator(\n                                    input.getName(), options.devMode!= DevMode.OFF);\n                    NodeTraversal.traverse(this, n, sia);\n                }\n\n                jsRoot.addChildToBack(n);\n            }\n        }\n\n        if (hasErrors()) {\n            return null;\n        }\n        return externAndJsRoot;\n    } finally {\n        stopTracer(tracer, \"parseInputs\");\n    }\n}\n\n// Define a comparator to sort inputs based on their dependencies.\nclass InputDependencyComparator implements Comparator<CompilerInput> {\n    @Override\n    public int compare(CompilerInput input1, CompilerInput input2) {\n        // If input1 requires input2, then input1 should come after input2.\n        if (input1.getRequires().contains(input2.getName())) {\n            return 1;\n        }\n        // If input2 requires input1, then input1 should come before input2.\n        else if (input2.getRequires().contains(input1.getName())) {\n            return -1;\n        }\n        // If neither input requires the other, then their order doesn't matter.\n        else {\n            return 0;\n        }\n    }\n}",
    "exact_match": false,
    "ast_match": false,
    "compile": false,
    "test": false
}