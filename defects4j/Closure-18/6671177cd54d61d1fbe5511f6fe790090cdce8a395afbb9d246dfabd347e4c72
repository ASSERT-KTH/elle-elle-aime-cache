{
    "generation": "/**\n * Parses the externs and main inputs.\n *\n * @return A synthetic root node whose two children are the externs root\n *     and the main root\n */\nNode parseInputs() {\n  boolean devMode = options.devMode!= DevMode.OFF;\n\n  // If old roots exist (we are parsing a second time), detach each of the\n  // individual file parse trees.\n  if (externsRoot!= null) {\n    externsRoot.detachChildren();\n  }\n  if (jsRoot!= null) {\n    jsRoot.detachChildren();\n  }\n\n  // Parse main JS sources.\n  jsRoot = IR.block();\n  jsRoot.setIsSyntheticBlock(true);\n\n  externsRoot = IR.block();\n  externsRoot.setIsSyntheticBlock(true);\n\n  externAndJsRoot = IR.block(externsRoot, jsRoot);\n  externAndJsRoot.setIsSyntheticBlock(true);\n\n  if (options.tracer.isOn()) {\n    tracker = new PerformanceTracker(jsRoot, options.tracer);\n    addChangeHandler(tracker.getCodeChangeHandler());\n  }\n\n  Tracer tracer = newTracer(\"parseInputs\");\n\n  try {\n    // Parse externs sources.\n    for (CompilerInput input : externs) {\n      Node n = input.getAstRoot(this);\n      if (hasErrors()) {\n        return null;\n      }\n      externsRoot.addChildToBack(n);\n    }\n\n    // Modules inferred in ProcessCommonJS pass.\n    if (options.transformAMDToCJSModules || options.processCommonJSModules) {\n      processAMDAndCommonJSModules();\n    }\n\n    hoistExterns(externsRoot);\n\n    // Check if the sources need to be re-ordered.\n    boolean staleInputs = false;\n    if (options.dependencyOptions.needsManagement() && options.closurePass) {\n      for (CompilerInput input : inputs) {\n        // Forward-declare all the provided types, so that they\n        // are not flagged even if they are dropped from the process.\n        for (String provide : input.getProvides()) {\n          getTypeRegistry().forwardDeclareType(provide);\n        }\n      }\n\n      try {\n        inputs =\n            (moduleGraph == null? new JSModuleGraph(modules) : moduleGraph)\n           .manageDependencies(options.dependencyOptions, inputs);\n        staleInputs = true;\n      } catch (CircularDependencyException e) {\n        report(JSError.make(\n            JSModule.CIRCULAR_DEPENDENCY_ERROR, e.getMessage()));\n\n        // If in IDE mode, we ignore the error and keep going.\n        if (hasErrors()) {\n          return null;\n        }\n      } catch (MissingProvideException e) {\n        report(JSError.make(\n            MISSING_ENTRY_ERROR, e.getMessage()));\n\n        // If in IDE mode, we ignore the error and keep going.\n        if (hasErrors()) {\n          return null;\n        }\n      }\n\n      if (staleInputs) {\n        // Before repartitioning inputs, we should also reorder the inputs\n        // based on the dependency sorting.\n        if (options.dependencyOptions.dependencySorting) {\n          inputs = reorderInputsBasedOnDependency(inputs);\n        }\n      }\n\n      hoistNoCompileFiles();\n\n      if (staleInputs) {\n        repartitionInputs();\n      }\n    }\n\n    // Build the AST.\n    for (CompilerInput input : inputs) {\n      Node n = input.getAstRoot(this);\n      if (n == null) {\n        continue;\n      }\n\n      if (devMode) {\n        runSanityCheck();\n        if (hasErrors()) {\n          return null;\n        }\n      }\n\n      if (options.sourceMapOutputPath!= null ||\n          options.nameReferenceReportPath!= null) {\n\n        // Annotate the nodes in the tree with information from the\n        // input file. This information is used to construct the SourceMap.\n        SourceInformationAnnotator sia =\n            new SourceInformationAnnotator(\n                input.getName(), options.devMode!= DevMode.OFF);\n        NodeTraversal.traverse(this, n, sia);\n      }\n\n      jsRoot.addChildToBack(n);\n    }\n\n    if (hasErrors()) {\n      return null;\n    }\n    return externAndJsRoot;\n  } finally {\n    stopTracer(tracer, \"parseInputs\");\n  }\n}\n\n// New method to reorder inputs based on dependency sorting.\nprivate List<CompilerInput> reorderInputsBasedOnDependency(List<CompilerInput> inputs) {\n  // Implementation of the reorder logic based on the dependency sorting.\n  // For this example, a simple implementation is provided.\n  List<CompilerInput> orderedInputs = new ArrayList<>();\n  Set<String> visited = new HashSet<>();\n\n  // Perform a depth-first search to order the inputs.\n  for (CompilerInput input : inputs) {\n    if (!visited.contains(input.getName())) {\n      dfs(input, inputs, orderedInputs, visited);\n    }\n  }\n\n  return orderedInputs;\n}\n\n// Helper method for the depth-first search.\nprivate void dfs(CompilerInput input, List<CompilerInput> inputs, List<CompilerInput> orderedInputs, Set<String> visited) {\n  visited.add(input.getName());\n\n  // Visit all the dependencies of the current input.\n  for (String require : input.getRequires()) {\n    for (CompilerInput i : inputs) {\n      if (i.getName().equals(require) &&!visited.contains(i.getName())) {\n        dfs(i, inputs, orderedInputs, visited);\n      }\n    }\n  }\n\n  // Add the current input to the ordered list.\n  orderedInputs.add(input);\n}",
    "exact_match": false,
    "ast_match": false,
    "compile": false,
    "test": false
}