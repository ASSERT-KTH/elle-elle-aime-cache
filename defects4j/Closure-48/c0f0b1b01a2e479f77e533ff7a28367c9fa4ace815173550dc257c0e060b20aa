{
    "generation": "void maybeDeclareQualifiedName(NodeTraversal t, JSDocInfo info,\n    Node n, Node parent, Node rhsValue) {\n  Node ownerNode = n.getFirstChild();\n  String ownerName = ownerNode.getQualifiedName();\n  String qName = n.getQualifiedName();\n  String propName = n.getLastChild().getString();\n  Preconditions.checkArgument(qName != null && ownerName != null);\n\n  // Getting the valueType and handling \"prototype\" case...\n\n  if (valueType == null && \"prototype\".equals(propName)) {\n    // If the property is 'prototype' and we didn't determine a type for it,\n    // we should consider it as a reassignment and ignore it.\n    return;\n  }\n\n  if (valueType == null) {\n    if (parent.isExprResult()) {\n      // Handling expressions...\n    }\n\n    return;\n  }\n\n  // Determining \"inferred\" nature...\n\n  if (\"prototype\".equals(propName)) {\n    // If the property is 'prototype', we should consider it as a this assignment\n    // and check if the type is valid.\n    FunctionType ownerType = JSType.toMaybeFunctionType(getObjectSlot(ownerName));\n    if (ownerType != null) {\n      JSType propType = ownerType.getPropertyType(propName);\n      if (!propType.isUnknownType() && !propType.isSubtype(valueType)) {\n        // If the property type is known and not compatible with the new value type,\n        // we should report a type mismatch error.\n        t.report(JSError.make(\"JSC_INCOMPATIBLE_TYPE\", n), n);\n      }\n    }\n  }\n\n  if (!inferred) {\n    // Handling inferred case...\n  } else if (rhsValue != null && rhsValue.isTrue()) {\n    // Handling boolean true case...\n  }\n}",
    "exact_match": false,
    "ast_match": false,
    "compile": false,
    "test": false
}