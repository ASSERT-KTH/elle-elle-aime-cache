{
    "generation": "    void maybeDeclareQualifiedName(NodeTraversal t, JSDocInfo info,\n        Node n, Node parent, Node rhsValue) {\n      Node ownerNode = n.getFirstChild();\n      String ownerName = ownerNode.getQualifiedName();\n      String qName = n.getQualifiedName();\n      String propName = n.getLastChild().getString();\n      Preconditions.checkArgument(qName != null && ownerName != null);\n\n      // ...\n\n      // Function prototypes are special.\n      // It's a common JS idiom to do:\n      // F.prototype = { ... };\n      // So if F does not have an explicitly declared super type,\n      // allow F.prototype to be redefined arbitrarily.\n      if (\"prototype\".equals(propName)) {\n        Var qVar = scope.getVar(qName);\n        if (qVar != null) {\n          // If the programmer has declared that F inherits from Super,\n          // and they assign F.prototype to an object literal,\n          // then they are responsible for making sure that the object literal's\n          // implicit prototype is set up appropriately. We just obey\n          // the @extends tag.\n          ObjectType qVarType = ObjectType.cast(qVar.getType());\n          if (qVarType != null &&\n              rhsValue != null &&\n              rhsValue.isObjectLit()) {\n            typeRegistry.resetImplicitPrototype(\n                rhsValue.getJSType(), qVarType.getImplicitPrototype());\n          } else if (!qVar.isTypeInferred()) {\n            // If the programmer has declared that F inherits from Super,\n            // and they assign F.prototype to some arbitrary expression,\n            // there's not much we can do. We just ignore the expression.\n            return;\n          } else if (qVar.getScope() == scope) {\n            scope.undeclare(qVar);\n          }\n        }\n      }\n\n      // ...\n\n      // NOTE(nicksantos): Determining whether a property is declared or not\n      // is really really obnoxious.\n      //\n      // ...\n      //\n      // The current algorithm checks if either the declaration has\n      // jsdoc type information, or @const with a known type,\n      // or a function literal with a name we haven't seen before,\n      // or if the property is the prototype and the type has been enforced.\n      boolean inferred = true;\n      if (info != null) {\n        // Determining declaration for #1 + #3 + #4\n        inferred = !(info.hasType()\n            || info.hasEnumParameterType()\n            || (info.isConstant() && valueType != null\n                && !valueType.isUnknownType())\n            || FunctionTypeBuilder.isFunctionTypeDeclaration(info));\n      }\n\n      if (\"prototype\".equals(propName) && !inferred) {\n        // If it's a prototype and it's not inferred, then it's declared.\n        inferred = false;\n      }\n\n      // ...\n    }",
    "exact_match": false,
    "ast_match": false,
    "compile": false,
    "test": false
}