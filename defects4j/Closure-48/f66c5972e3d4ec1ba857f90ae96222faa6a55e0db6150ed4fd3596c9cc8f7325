{
    "generation": "/**\n * Declare the symbol for a qualified name in the global scope.\n *\n * @param info The doc info for this property.\n * @param n A top-level GETPROP node (it should not be contained inside\n *     another GETPROP).\n * @param parent The parent of {@code n}.\n * @param rhsValue The node that {@code n} is being initialized to,\n *     or {@code null} if this is a stub declaration.\n */\nvoid maybeDeclareQualifiedName(NodeTraversal t, JSDocInfo info,\n    Node n, Node parent, Node rhsValue) {\n  Node ownerNode = n.getFirstChild();\n  String ownerName = ownerNode.getQualifiedName();\n  String qName = n.getQualifiedName();\n  String propName = n.getLastChild().getString();\n  Preconditions.checkArgument(qName!= null && ownerName!= null);\n\n  //... (unchanged code)\n\n  if (!inferred) {\n    ObjectType ownerType = getObjectSlot(ownerName);\n    if (ownerType!= null) {\n      // Only declare this as an official property if it has not been\n      // declared yet, or if the new declaration is for a subtype.\n      boolean isExtern = t.getInput()!= null && t.getInput().isExtern();\n      JSType existingType = ownerType.getPropertyType(propName);\n      if ((existingType == null ||\n           existingType.isUnknownType() ||\n           valueType.isSubtype(existingType)) &&\n          ((isExtern &&!ownerType.isNativeObjectType()) ||\n          !ownerType.isInstanceType())) {\n        // If the property is undeclared, inferred, or being reassigned to a subtype, declare it now.\n        ownerType.defineDeclaredProperty(propName, valueType, n);\n      }\n    }\n\n    // If the property is already declared, the error will be\n    // caught when we try to declare it in the current scope.\n    defineSlot(n, parent, valueType, inferred);\n  } else if (rhsValue!= null && rhsValue.isTrue()) {\n    //... (unchanged code)\n  }\n}",
    "exact_match": false,
    "ast_match": false,
    "compile": false,
    "test": false
}