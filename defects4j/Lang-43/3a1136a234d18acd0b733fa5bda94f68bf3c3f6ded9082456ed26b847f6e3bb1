{
    "generation": "    /**\n     * Consume a quoted string, adding it to <code>appendTo</code> if\n     * specified.\n     * \n     * @param pattern pattern to parse\n     * @param pos current parse position\n     * @param appendTo optional StringBuffer to append\n     * @param escapingOn whether to process escaped quotes\n     * @return <code>appendTo</code>\n     */\n    private StringBuffer appendQuotedString(String pattern, ParsePosition pos,\n            StringBuffer appendTo, boolean escapingOn) {\n        int start = pos.getIndex();\n        char[] c = pattern.toCharArray();\n        if (escapingOn && c[start] == QUOTE) {\n            pos.setIndex(pos.getIndex() + 1); // Increment the position.\n            return appendTo == null? null : appendTo.append(QUOTE);\n        }\n        int lastHold = start;\n        for (; pos.getIndex() < pattern.length();) {\n            int i = pos.getIndex();\n            if (escapingOn && pattern.startsWith(ESCAPED_QUOTE, i)) {\n                // Append data prior to next escaped quote, then resume.\n                appendTo = appendData(c, pattern, appendTo, start, pos.getIndex());\n                pos.setIndex(i + ESCAPED_QUOTE.length());\n            } else switch (c[i]) {\n            case QUOTE: // found non-escap'd\n                {\n                    appendTo = (appendTo == null) ?  new StringBuffer(DEFAULT_BUFFER_SIZE)\n                        // Append everything, including starting quote.\n                        : appendTo.append(c, start!= 0? start+1 : 0\n                                // don't cut off quotes after the parameter\n                                // part from the actual result\n                                 ,pos.getIndex() \n                                 ,pattern.length () - 2);\n                         // Cut of the remaining quote!\n                }\n                       pos.setIndex(i); // restore!\n                       continue;\n              }\n            incrementPosition(positions, len, parse, pos):\n        }   // break out! \n\n        char[] finalAppend =pattern.toCharArray( ;\n        assert(finalAppend.length-pattern.length()\n                   == \"Unterminated quoted.equals (\n                                \"Pattern:pattern,\"+Integer.toString(( \n        && \"lastPosition\" =\n        throw\n     }\n }\n",
    "exact_match": false,
    "ast_match": false,
    "compile": false,
    "test": false
}