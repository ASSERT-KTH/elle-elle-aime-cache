{
    "generation": "static Document parseByteData(ByteBuffer byteData, String charsetName, String baseUri, Parser parser) {\n    Document doc = null;\n    String docData;\n\n    if (charsetName == null) { // determine from meta. safe parse as UTF-8\n        // Look for BOM to determine encoding\n        charsetName = detectCharset(byteData);\n        docData = Charset.forName(charsetName).decode(byteData).toString();\n        doc = parser.parseInput(docData, baseUri);\n        Element meta = doc.select(\"meta[http-equiv=content-type], meta[charset]\").first();\n        if (meta != null) { // if meta found, might override BOM detection\n            String foundCharset = getCharsetFromMeta(meta);\n            if (foundCharset != null && !foundCharset.equals(charsetName)) { // need to re-decode\n                charsetName = foundCharset;\n                byteData.rewind();\n                docData = Charset.forName(foundCharset).decode(byteData).toString();\n                doc = null;\n            }\n        }\n    } else { // specified by content type header (or by user on file load)\n        Validate.notEmpty(charsetName, \"Must set charset arg to character set of file to parse. Set to null to attempt to detect from HTML\");\n        docData = Charset.forName(charsetName).decode(byteData).toString();\n    }\n\n    if (doc == null) {\n        doc = parser.parseInput(docData, baseUri);\n        doc.outputSettings().charset(charsetName);\n    }\n    return doc;\n}\n\nprivate static String detectCharset(ByteBuffer byteData) {\n    byte[] bom = new byte[4];\n    byteData.get(bom);\n    if ((bom[0] == (byte) 0xFE && bom[1] == (byte) 0xFF) || (bom[0] == (byte) 0xFF && bom[1] == (byte) 0xFE)) {\n        // UTF-16 BOM detected\n        return bom[0] == (byte) 0xFE ? \"UTF-16BE\" : \"UTF-16LE\";\n    } else if (bom[0] == (byte) 0xEF && bom[1] == (byte) 0xBB && bom[2] == (byte) 0xBF) {\n        // UTF-8 BOM detected\n        byteData.position(3); // skip BOM\n        return \"UTF-8\";\n    } else if ((bom[0] == (byte) 0x00 && bom[1] == (byte) 0x00 && bom[2] == (byte) 0xFE && bom[3] == (byte) 0xFF) ||\n                (bom[0] == (byte) 0xFF && bom[1] == (byte) 0xFE && bom[2] == (byte) 0x00 && bom[3] == (byte) 0x00)) {\n        // UTF-32 BOM detected\n        return bom[2] == (byte) 0xFE ? \"UTF-32BE\" : \"UTF-32LE\";\n    }\n    byteData.position(0); // reset position\n    return defaultCharset;\n}\n\nprivate static String getCharsetFromMeta(Element meta) {\n    String foundCharset = null;\n    if (meta.hasAttr(\"http-equiv\")) {\n        foundCharset = getCharsetFromContentType(meta.attr(\"content\"));\n    }\n    if (foundCharset == null && meta.hasAttr(\"charset\")) {\n        try {\n            if (Charset.isSupported(meta.attr(\"charset\"))) {\n                foundCharset = meta.attr(\"charset\");\n            }\n        } catch (IllegalCharsetNameException e) {\n            foundCharset = null;\n        }\n    }\n    if (foundCharset != null) {\n        foundCharset = foundCharset.trim().replaceAll(\"[\\\"']\", \"\");\n    }\n    return foundCharset;\n}",
    "exact_match": false,
    "ast_match": false,
    "compile": true,
    "test": false
}