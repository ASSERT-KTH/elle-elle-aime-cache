{
    "generation": "public double[] fit(final Gaussian.Parametric params) {\n    // Parameter bounds to ensure sigma stays positive.\n    GoalFunction goal = new GaussianCurveFitter.Problem(params, getObservations());\n    SimpleValueChecker checker = new SimpleValueChecker(1e-6, 1e-6, 30);\n\n    PointVectorValuePair optimum = null;\n    try {\n        double[] startPoint = this.getParameters();\n        boolean[] fix = new boolean[startPoint.length];\n        double[] weight = new double[startPoint.length];\n        double[] min = new double[startPoint.length];\n        double[] max = new double[startPoint.length];\n\n        for (int i = 0; i < startPoint.length; ++i) {\n            fix[i] = false;\n            weight[i] = 1.0;\n            min[i] = -Double.MAX_VALUE;\n            max[i] = Double.MAX_VALUE;\n        }\n\n        // Ensuring sigma is strictly positive\n        min[2] = 1e-6;\n\n        PointVectorValuePair opt = optimizer.optimize(new MaxEval(Integer.MAX_VALUE),\n                goal, goal, GoalType.MINIMIZE, new InitialGuess(startPoint), SimpleBounds.unbounded(startPoint.length));\n\n        optimum = optimizer.optimize(new MaxEval(Integer.MAX_VALUE),\n                new MaxIter(1000),\n                goal, goal, GoalType.MINIMIZE,\n                new InitialGuess(startPoint),\n                new SimpleBounds(min, max),\n                fix, weight, checker);\n\n    } catch (Exception e) {\n        e.printStackTrace();\n    }\n\n    if (optimum == null) {\n        throw new MathIllegalArgumentException(LocalizedFormats.NO_DATA);\n    }\n\n    return optimum.getPoint();\n}",
    "exact_match": false,
    "ast_match": false,
    "compile": false,
    "test": false
}