{
    "generation": "/**\n * Fits a Gaussian function to the observed points.\n *\n * @return the parameters of the Gaussian function that best fits the\n * observed points (in the same order as above).\n */\npublic double[] fit() {\n    final double[] guess = (new ParameterGuesser(getObservations())).guess();\n    \n    // Transform the parameters to ensure positivity where needed\n    final double amp = guess[0];\n    final double mean = guess[1];\n    final double sigma = Math.log(guess[2]); // Store the log of sigma\n    \n    final double[] transformedGuess = {amp, mean, sigma};\n    \n    final ParametricRealFunction transformedFunction = new ParametricRealFunction() {\n        public double value(double x, double[] parameters) {\n            double amp = parameters[0];\n            double mean = parameters[1];\n            double sigma = Math.exp(parameters[2]); // Exponentiate to get positive sigma\n            return amp * Math.exp(-Math.pow(x - mean, 2) / (2 * sigma * sigma));\n        }\n        \n        public double[] gradient(double x, double[] parameters) {\n            double amp = parameters[0];\n            double mean = parameters[1];\n            double logSigma = parameters[2];\n            double sigma = Math.exp(logSigma);\n            double dx = x - mean;\n            double exponent = -dx * dx / (2 * sigma * sigma);\n            double gaussian = amp * Math.exp(exponent);\n            return new double[]{\n                gaussian / amp, // d/damp\n                gaussian * dx / (sigma * sigma), // d/dmean\n                gaussian * dx * dx / (sigma * sigma * sigma) // d/dsigma\n            };\n        }\n    };\n    \n    final double[] transformedFit = fit(transformedFunction, transformedGuess);\n    \n    // Transform back to original parameters\n    return new double[]{transformedFit[0], transformedFit[1], Math.exp(transformedFit[2])};\n}",
    "exact_match": false,
    "ast_match": false,
    "compile": false,
    "test": false
}