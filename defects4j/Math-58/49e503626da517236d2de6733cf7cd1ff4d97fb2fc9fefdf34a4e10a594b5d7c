{
    "generation": "    /**\n     * Fits a Gaussian function to the observed points.\n     *\n     * @return the parameters of the Gaussian function that best fits the\n     * observed points (in the same order as above).\n     */\n    public double[] fit() {\n        final double[] guess = (new ParameterGuesser(getObservations())).guess();\n        double[] parameters = fit(new Gaussian.Parametric(), guess);\n        if (Double.isNaN(parameters[0]) || Double.isNaN(parameters[1]) || Double.isNaN(parameters[2])) {\n            // try to fit a gaussian with reversed x values\n            final WeightedObservedPoint[] points = getObservations();\n            final WeightedObservedPoint[] revPoints = new WeightedObservedPoint[points.length];\n            for (int i = 0; i < points.length; ++i) {\n                revPoints[i] = new WeightedObservedPoint(points[i].getWeight(),\n                        -points[i].getX(), points[i].getY());\n            }\n            final ParameterGuesser guesser = new ParameterGuesser(revPoints);\n            final double[] revParams = fit(new Gaussian.Parametric(), guesser.guess());\n\n            // check if the reversed model is valid\n            double[] modPoints = new double[points.length];\n            for (int i = 0; i < points.length; i++) {\n                modPoints[i] = new Gaussian.Parametric().value(-points[i].getX(), revParams);\n            }\n            double[] modPointsOriginal = new double[points.length];\n            for (int i = 0; i < points.length; i++) {\n                modPointsOriginal[i] = new Gaussian.Parametric().value(points[i].getX(), parameters);\n            }\n            \n            double errorOrig = 0;\n            for (int i = 0; i < points.length; i++) {\n                errorOrig += Math.abs(points[i].getY() - modPointsOriginal[i]);\n            }\n            double errorRev = 0;\n            for (int i = 0; i < points.length; i++) {\n                errorRev += Math.abs(points[i].getY() - modPoints[i]);\n            }\n\n            if (!Double.isNaN(revParams[0]) && !Double.isNaN(revParams[1]) && !Double.isNaN(revParams[2]) && (errorRev < errorOrig)) {\n                // the reversed model is better than the original one\n                // return the reversed parameters after correcting the norm and mean\n                parameters = new double[] {revParams[0], -revParams[1], revParams[2]};\n            }\n\n        }\n        return parameters;\n    }\n",
    "exact_match": false,
    "ast_match": false,
    "compile": true,
    "test": false
}