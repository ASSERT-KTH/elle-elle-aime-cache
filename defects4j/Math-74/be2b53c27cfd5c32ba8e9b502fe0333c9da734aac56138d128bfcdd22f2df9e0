{
    "generation": "/** {@inheritDoc} */\n@Override\npublic double integrate(final FirstOrderDifferentialEquations equations,\n                        final double t0, final double[] y0,\n                        final double t, final double[] y)\n    throws DerivativeException, IntegratorException {\n\n    sanityChecks(equations, t0, y0, t, y);\n    setEquations(equations);\n    resetEvaluations();\n    final boolean forward = t > t0;\n\n    // Initialize working arrays\n    if (y != y0) {\n        System.arraycopy(y0, 0, y, 0, y0.length);\n    }\n    double[] yDot = new double[y0.length];\n    double[] yTmp = new double[y0.length];\n    double[][] history = new double[getOrder() + 1][y0.length];\n\n    // Set up an interpolator\n    AbstractStepInterpolator interpolator = new DummyStepInterpolator(y, forward);\n    interpolator.storeTime(t0);\n\n    // Set up integration control objects\n    stepStart = t0;\n    stepSize = Math.abs(t - t0) / 100.0; // Initial step size\n    for (StepHandler handler : stepHandlers) {\n        handler.reset();\n    }\n    CombinedEventsManager manager = addEndTimeChecker(t0, t, eventsHandlersManager);\n\n    // Main integration loop\n    boolean lastStep = false;\n    while (!lastStep) {\n\n        // Predict step\n        computeDerivatives(stepStart, y, yDot);\n        for (int j = 0; j < y0.length; j++) {\n            yTmp[j] = y[j] + stepSize * yDot[j];\n        }\n\n        // Correct step (Adams-Moulton corrector)\n        for (int iteration = 0; iteration < 3; iteration++) {\n            computeDerivatives(stepStart + stepSize, yTmp, yDot);\n            for (int j = 0; j < y0.length; j++) {\n                yTmp[j] = y[j] + 0.5 * stepSize * (yDot[j] + history[0][j]);\n            }\n        }\n\n        // Accept the step\n        stepStart += stepSize;\n        System.arraycopy(yTmp, 0, y, 0, y0.length);\n        \n        // Shift history\n        for (int i = getOrder(); i > 0; i--) {\n            System.arraycopy(history[i-1], 0, history[i], 0, y0.length);\n        }\n        System.arraycopy(yDot, 0, history[0], 0, y0.length);\n\n        // Handle events and check for last step\n        interpolator.storeTime(stepStart);\n        manager.stepAccepted(stepStart, y);\n        lastStep = manager.stop();\n        for (StepHandler handler : stepHandlers) {\n            handler.handleStep(interpolator, lastStep);\n        }\n\n        if (!lastStep) {\n            // Adjust step size for next step\n            stepSize = Math.min(stepSize * 1.2, Math.abs(t - stepStart));\n            if (forward && (stepStart + stepSize > t)) {\n                stepSize = t - stepStart;\n                lastStep = true;\n            } else if (!forward && (stepStart + stepSize < t)) {\n                stepSize = t - stepStart;\n                lastStep = true;\n            }\n            stepSize = Math.copySign(stepSize, t - t0);\n        }\n    }\n\n    resetInternalState();\n    return stepStart;\n}",
    "exact_match": false,
    "ast_match": false,
    "compile": true,
    "test": false
}