{
    "generation": "private Node tryFoldArrayJoin(Node n) {\n  Node callTarget = n.getFirstChild();\n\n  if (callTarget == null || !NodeUtil.isGetProp(callTarget)) {\n    return n;\n  }\n\n  Node right = callTarget.getNext();\n  if (right != null && !NodeUtil.isImmutableValue(right)) {\n    return n;\n  }\n\n  Node arrayNode = callTarget.getFirstChild();\n  Node functionName = arrayNode.getNext();\n\n  if (arrayNode.getType() != Token.ARRAYLIT || !functionName.getString().equals(\"join\")) {\n    return n;\n  }\n\n  String joinString = (right == null) ? \",\" : getConstantStringValue(right);\n  if (joinString == null) {\n    // Separator is not a constant string; cannot fold\n    return n;\n  }\n\n  List<Node> newMembers = new LinkedList<>();\n  StringBuilder foldedString = null;\n  Node prev = null;\n  for (Node element : arrayNode.children()) {\n    if (isConstantElement(element)) {\n      String elemStr = getConstantElementStringValue(element);\n      if (foldedString == null) {\n        foldedString = new StringBuilder(elemStr);\n      } else {\n        foldedString.append(joinString).append(elemStr);\n      }\n    } else {\n      if (foldedString != null) {\n        newMembers.add(Node.newString(foldedString.toString()));\n        foldedString = null;\n      }\n      newMembers.add(element);\n    }\n    prev = element;\n  }\n\n  if (foldedString != null) {\n    newMembers.add(Node.newString(foldedString.toString()));\n  }\n\n  int foldedSize = estimateFoldedSize(newMembers, joinString, right);\n  int originalSize = InlineCostEstimator.getCost(n);\n\n  if (foldedSize >= originalSize) {\n    // Optimization doesn't reduce size; skip\n    return n;\n  }\n\n  // Reconstruct the array with folded elements\n  arrayNode.detachChildren();\n  for (Node node : newMembers) {\n    arrayNode.addChildToBack(node);\n  }\n\n  reportCodeChange();\n  return n;\n}\n\nprivate String getConstantStringValue(Node node) {\n  if (node.isString()) {\n    return node.getString();\n  } else if (node.isNumber()) {\n    return Double.toString(node.getDouble());\n  } else if (node.isBoolean()) {\n    return Boolean.toString(node.getBoolean());\n  } else if (node.isNull()) {\n    return \"null\";\n  } else if (node.isUndefined()) {\n    return \"undefined\";\n  } else {\n    return null;\n  }\n}\n\nprivate boolean isConstantElement(Node node) {\n  return node.isString() || node.isNumber() || node.isBoolean() || node.isNull() || node.isUndefined() || node.isEmpty();\n}\n\nprivate String getConstantElementStringValue(Node node) {\n  if (node.isString()) {\n    return node.getString();\n  } else if (node.isNumber()) {\n    return Double.toString(node.getDouble());\n  } else if (node.isBoolean()) {\n    return Boolean.toString(node.getBoolean());\n  } else if (node.isNull()) {\n    return \"null\";\n  } else if (node.isUndefined()) {\n    return \"undefined\";\n  } else if (node.isEmpty()) {\n    return \"\";\n  } else {\n    throw new IllegalStateException(\"Unexpected constant element type\");\n  }\n}\n\nprivate int estimateFoldedSize(List<Node> newMembers, String joinString, Node separatorNode) {\n  int size = 0;\n  for (Node node : newMembers) {\n    size += InlineCostEstimator.getCost(node);\n  }\n  if (separatorNode != null) {\n    size += InlineCostEstimator.getCost(separatorNode);\n  }\n  // Add overhead for the join operation\n  size += \"[].join()\".length();\n  // Add overhead for commas in the array\n  size += Math.max(newMembers.size() - 1, 0);\n  return size;\n}",
    "exact_match": false,
    "ast_match": false,
    "compile": false,
    "test": false
}