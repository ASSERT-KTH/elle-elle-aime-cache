{
    "generation": "void tryMinimizeExits(Node n, int exitType, String labelName) {\n    // Just an 'exit'.\n    if (matchingExitNode(n, exitType, labelName)) {\n        NodeUtil.removeChild(n.getParent(), n);\n        compiler.reportCodeChange();\n        return;\n    }\n\n    // Just an 'if'.\n    if (n.isIf()) {\n        Node ifBlock = n.getFirstChild().getNext();\n        tryMinimizeExits(ifBlock, exitType, labelName);\n        Node elseBlock = ifBlock.getNext();\n        if (elseBlock != null) {\n            tryMinimizeExits(elseBlock, exitType, labelName);\n        }\n        return;\n    }\n\n    // Just a 'try/catch/finally'.\n    if (n.isTry()) {\n        Node tryBlock = n.getFirstChild();\n        tryMinimizeExits(tryBlock, exitType, labelName);\n        Node allCatchNodes = NodeUtil.getCatchBlock(n);\n        if (NodeUtil.hasCatchHandler(allCatchNodes)) {\n            Preconditions.checkState(allCatchNodes.hasOneChild());\n            Node catchNode = allCatchNodes.getFirstChild();\n            Node catchCodeBlock = catchNode.getLastChild();\n            tryMinimizeExits(catchCodeBlock, exitType, labelName);\n        }\n        // Modified: Don't minimize exits in finally block\n        if (NodeUtil.hasFinally(n)) {\n            Node finallyBlock = n.getLastChild();\n            // Remove the call to tryMinimizeExits for finally block\n            // tryMinimizeExits(finallyBlock, exitType, labelName);\n        }\n    }\n\n    // Just a 'label'.\n    if (n.isLabel()) {\n        Node labelBlock = n.getLastChild();\n        tryMinimizeExits(labelBlock, exitType, labelName);\n    }\n\n    // TODO(johnlenz): The last case of SWITCH statement?\n\n    // The rest assumes a block with at least one child, bail on anything else.\n    if (!n.isBlock() || n.getLastChild() == null) {\n        return;\n    }\n\n    // Modified: Handle multiple if-exits in a single pass\n    List<Node> ifNodes = new ArrayList<>();\n    for (Node c = n.getFirstChild(); c != null; c = c.getNext()) {\n        if (c.isIf()) {\n            ifNodes.add(c);\n        }\n    }\n\n    if (!ifNodes.isEmpty()) {\n        Node lastIf = ifNodes.get(ifNodes.size() - 1);\n        Node current = lastIf;\n\n        for (int i = ifNodes.size() - 1; i >= 0; i--) {\n            Node ifNode = ifNodes.get(i);\n            Node trueBlock = ifNode.getFirstChild().getNext();\n            Node falseBlock = trueBlock.getNext();\n\n            if (falseBlock == null) {\n                falseBlock = new Node(Token.BLOCK);\n                ifNode.addChildAfter(falseBlock, trueBlock);\n            }\n\n            if (current != ifNode) {\n                NodeUtil.removeChild(n, current);\n                falseBlock.addChildrenToFront(current);\n                compiler.reportCodeChange();\n            }\n\n            tryMinimizeIfBlockExits(trueBlock, falseBlock, ifNode, exitType, labelName);\n            current = ifNode;\n        }\n\n        // Handle the remaining statements\n        Node remaining = lastIf.getNext();\n        if (remaining != null) {\n            NodeUtil.removeChild(n, remaining);\n            Node falseBlock = lastIf.getFirstChild().getNext().getNext();\n            falseBlock.addChildrenToFront(remaining);\n            compiler.reportCodeChange();\n        }\n    }\n\n    // Now try to minimize the exits of the last child, if it is removed\n    // look at what has become the last child.\n    for (Node c = n.getLastChild(); c != null; c = n.getLastChild()) {\n        tryMinimizeExits(c, exitType, labelName);\n        // If the node is still the last child, we are done.\n        if (c == n.getLastChild()) {\n            break;\n        }\n    }\n}",
    "exact_match": false,
    "ast_match": false,
    "compile": false,
    "test": false
}