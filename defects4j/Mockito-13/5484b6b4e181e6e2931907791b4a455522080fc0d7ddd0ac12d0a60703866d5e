{
    "generation": "public Object handle(Invocation invocation) throws Throwable {\n    if (invocationContainerImpl.hasAnswersForStubbing()) {\n        // stubbing voids with stubVoid() or doAnswer() style\n        InvocationMatcher invocationMatcher = matchersBinder.bindMatchers(mockingProgress\n                        .getArgumentMatcherStorage(), invocation);\n        invocationContainerImpl.setMethodForStubbing(invocationMatcher);\n        return null;\n    }\n    \n    VerificationMode verificationMode = mockingProgress.pullVerificationMode();\n    \n    if (verificationMode != null) {\n        // We need to check if verification was started on the correct mock\n        // - see VerifyingWithAnExtraCallToADifferentMockTest (bug 138)\n        if (verificationMode instanceof MockAwareVerificationMode) {\n            MockAwareVerificationMode mockAwareVerificationMode = (MockAwareVerificationMode) verificationMode;\n            Object mock = mockAwareVerificationMode.getMock();\n            if (mock == invocation.getMock()) {\n                InvocationMatcher invocationMatcher = matchersBinder.bindMatchers(mockingProgress.getArgumentMatcherStorage(), invocation);\n                VerificationDataImpl data = new VerificationDataImpl(invocationContainerImpl, invocationMatcher);\n                verificationMode.verify(data);\n                return null;\n            } else {\n                // Re-add the verification mode if it's for a different mock\n                mockingProgress.pushVerificationMode(verificationMode);\n                // Continue to handle the invocation as a normal method call\n            }\n        }\n    }\n    \n    InvocationMatcher invocationMatcher = matchersBinder.bindMatchers(mockingProgress.getArgumentMatcherStorage(), invocation);\n    mockingProgress.validateState();\n    \n    invocationContainerImpl.setInvocationForPotentialStubbing(invocationMatcher);\n    OngoingStubbingImpl<T> ongoingStubbing = new OngoingStubbingImpl<>(invocationContainerImpl);\n    mockingProgress.reportOngoingStubbing(ongoingStubbing);\n    \n    StubbedInvocationMatcher stubbedInvocation = invocationContainerImpl.findAnswerFor(invocation);\n    \n    if (stubbedInvocation != null) {\n        stubbedInvocation.captureArgumentsFrom(invocation);\n        return stubbedInvocation.answer(invocation);\n    } else {\n        Object ret = mockSettings.getDefaultAnswer().answer(invocation);\n        \n        // Redo setting invocation for potential stubbing in case of partial\n        // mocks / spies.\n        // Without it, the real method inside 'when' might have delegated\n        // to other self method and overwrite the intended stubbed method\n        // with a different one. The reset is required to avoid runtime exception that validates return type with stubbed method signature.\n        invocationContainerImpl.resetInvocationForPotentialStubbing(invocationMatcher);\n        return ret;\n    }\n}",
    "exact_match": false,
    "ast_match": false,
    "compile": false,
    "test": false
}