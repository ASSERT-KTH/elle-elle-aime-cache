{
    "generation": "/** {@inheritDoc} */\n@Override\nprotected UnivariatePointValuePair doOptimize() {\n    final boolean isMinim = getGoalType() == GoalType.MINIMIZE;\n    double lo = getMin();\n    double mid = getStartValue();\n    double hi = getMax();\n\n    // Ensure lo < mid < hi for algorithm to work\n    if (lo > mid) {\n        double temp = lo;\n        lo = mid;\n        mid = temp;\n    }\n    if (mid > hi) {\n        double temp = mid;\n        mid = hi;\n        hi = temp;\n    }\n    if (lo > mid) {\n        double temp = lo;\n        lo = mid;\n        mid = temp;\n    }\n\n    // Optional additional convergence criteria.\n    final ConvergenceChecker<UnivariatePointValuePair> checker = getConvergenceChecker();\n\n    double a = lo;\n    double b = hi;\n\n    double x = mid;\n    double w = x;\n    double v = w;\n    double fx = computeObjectiveValue(x);\n    double fw = fx;\n    double fv = fw;\n    double bestX = x;\n    double bestFx = fx;\n    boolean foundBest = true;\n\n    UnivariatePointValuePair previous = null;\n    UnivariatePointValuePair current = new UnivariatePointValuePair(x, isMinim ? fx : -fx);\n\n    int iter = 0;\n    while (true) {\n        final double m = 0.5 * (a + b);\n        final double tol1 = relativeThreshold * FastMath.abs(x) + absoluteThreshold;\n        final double tol2 = 2 * tol1;\n\n        if (FastMath.abs(x - m) <= tol2 - 0.5 * (b - a)) {\n            break; // Default termination (Brent's criterion).\n        }\n\n        double p = 0;\n        double q = 0;\n\n        if (FastMath.abs(v - w) > tol1) {\n            q = (x - v) * (fx - fw);\n            p = (x - w) * (fx - fv);\n            q = q - p;\n            p = 2 * (p - q);\n        }\n\n        if (p > 0) {\n            q = -q;\n        } else {\n            p = -p;\n        }\n\n        double u;\n\n        if (FastMath.abs(p) >= tol1 && p <= q * (a - x) && p >= q * (b - x)) {\n            u = x + p / q;\n        } else {\n            if (x < m) {\n                u = x + GOLDEN_SECTION * (b - x);\n            } else {\n                u = x - GOLDEN_SECTION * (x - a);\n            }\n        }\n\n        u = clip(u, a, b);\n\n        if (u - x < tol2 && u - x > -tol2) {\n            if (x > m) {\n                u = x - tol1;\n            } else {\n                u = x + tol1;\n            }\n        }\n\n        final double fu = computeObjectiveValue(u);\n\n        if (fu <= fx) {\n            a = u >= x ? x : u;\n            b = u >= x ? u : x;\n\n            foundBest = false;\n        } else {\n            if (u < x) {\n                a = u;\n            } else {\n                b = u;\n            }\n\n            if (fu <= fw || w == x) {\n                v = w;\n                w = u;\n                fv = fw;\n                fw = fu;\n            } else if (fu <= fv || v == x || v == w) {\n                v = u;\n                fv = fu;\n            }\n\n            if (foundBest) {\n                bestX = x;\n                bestFx = fx;\n            }\n        }\n\n        x = u;\n        fx = fu;\n\n        final UnivariatePointValuePair previousCandidate = current;\n        current = new UnivariatePointValuePair(u, isMinim ? fu : -fu);\n\n        if (checker != null) {\n            if (checker.converged(iter, previousCandidate, current)) {\n                return new UnivariatePointValuePair(bestX, isMinim ? bestFx : -bestFx);\n            }\n        }\n\n        ++iter;\n    }\n\n    return new UnivariatePointValuePair(bestX, isMinim ? bestFx : -bestFx);\n}",
    "exact_match": false,
    "ast_match": false,
    "compile": false,
    "test": false
}