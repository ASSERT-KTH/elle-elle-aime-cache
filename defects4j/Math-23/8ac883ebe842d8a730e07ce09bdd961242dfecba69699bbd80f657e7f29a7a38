{
    "generation": "@Override\nprotected UnivariatePointValuePair doOptimize() {\n    final boolean isMinim = getGoalType() == GoalType.MINIMIZE;\n    final double lo = getMin();\n    final double mid = getStartValue();\n    final double hi = getMax();\n\n    // Optional additional convergence criteria.\n    final ConvergenceChecker<UnivariatePointValuePair> checker = getConvergenceChecker();\n\n    double a;\n    double b;\n    if (lo < hi) {\n        a = lo;\n        b = hi;\n    } else {\n        a = hi;\n        b = lo;\n    }\n\n    double x = mid;\n    double v = x;\n    double w = x;\n    double d = 0;\n    double e = 0;\n    double fx = computeObjectiveValue(x);\n    if (!isMinim) {\n        fx = -fx;\n    }\n    double fv = fx;\n    double fw = fx;\n\n    // Best point encountered so far (which is the initial guess).\n    UnivariatePointValuePair best = new UnivariatePointValuePair(x, isMinim ? fx : -fx);\n    UnivariatePointValuePair current = best;\n    UnivariatePointValuePair previous = null;\n\n    int iter = 0;\n    while (true) {\n        // ... the rest of the function body ...\n\n        // User-defined convergence checker.\n        previous = current;\n        current = new UnivariatePointValuePair(u, isMinim ? fu : -fu);\n\n        // Store the best point.\n        if (isMinim) {\n            best = fu < best.getValue() ? current : best;\n        } else {\n            best = fu > best.getValue() ? current : best;\n        }\n\n        // ... the rest of the function body ...\n    }\n    return best;\n}",
    "exact_match": false,
    "ast_match": false,
    "compile": false,
    "test": false
}