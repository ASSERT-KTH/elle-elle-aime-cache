{
    "generation": "\n/** {@inheritDoc} */\n\n@Override\n\nprotected UnivariatePointValuePair doOptimize() {\n\nfinal boolean isMinim = getGoalType() == GoalType.MINIMIZE;\n\nfinal double lo = getMin();\n\nfinal double mid = getStartValue();\n\nfinal double hi = getMax();\n\n// Optional additional convergence criteria.\n\nfinal ConvergenceChecker<UnivariatePointValuePair> checker\n\n= getConvergenceChecker();\n\ndouble a;\n\ndouble b;\n\nif (lo < hi) {\n\na = lo;\n\nb = hi;\n\n} else {\n\na = hi;\n\nb = lo;\n\n}\n\ndouble x = mid;\n\ndouble v = x;\n\ndouble w = x;\n\ndouble d = 0;\n\ndouble e = 0;\n\ndouble fx = computeObjectiveValue(x);\n\nif (!isMinim) {\n\nfx = -fx;\n\n}\n\ndouble fv = fx;\n\ndouble fw = fx;\n\n// Evaluate function at bounds\n\ndouble fa = computeObjectiveValue(a);\n\nif (!isMinim) {\n\nfa = -fa;\n\n}\n\ndouble fb = computeObjectiveValue(b);\n\nif (!isMinim) {\n\nfb = -fb;\n\n}\n\n// Check if x is already the best within tolerances\n\nfinal double tol1 = relativeThreshold * FastMath.abs(x) + absoluteThreshold;\n\nif (isMinim ? (fx <= fa + tol1 && fx <= fb + tol1)\n\n: (fx >= fa - tol1 && fx >= fb - tol1)) {\n\nreturn new UnivariatePointValuePair(x, isMinim ? fx : -fx);\n\n}\n\nUnivariatePointValuePair previous = null;\n\nUnivariatePointValuePair current\n\n= new UnivariatePointValuePair(x, isMinim ? fx : -fx);\n\n// Best point encountered so far (which is the initial guess).\n\nint iter = 0;\n\nwhile (true) {\n\nfinal double m = 0.5 * (a + b);\n\nfinal double tol2 = 2 * tol1;\n\n// Default stopping criterion.\n\nfinal boolean stop = FastMath.abs(x - m) <= tol2 - 0.5 * (b - a);\n\nif (!stop) {\n\ndouble p = 0;\n\ndouble q = 0;\n\ndouble r = 0;\n\ndouble u = 0;\n\nif (FastMath.abs(e) > tol1) { // Fit parabola.\n\nr = (x - w) * (fx - fv);\n\nq = (x - v) * (fx - fw);\n\np = (x - v) * q - (x - w) * r;\n\nq = 2 * (q - r);\n\nif (q > 0) {\n\np = -p;\n\n} else {\n\nq = -q;\n\n}\n\nr = e;\n\ne = d;\n\nif (p > q * (a - x) && p < q * (b - x) && FastMath.abs(p) < FastMath.abs(0.5 * q * r)) {\n\n// Parabolic interpolation step.\n\nd = p / q;\n\nu = x + d;\n\n// f must not be evaluated too close to a or b.\n\nif (u - a < tol2 || b - u < tol2) {\n\nif (x <= m) {\n\nd = tol1;\n\n} else {\n\nd = -tol1;\n\n}\n\n}\n\n} else {\n\n// Golden section step.\n\nif (x < m) {\n\ne = b - x;\n\n} else {\n\ne = a - x;\n\n}\n\nd = GOLDEN_SECTION * e;\n\n}\n\n} else {\n\n// Golden section step.\n\nif (x < m) {\n\ne = b - x;\n\n} else {\n\ne = a - x;\n\n}\n\nd = GOLDEN_SECTION * e;\n\n}\n\n// Update by at least \"tol1\".\n\nif (FastMath.abs(d) < tol1) {\n\nif (d >= 0) {\n\nu = x + tol1;\n\n} else {\n\nu = x - tol1;\n\n}\n\n} else {\n\nu = x + d;\n\n}\n\ndouble fu = computeObjectiveValue(u);\n\nif (!isMinim) {\n\nfu = -fu;\n\n}\n\n// User-defined convergence checker.\n\nprevious = current;\n\ncurrent = new UnivariatePointValuePair(u, isMinim ? fu : -fu);\n\nif (checker != null) {\n\nif (checker.converged(iter, previous, current)) {\n\nreturn best(current, previous, isMinim);\n\n}\n\n}\n\n// Update a, b, v, w and x.\n\nif (fu <= fx) {\n\nif (u < x) {\n\nb = x;\n\n} else {\n\na = x;\n\n}\n\nv = w;\n\nfv = fw;\n\nw = x;\n\nfw = fx;\n\nx = u;\n\nfx = fu;\n\n} else {\n\nif (u < x) {\n\na = u;\n\n} else {\n\nb = u;\n\n}\n\nif (fu <= fw || Precision.equals(w, x)) {\n\nv = w;\n\nfv = fw;\n\nw = u;\n\nfw = fu;\n\n} else if (fu <= fv || Precision.equals(v, x) || Precision.equals(v, w)) {\n\nv = u;\n\nfv = fu;\n\n}\n\n}\n\n} else { // Default termination (Brent's criterion).\n\nreturn best(current, previous, isMinim);\n\n}\n\n++iter;\n\n}\n\n}\n",
    "exact_match": false,
    "ast_match": false,
    "compile": true,
    "test": false
}