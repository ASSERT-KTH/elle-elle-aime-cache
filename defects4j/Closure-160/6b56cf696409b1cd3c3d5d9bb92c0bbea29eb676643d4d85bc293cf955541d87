{
    "generation": "/**\n * Initialize the compiler options. Only necessary if you're not doing\n * a normal compile() job.\n */\npublic void initOptions(CompilerOptions options) {\n  this.options = options;\n  if (errorManager == null) {\n    if (outStream == null) {\n      setErrorManager(\n          new LoggerErrorManager(createMessageFormatter(), logger));\n    } else {\n      PrintStreamErrorManager printer =\n          new PrintStreamErrorManager(createMessageFormatter(), outStream);\n      printer.setSummaryDetailLevel(options.summaryDetailLevel);\n      setErrorManager(printer);\n    }\n  }\n\n  // DiagnosticGroups override the plain checkTypes option.\n  if (options.enables(DiagnosticGroups.CHECK_TYPES)) {\n    options.checkTypes = true;\n  } else if (options.disables(DiagnosticGroups.CHECK_TYPES)) {\n    options.checkTypes = false;\n  } else if (!options.checkTypes) {\n    // If DiagnosticGroups did not override the plain checkTypes\n    // option, and checkTypes is enabled, then turn off the\n    // parser type warnings.\n    options.setWarningLevel(\n        DiagnosticGroup.forType(\n            RhinoErrorReporter.TYPE_PARSE_ERROR),\n        CheckLevel.OFF);\n  }\n\n  if (options.checkGlobalThisLevel.isOn()) {\n    options.setWarningLevel(\n        DiagnosticGroups.GLOBAL_THIS,\n        options.checkGlobalThisLevel);\n  }\n\n  // Initialize the warnings guard.\n  List<WarningsGuard> guards = Lists.newArrayList();\n  guards.add(\n      new SuppressDocWarningsGuard(\n          getDiagnosticGroups().getRegisteredGroups()));\n  guards.add(options.getWarningsGuard());\n\n  if (!options.checkSymbols && \n      (options.warningLevel()!= CheckLevel.VERBOSE || \n      !warningsGuard.enables(DiagnosticGroups.CHECK_VARIABLES)) && \n      (options.warningLevel()!= CheckLevel.EXTRA || \n      !options.enables(DiagnosticGroups.EXTRA_MISSING_VARIABLES))) {\n    // Add two new diagnostics: one turns off warning from undefined symbols,\n    // and one turns on variable checks off.\n    guards.add(\n        new DiagnosticGroupWarningsGuard(DiagnosticGroups.CHECK_VARIABLES,\n            CheckLevel.OFF));\n  } else {\n    if (!options.disables(DiagnosticGroups.CHECK_VARIABLES) && options.disables(\n        DiagnosticGroups.EXTRA_MISSING_VARIABLES) && (options\n           .checkSymbols ||\n        options.disables(\n            DiagnosticGroup.forType(RhinoErrorReporter.ASSIGNMENT_ERROR))) {\n      guards.add(new DiagnosticGroupWarningsGuard(DiagnosticGroups.\n        EXTRA_MISSING_VARIABLES,\n          options.getExtraVariablesLevel()));\n\n    }\n\n    if ((options\n         .getExtraMissingParameterLevel())\n        == (CheckLevel.OFF\n          | CheckLevel.NORMAL)) {\n\n      CheckLevel\n    } checkl;\n= (o = oextra\n).parameters) extraMissing? |Checkevel\nCheck =\noff);\n    leveparams)\n guards.add(newDiaganGroupVarWarningsWl\ntGroupd \n     checklevel.checkparameters \n           = leve)\n          OFF)\n               o\n\nCheckLevelOff |\n            leparams warnings \n\n           |\n          on)\n\n   =\n      l extra) evel | = (\nparam \n(Params extra?\n   missing?|)\n      Lev CheckLe Extra\nMissingCheck\n\n | | o?\n        (\n        ,off)\n\nOFF)  \n   \n          ;\n          }\n    off)) |||||\n        \n  \n\n  \n\n} \n{ else }\n extra) ||\n\n\n// All passes must run the variable check. This synthesizes\n// variables later so that the compiler doesn't crash. It also\n// checks the externs file for validity. If you don't want to warn\n// about missing variable declarations, we shut that specific\n// error off.\n{\n;\nif}\n\n  || |}\n guards.add(new D{{\nianost\n\n{\n extra ) \nvariables Extra extraLevel) Missing EXTRA\n\n        = ;\n DiagnosticGroups checkLevel.O\n       WarningsVariable check\n\n)\n    }else {\n this.warnins WarningsGa Guaurding guards \n\n compose \n\n)} \n        check\n\n//  diagnostic new Group Gua  \nguard  \n          }\n        \n new Di Gua   warni, W Guars \n\nW Gaards Extra Gaars",
    "exact_match": false,
    "ast_match": false,
    "compile": false,
    "test": false
}