{
    "generation": "/**\n*     SUBROUTINE PRELIM sets the elements of XBASE, XPT, FVAL, GOPT, HQ, PQ,\n*     BMAT and ZMAT for the first iteration, and it maintains the values of\n*     NF and KOPT. The vector X is also changed by PRELIM.\n*\n*     The arguments N, NPT, X, XL, XU, RHOBEG, IPRINT and MAXFUN are the\n*       same as the corresponding arguments in SUBROUTINE BOBYQA.\n*     The arguments XBASE, XPT, FVAL, HQ, PQ, BMAT, ZMAT, NDIM, SL and SU\n*       are the same as the corresponding arguments in BOBYQB, the elements\n*       of SL and SU being set in BOBYQA.\n*     GOPT is usually the gradient of the quadratic model at XOPT+XBASE, but\n*       it is set by PRELIM to the gradient of the quadratic model at XBASE.\n*       If XOPT is nonzero, BOBYQB will change it to its usual value later.\n*     NF is maintaned as the number of calls of CALFUN so far.\n*     KOPT will be such that the least calculated value of F so far is at\n*       the point XPT(KOPT,.)+XBASE in the space of the variables.\n*\n* @param lowerBound Lower bounds.\n* @param upperBound Upper bounds.\n*/\nprivate void prelim(double[] lowerBound,\n                    double[] upperBound) {\n    printMethod();\n\n    final int n = currentBest.getDimension();\n    final int npt = numberOfInterpolationPoints;\n    final int ndim = bMatrix.getRowDimension();\n\n    final double rhosq = initialTrustRegionRadius * initialTrustRegionRadius;\n    final double recip = 1d / rhosq;\n    final int np = n + 1;\n\n    // Set XBASE to the initial vector of variables, and set the initial\n    // elements of XPT, BMAT, HQ, PQ and ZMAT to zero.\n\n    for (int j = 0; j < n; j++) {\n        originShift.setEntry(j, currentBest.getEntry(j));\n        for (int k = 0; k < npt; k++) {\n            interpolationPoints.setEntry(k, j, ZERO);\n        }\n        for (int i = 0; i < ndim; i++) {\n            bMatrix.setEntry(i, j, ZERO);\n        }\n    }\n    for (int i = 0, max = n * np / 2; i < max; i++) {\n        modelSecondDerivativesValues.setEntry(i, ZERO);\n    }\n    for (int k = 0; k < npt; k++) {\n        modelSecondDerivativesParameters.setEntry(k, ZERO);\n        for (int j = 0, max = npt - np; j < max; j++) {\n            zMatrix.setEntry(k, j, ZERO);\n        }\n    }\n\n    // Begin the initialization procedure. NF becomes one more than the number\n    // of function values so far. The coordinates of the displacement of the\n    // next initial interpolation point from XBASE are set in XPT(NF+1,.).\n\n    double fbeg = Double.NaN;\n    for (int nf = 1; nf <= npt; nf++) {\n        final int nfm = nf - 1;\n        final int nfx = nf - n;\n        final int nfxm = nfx - 1;\n        double stepa = 0;\n        double stepb = 0;\n        if (nf <= 2 * n) {\n            if (nf >= 1 && nf <= n) {\n                stepa = initialTrustRegionRadius;\n                if (upperDifference.getEntry(nfm) == ZERO) {\n                    stepa = -stepa;\n                }\n                interpolationPoints.setEntry(nf, nfm, stepa);\n            } else if (nf > n) {\n                stepa = interpolationPoints.getEntry(nfx, nfxm);\n                stepb = -initialTrustRegionRadius;\n                if (lowerDifference.getEntry(nfxm) != ZERO) {\n                    stepb = Math.min(TWO * initialTrustRegionRadius, upperDifference.getEntry(nfxm));\n                }\n                if (upperDifference.getEntry(nfxm) != ZERO) {\n                    stepb = Math.max(-TWO * initialTrustRegionRadius, lowerDifference.getEntry(nfxm));\n                }\n                interpolationPoints.setEntry(nf, nfxm, stepb);\n            }\n        } else {\n            final int tmp1 = (nf - np) / n;\n            final int jpt = nf - tmp1 * n - n;\n            final int ipt = jpt + tmp1;\n            interpolationPoints.setEntry(nf, ipt - 1, interpolationPoints.getEntry(ipt, ipt - 1));\n            interpolationPoints.setEntry(nf, jpt - 1, interpolationPoints.getEntry(jpt, jpt - 1));\n        }\n\n        // Calculate the next value of F. The least function value so far and\n        // its index are required.\n\n        for (int j = 0; j < n; j++) {\n            currentBest.setEntry(j, Math.min(Math.max(lowerBound[j],\n                                                     originShift.getEntry(j) + interpolationPoints.getEntry(nf, j)),\n                                             upperBound[j]));\n            if (interpolationPoints.getEntry(nf, j) == lowerDifference.getEntry(j)) {\n                currentBest.setEntry(j, lowerBound[j]);\n            }\n            if (interpolationPoints.getEntry(nf, j) == upperDifference.getEntry(j)) {\n                currentBest.setEntry(j, upperBound[j]);\n            }\n        }\n\n        final double objectiveValue = computeObjectiveValue(currentBest.toArray());\n        final double f = isMinimize ? objectiveValue : -objectiveValue;\n        fAtInterpolationPoints.setEntry(nfm, f);\n\n        if (nf == 1) {\n            fbeg = f;\n            trustRegionCenterInterpolationPointIndex = 0;\n        } else if (f < fAtInterpolationPoints.getEntry(trustRegionCenterInterpolationPointIndex)) {\n            trustRegionCenterInterpolationPointIndex = nfm;\n        }\n\n        // Set the nonzero initial elements of BMAT and the quadratic model in the\n        // cases when NF is at most 2*N+1. If NF exceeds N+1, then the positions\n        // of the NF-th and (NF-N)-th interpolation points may be switched, in\n        // order that the function value at the first of them contributes to the\n        // off-diagonal second derivative terms of the initial quadratic model.\n\n        if (nf <= 2 * n + 1) {\n            if (nf >= 2 && nf <= n + 1) {\n                gradientAtTrustRegionCenter.setEntry(nfm, (f - fbeg) / stepa);\n                if (npt < nf + n) {\n                    final double oneOverStepA = ONE / stepa;\n                    bMatrix.setEntry(0, nfm, -oneOverStepA);\n                    bMatrix.setEntry(nf, nfm, oneOverStepA);\n                    bMatrix.setEntry(npt + nfm, nfm, -HALF * rhosq);\n                }\n            } else if (nf >= n + 2) {\n                final int ih = nfx * (nfx + 1) / 2 - 1;\n                final double tmp = (f - fbeg) / stepb;\n                final double diff = stepb - stepa;\n                modelSecondDerivativesValues.setEntry(ih, TWO * (tmp - gradientAtTrustRegionCenter.getEntry(nfxm)) / diff);\n                gradientAtTrustRegionCenter.setEntry(nfxm, (gradientAtTrustRegionCenter.getEntry(nfxm) * stepb - tmp * stepa) / diff);\n                if (stepa * stepb < ZERO) {\n                    if (f < fAtInterpolationPoints.getEntry(nfm - n)) {\n                        final double temp = fAtInterpolationPoints.getEntry(nfm);\n                        fAtInterpolationPoints.setEntry(nfm, fAtInterpolationPoints.getEntry(nfm - n));\n                        fAtInterpolationPoints.setEntry(nfm - n, temp);\n                        if (trustRegionCenterInterpolationPointIndex == nf) {\n                            trustRegionCenterInterpolationPointIndex = nf - n;\n                        }\n                        interpolationPoints.setEntry(nfm - n, nfxm, stepb);\n                        interpolationPoints.setEntry(nf, nfxm, stepa);\n                    }\n                }\n                bMatrix.setEntry(0, nfxm, -(stepa + stepb) / (stepa * stepb));\n                bMatrix.setEntry(nf, nfxm, -HALF / interpolationPoints.getEntry(nfm - n, nfxm));\n                bMatrix.setEntry(nfm - n, nfxm,\n                              -bMatrix.getEntry(0, nfxm) - bMatrix.getEntry(nf, nfxm));\n                zMatrix.setEntry(0, nfxm, Math.sqrt(TWO) / (stepa * stepb));\n                zMatrix.setEntry(nf, nfxm, Math.sqrt(HALF) / rhosq);\n                zMatrix.setEntry(nfm - n, nfxm,\n                              -zMatrix.getEntry(0, nfxm) - zMatrix.getEntry(nf, nfxm));\n            }\n\n            // Set the off-diagonal second derivatives of the Lagrange functions and\n            // the initial quadratic model.\n\n        } else {\n            zMatrix.setEntry(0, nfxm, recip);\n            zMatrix.setEntry(nf, nfxm, recip);\n            zMatrix.setEntry(ipt - 1, nfxm, -recip);\n            zMatrix.setEntry(jpt - 1, nfxm, -recip);\n\n            final int ih = ipt * (ipt - 1) / 2 + jpt - 2;\n            final double tmp = interpolationPoints.getEntry(nf, ipt - 1) * interpolationPoints.getEntry(nf, jpt - 1);\n            modelSecondDerivativesValues.setEntry(ih, (fbeg - fAtInterpolationPoints.getEntry(ipt - 1) - fAtInterpolationPoints.getEntry(jpt - 1) + f) / tmp);\n        }\n    }\n} // prelim",
    "exact_match": false,
    "ast_match": false,
    "compile": false,
    "test": false
}