{
    "generation": "import java.io.IOException;\nimport java.io.ObjectInputStream;\nimport java.io.ObjectOutputStream;\nimport java.util.Collection;\nimport java.util.HashMap;\nimport java.util.Map;\n\nimport org.apache.commons.collections4.CollectionUtils;\nimport org.apache.commons.collections4.Factory;\nimport org.apache.commons.collections4.FunctorException;\nimport org.apache.commons.collections4.MultiSet;\nimport org.apache.commons.collections4.MultiValuedMap;\nimport org.apache.commons.collections4.multiset.AbstractMultiSetDecorator;\n\npublic class MultiValueMap<K, V> extends AbstractMultiSetDecorator<K> implements MultiValuedMap<K, V> {\n    // deliberately not serializing this field\n    private transient Map<K, Collection<V>> map;\n    private final Factory<? extends Collection<V>> collectionFactory;\n\n    /**\n     * Reads the state of the map from the stream.  It expects to be able\n     * to find the map in the stream.  The order in which the elements are\n     * restored for the multivalued offense/defense map is unimportant, as the\n     * iterators are guaranteed to traverse the map in no particular order.\n     *\n     * @param stream  the stream to read from\n     * @throws IOException if the stream raises it\n     * @throws ClassNotFoundException if the stream raises it\n     */\n    private void readObject(final ObjectInputStream stream)\n        throws IOException, ClassNotFoundException {\n\n        stream.defaultReadObject();\n        this.map = new HashMap<>();\n\n        final int size = stream.readInt();\n        for (int i = 0; i < size; i++) {\n            @SuppressWarnings(\"unchecked\")\n            final K key = (K) stream.readObject();\n            @SuppressWarnings(\"unchecked\")\n            final Collection<V> coll = (Collection<V>) stream.readObject();\n            if (coll != null) {\n                this.map.put(key, coll);\n            }\n        }\n    }\n\n    /**\n     * Writes the map data out to the stream.  This method can safely be\n     * overridden if the subclass needs to write out any additional data.\n     * The subclass must call this method to ensure the map data is written.\n     * <p>\n     * This implementation iterates over the map's\n     * entries and saves the key and value.  Subclasses can forget about the\n     * entries if they wish (although they shouldn't bother).  \n     *\n     * @param stream  the stream to write to\n     * @throws IOException if the stream raises it\n     */\n    private void writeObject(final ObjectOutputStream stream) throws IOException {\n        stream.defaultWriteObject();\n        stream.writeInt(map.size());\n        for (final Map.Entry<K, Collection<V>> entry : map.entrySet()) {\n            stream.writeObject(entry.getKey());\n            stream.writeObject(entry.getValue());\n        }\n    }\n}",
    "exact_match": false,
    "ast_match": false,
    "compile": false,
    "test": false
}