{
    "generation": "import java.io.IOException;\nimport java.io.ObjectInputStream;\nimport java.io.ObjectOutputStream;\nimport java.io.Serializable;\nimport java.util.ArrayList;\nimport java.util.Collection;\nimport java.util.HashMap;\nimport java.util.List;\nimport java.util.Map;\n\nimport org.apache.commons.collections4.MultiMap;\nimport org.apache.commons.collections4.collection.AbstractCollectionDecorator;\n\npublic class MultiValueMap<K, V> extends AbstractMapDecorator<K, Object>\n        implements MultiMap<K, V>, Serializable {\n\n    /** Serialization version */\n    private static final long serialVersionUID = -2214199726790381732L;\n\n    /** The factory to create the collection to store values */\n    private final Factory<? extends Collection<V>> collectionFactory;\n\n    /**\n     * Creates a MultiValueMap using the supplied map and a default collection factory.\n     * <p>\n     * The default factory creates an {@code ArrayList} for each key.\n     *\n     * @param map  the map to decorate, must not be null\n     * @throws NullPointerException if map is null\n     */\n    public static <K, V> MultiValueMap<K, V> multiValueMap(final Map<K, ? super Collection<V>> map) {\n        return multiValueMap(map, ArrayList.class);\n    }\n\n    /**\n     * Creates a MultiValueMap using the supplied map and collection factory.\n     *\n     * @param map  the map to decorate, must not be null\n     * @param collectionFactory  the factory to create collections to store values, must not be null\n     * @throws NullPointerException if map or collectionFactory is null\n     */\n    public static <K, V> MultiValueMap<K, V> multiValueMap(final Map<K, ? super Collection<V>> map,\n                                                           final Factory<? extends Collection<V>> collectionFactory) {\n        if (collectionFactory == null) {\n            throw new NullPointerException(\"CollectionFactory must not be null.\");\n        }\n        return new MultiValueMap<>(map, collectionFactory);\n    }\n\n    /**\n     * Creates a MultiValueMap using the supplied map and a default collection factory.\n     * <p>\n     * The default factory creates an {@code ArrayList} for each key.\n     *\n     * @param <K> the key type\n     * @param <V> the value type\n     * @param map  the map to decorate, must not be null\n     * @param collectionClass the collection class to use, must not be null, must have a public constructor\n     * @throws NullPointerException if map or collectionClass is null\n     * @throws IllegalArgumentException if {@code collectionClass} does not have a public no-args constructor.\n     */\n    public static <K, V, C extends Collection<V>> MultiValueMap<K, V> multiValueMap(final Map<K, ? super Collection<V>> map, final Class<C> collectionClass) {\n        if (collectionClass == null) {\n            throw new NullPointerException(\"CollectionClass must not be null.\");\n        }\n        return multiValueMap(map, new ClassCollectionFactory<>(collectionClass));\n    }\n\n\n    //-----------------------------------------------------------------------\n    /**\n     * Constructor that wraps (not copies).\n     *\n     * @param map  the map to decorate, must not be null\n     * @param collectionFactory  the factory to create value collections, must not be null\n     * @throws NullPointerException if map or collectionFactory is null\n     */\n    protected MultiValueMap(final Map<K, ? super Collection<V>> map, final Factory<? extends Collection<V>> collectionFactory) {\n        super(map);\n        if (collectionFactory == null) {\n            throw new NullPointerException(\"CollectionFactory must not be null.\");\n        }\n        this.collectionFactory = collectionFactory;\n    }\n\n    private void readObject(final ObjectInputStream ois) throws IOException, ClassNotFoundException {\n        ois.defaultReadObject();\n        final Map<K, Collection<V>> map = new HashMap<>();\n        decorated(); // empty method, added to remove warning\n        this.map = map; // from AbstractMapDecorator\n    }\n\n\n    //-----------------------------------------------------------------------\n    @Override\n    public boolean put(final K key, final V value) {\n        Collection<V> coll = get(key);\n        if (coll == null) {\n            coll = createCollection(1);\n            put(key, coll);\n        }\n        return coll.add(value);\n    }\n\n\n\n    @Override\n    public void putAll(final Map<? extends K, ? extends V> map) {\n        for (final Map.Entry<? extends K, ? extends V> entry : map.entrySet()) {\n            put(entry.getKey(), entry.getValue());\n        }\n    }\n\n\n\n    @Override\n    public void putAll(final MultiMap<? extends K, ? extends V> map) {\n        for (final K key : map.keySet()) {\n            putAll(key, map.get(key));\n        }\n    }\n\n\n    @Override\n    @SuppressWarnings(\"unchecked\")\n    public Collection<V> get(final Object key) {\n        return (Collection<V>) decorated().get(key);\n    }\n\n\n    //-----------------------------------------------------------------------\n\n    /**\n     * Creates a new instance of the value collection associated with this multi-value map.\n     * <p>\n     * The collection is created using the factory specified at construction.\n     *\n     * @param size  the anticipated size of the collection (passed to the factory)\n     * @return a new, empty collection\n     */\n    protected Collection<V> createCollection(final int size) {\n        return collectionFactory.create(size);\n    }\n\n    /**\n     * Inner class to allow String constructors.\n     */\n    static class ClassCollectionFactory<V> implements Factory<Collection<V>>, Serializable {\n\n        /** Serialization version */\n        private static final long serialVersionUID = -7753217701674564658L;\n\n        /** The class to create */\n        private final Class<? extends Collection<V>> clazz;\n\n        /**\n         * Constructor that performs no validation.\n         * Use {@code ClassCollectionFactory.classCollectionFactory(Class)} instead.\n         *\n         * @param cls  the class to create, must not be null\n         */\n        ClassCollectionFactory(final Class<? extends Collection<V>> cls) { // package protected\n            this.clazz = cls;\n        }\n        \n        public static <V, C extends Collection<V>> ClassCollectionFactory<V> classCollectionFactory(final Class<C> cls) {\n            if (cls == null) {\n                throw new IllegalArgumentException(\"Collection class must not be null\");\n            }\n            return new ClassCollectionFactory<>(cls);\n        }\n\n        @Override\n        public Collection<V> create(final int size) {\n            try {\n                return clazz.getDeclaredConstructor().newInstance();\n            } catch (final ReflectiveOperationException ex) {\n                throw new IllegalArgumentException(\"Collection class must have a public no-args constructor\", ex);\n            }\n        }\n\n        private Object readResolve() {\n            if (List.class.equals(clazz) || ArrayList.class.equals(clazz)) {\n                return MultiValueMap.arrayListFactory();\n            }\n            // String is unsafe, so check that first\n            if (String.class.equals(clazz)) {\n                throw new UnsupportedOperationException(\"Unsafe collection class requested, String is not allowed\");\n            }\n            return this;\n        }\n\n    }\n\n    private static final Factory<List<Object>> ARRAY_LIST_FACTORY = new Factory<List<Object>>() {\n        @Override\n        public List<Object> create(int size) {\n            return new ArrayList<>(size);\n        }\n    };\n\n    @SuppressWarnings(\"unchecked\")\n    static <E> Factory<List<E>> arrayListFactory() {\n        return (Factory<List<E>>) ARRAY_LIST_FACTORY;\n    }\n\n}",
    "exact_match": false,
    "ast_match": false,
    "compile": false,
    "test": false
}