{
    "generation": "import java.util.ArrayList;\nimport java.util.Collection;\nimport java.util.Map;\nimport java.io.IOException;\nimport java.io.ObjectInputStream;\nimport java.io.ObjectOutputStream;\nimport java.io.Serializable;\n\nimport org.apache.commons.collections4.CollectionUtils;\nimport org.apache.commons.collections4.Factory;\nimport org.apache.commons.collections4.FunctorException;\nimport org.apache.commons.collections4.MultiSet;\nimport org.apache.commons.collections4.multiset.AbstractMapMultiSet;\n\n/**\n * Implements {@code MultiSet} using a {@code Map} to store the data.\n * <p>\n * This is the standard implementation of a multiset.\n * </p>\n * @param <E> the element type\n * @since 4.1\n */\npublic class MultiValueMap<K, V> extends AbstractMapMultiSet<K, V> implements Serializable {\n\n    /** Serialisation version */\n    private static final long serialVersionUID = 20151118L;\n\n    /** The factory to use for creating the value collections. */\n    private final Factory<? extends Collection<V>> collectionFactory;\n\n    /**\n     * Constructor.\n     *\n     * @param map  the map to decorate\n     * @param collectionFactory  the factory to use to create value collections\n     */\n    public MultiValueMap(final Map<K, ? super Collection<V>> map, final Factory<? extends Collection<V>> collectionFactory) {\n        super(map);\n        if (collectionFactory == null) {\n            throw new IllegalArgumentException(\"The factory must not be null\");\n        }\n        this.collectionFactory = collectionFactory;\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Write the map out using a custom routine.\n     *\n     * @param out  the output stream\n     * @throws IOException if an error occurs while writing to the collection's underlying storage\n     */\n    private void writeObject(final ObjectOutputStream out) throws IOException {\n        out.defaultWriteObject();\n        out.writeObject(getMap());\n    }\n\n    /**\n     * Read the map in using a custom routine.\n     *\n     * @param in  the input stream\n     * @throws IOException if an error occurs while reading from the collection's underlying storage\n     * @throws ClassNotFoundException if the class of a serialized object can not be found\n     */\n    @SuppressWarnings(\"unchecked\") // (1) should only fail if factory is incorrect\n    private void readObject(final ObjectInputStream in) throws IOException, ClassNotFoundException {\n        in.defaultReadObject();\n        setMap((Map<K, ? super Collection<V>>) in.readObject());\n    }\n\n    //-----------------------------------------------------------------------\n    @Override\n    protected Collection<V> createCollection() {\n        try {\n            return collectionFactory.create();\n        } catch (final RuntimeException ex) {\n            throw ex;\n        } catch (final Exception ex) {\n            throw new FunctorException(ex);\n        }\n    }\n\n    @Override\n    @SuppressWarnings(\"unchecked\")\n    public boolean equals(final Object object) {\n        if (object == this) {\n            return true;\n        }\n        if (!(object instanceof MultiValueMap)) {\n            return false;\n        }\n        final MultiValueMap<?, ?> that = (MultiValueMap<?, ?>) object;\n        return super.equals(object) &&\n               CollectionUtils.isEqualCollection(entrySet(), that.entrySet());\n    }\n\n}",
    "exact_match": false,
    "ast_match": false,
    "compile": false,
    "test": false
}