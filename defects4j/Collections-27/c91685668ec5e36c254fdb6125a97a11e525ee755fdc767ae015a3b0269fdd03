{
    "generation": "import java.util.ArrayList;\nimport java.util.Collection;\nimport java.util.Map;\nimport java.io.IOException;\nimport java.io.ObjectInputStream;\nimport java.io.ObjectOutputStream;\n\nimport org.apache.commons.collections4.CollectionUtils;\nimport org.apache.commons.collections4.Factory;\nimport org.apache.commons.collections4.FunctorException;\nimport org.apache.commons.collections4.MultiSet;\nimport org.apache.commons.collections4.Transformer;\nimport org.apache.commons.collections4.multiset.UnmodifiableMultiSet;\n\n/**\n * Implements <code>Map</code>, supporting multiple values per key.\n * <p>\n * The map interface is defined as accepting objects as keys and values.\n * However, this implementation assumes that all keys are objects with\n * sensible implementations of <code>equals(Object)</code> and\n * <code>hashCode()</code>, which returns the same value for all objects\n * that compare equal. In particular, numeric keys should not be used as they\n * may lead to unexpected behaviour.\n * </p>\n * <p>\n * This map uses a light-weight implementation, not suitable for many map entries.\n * Keys are stored in a <code>HashMap</code>, and values in a <code>ArrayList</code>.\n * </p>\n *\n * @since 3.0\n * @version $Id: MultiValueMap.java 1686855 2015-06-22 13:00:29Z tn $\n */\npublic class MultiValueMap<K, V> extends AbstractMultiValuedMap<K, V> {\n\n    /** Serialisation version */\n    private static final long serialVersionUID = -2210955749735604426L;\n\n    /** The factory to use to create value collections */\n    private final Factory<? extends Collection<V>> collectionFactory;\n\n    /**\n     * Constructor that uses an <code>ArrayList</code> as the collection\n     * to store multiple values in.\n     *\n     * @param map  the map to decorate, must not be null\n     * @throws NullPointerException if map is null\n     */\n    public MultiValueMap(final Map<K, ? extends Collection<V>> map) {\n        this(map, ArrayList.class);\n    }\n\n    /**\n     * Constructor that uses the supplied <code>Factory</code> to create\n     * the collections to store multiple values in. The factory must\n     * return a new, empty <code>Collection</code>.\n     *\n     * @param map  the map to decorate, must not be null\n     * @param factory  the factory to use, must not be null\n     * @throws NullPointerException if map or factory is null\n     */\n    public MultiValueMap(final Map<K, ? extends Collection<V>> map, final Factory<? extends Collection<V>> factory) {\n        super(map);\n        if (factory == null) {\n            throw new NullPointerException(\"factory must not be null\");\n        }\n        this.collectionFactory = factory;\n    }\n\n    /**\n     * Constructor that uses the supplied <code>Class</code> to instantiate\n     * the collections to store multiple values in. The class must have a\n     * default constructor.\n     *\n     * @param map  the map to decorate, must not be null\n     * @param clazz  the type of the collection (e.g. ArrayList.class)\n     * @throws NullPointerException if map or clazz is null\n     * @throws ClassCastException if the class is invalid\n     */\n    public MultiValueMap(final Map<K, ? extends Collection<V>> map, final Class<? extends Collection<V>> clazz) {\n        super(map);\n        if (clazz == null) {\n            throw new NullPointerException(\"clazz must not be null\");\n        }\n        this.collectionFactory = new Factory<Collection<V>>() {\n            @Override\n            public Collection<V> create() {\n                try {\n                    return clazz.newInstance();\n                } catch (final InstantiationException ex) {\n                    throw new FunctorException(ex);\n                } catch (final IllegalAccessException ex) {\n                    throw new FunctorException(ex);\n                }\n            }\n        };\n    }\n\n    /**\n     * A constructor that wraps the specified map and uses the supplied\n     * <code>Factory</code> to create the collections to store multiple\n     * values in.\n     *\n     * @param map  the map to wrap, must not be null\n     * @param collectionFactory  the factory to use, must not be null\n     * @throws NullPointerException if map or factory is null\n     */\n    protected MultiValueMap(final Map<K, Collection<V>> map,\n                            final Factory<? extends Collection<V>> collectionFactory) {\n        super(map);\n        if (collectionFactory == null) {\n            throw new NullPointerException(\"collectionFactory must not be null\");\n        }\n        this.collectionFactory = collectionFactory;\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Factory method to create a MultiValueMap using an <code>ArrayList</code>\n     * as the collection to store multiple values in.\n     *\n     * @param <K>  the key type\n     * @param <V>  the value to store\n     * @return a new MultiValueMap\n     */\n    public static <K, V> MultiValueMap<K, V> multiValueMap() {\n        return new MultiValueMap<K, V>(new HashMap<K, Collection<V>>());\n    }\n\n    /**\n     * Factory method to create a MultiValueMap using an <code>ArrayList</code>\n     * as the collection to store multiple values in.\n     *\n     * @param <K>  the key type\n     * @param <V>  the value to store\n     * @param map  the map to decorate, must not be null\n     * @return a new MultiValueMap\n     * @throws NullPointerException if map is null\n     * @since 4.0\n     */\n    public static <K, V> MultiValueMap<K, V> multiValueMap(final Map<K, ? extends Collection<V>> map) {\n        return new MultiValueMap<K, V>(map);\n    }\n\n    /**\n     * Factory method to create a MultiValueMap that uses the supplied factory\n     * to create the collections to store multiple values in. The factory must\n     * return a new, empty <code>Collection</code>.\n     *\n     * @param <K>  the key type\n     * @param <V>  the value to store\n     * @param map  the map to decorate, must not be null\n     * @param factory  the factory to use, must not be null\n     * @return a new MultiValueMap\n     * @throws NullPointerException if map or factory is null\n     * @since 4.0\n     */\n    public static <K, V> MultiValueMap<K, V> multiValueMap(final Map<K, ? extends Collection<V>> map,\n                                                            final Factory<? extends Collection<V>> factory) {\n        return new MultiValueMap<K, V>(map, factory);\n    }\n\n    /**\n     * Factory method to create a MultiValueMap that uses the supplied\n     * class to instantiate the collections to store multiple values\n     * in.\n     *\n     * @param <K>  the key type\n     * @param <V>  the value to store\n     * @param map  the map to decorate, must not be null\n     * @param clazz  the type of the collection (e.g. ArrayList.class)\n     * @return a new MultiValueMap\n     * @throws NullPointerException if map or clazz is null\n     * @throws ClassCastException if the class is invalid\n     * @since 4.0\n     */\n    public static <K, V> MultiValueMap<K, V> multiValueMap(final Map<K, ? extends Collection<V>> map,\n                                                            final Class<? extends Collection<V>> clazz) {\n        return new MultiValueMap<K, V>(map, clazz);\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Creates a new instance of the map value Collection.\n     *\n     * @return a new instance of the map value Collection\n     */\n    @Override\n    protected Collection<V> createCollection() {\n        return this.collectionFactory.create();\n    }\n\n    /**\n     * Write the map out using a custom routine.\n     *\n     * @param out  the output stream\n     * @throws IOException if an error occurs while writing to the collection's\n     * serialized form\n     */\n    private void writeObject(final ObjectOutputStream out) throws IOException {\n        out.defaultWriteObject();\n        out.writeObject(map);\n    }\n\n    /**\n     * Read the map in using a custom routine.\n     *\n     * @param in the input stream\n     * @throws IOException if an error occurs while reading from the collection's\n     * serialized form\n     * @throws ClassNotFoundException if the class of a serialized object can not be found\n     */\n    @SuppressWarnings(\"unchecked\") // (cast) map entrySet - needed\n    private void readObject(final ObjectInputStream in) throws IOException, ClassNotFoundException {\n        in.defaultReadObject();\n        this.map = (Map<K, Collection<V>>) in.readObject();\n        if (collectionFactory == null) {\n            this.collectionFactory = new Factory<Collection<V>>() {\n                @Override\n                public Collection<V> create() {\n                    return new ArrayList<V>();\n                }\n            };\n        }\n    }\n\n}",
    "exact_match": false,
    "ast_match": false,
    "compile": false,
    "test": false
}