{
    "generation": "import java.io.IOException;\nimport java.io.ObjectInputStream;\nimport java.io.ObjectOutputStream;\nimport java.io.Serializable;\nimport java.util.ArrayList;\nimport java.util.Collection;\nimport java.util.HashMap;\nimport java.util.Map;\n\nimport org.apache.commons.collections4.MultiMap;\nimport org.apache.commons.collections4.Transformer;\nimport org.apache.commons.collections4.collection.AbstractCollectionDecorator;\nimport org.apache.commons.collections4.iterators.AbstractIteratorDecorator;\nimport org.apache.commons.collections4.keyvalue.AbstractMapEntryDecorator;\nimport org.apache.commons.collections4.map.AbstractMapDecorator;\n\n/**\n * Implementation of {@link MultiMap} using a {@link Map} and a {@link Collection}.\n * <p>\n * Internally this map uses a standard {@link HashMap} and for the values\n * it uses a {@link ArrayList}.\n * </p>\n * @param <K> the type of the keys in this map\n * @param <V> the type of the values in this map\n * @since 4.1\n */\npublic class MultiValueMap<K, V> extends AbstractMapDecorator<K, Collection<V>>\n        implements MultiMap<K, V>, Serializable {\n\n    /** Serialisation version */\n    private static final long serialVersionUID = -2214190725972373922L;\n\n    /** The collection class to use. */\n    private final Class<? extends Collection<V>> collectionClass;\n\n    /** The factory to use to create value collections. */\n    private transient Transformer<? super K, ? extends Collection<V>> collectionFactory;\n\n\n    /**\n     * Factory method to create a MultiValueMap using the default collection class.\n     * <p>\n     * The returned map uses {@link ArrayList} as the collection type.\n     *\n     * @param <K>  the key type\n     * @param <V>  the value type\n     * @return a new MultiValueMap\n     */\n    public static <K, V> MultiValueMap<K, V> multiValueMap() {\n        return multiValueMap(new HashMap<K, Collection<V>>(), ArrayList.class);\n    }\n\n    /**\n     * Factory method to create a MultiValueMap.\n     *\n     * @param <K>  the key type\n     * @param <V>  the value type\n     * @param map  the map to decorate, must not be null\n     * @param collectionClass  the collection class, must not be null\n     * @return a new MultiValueMap\n     * @throws NullPointerException if map or collectionClass is null\n     * @since 4.2\n     */\n    public static <K, V> MultiValueMap<K, V> multiValueMap(final Map<K, ? super Collection<V>> map,\n                                                         final Class<? extends Collection<V>> collectionClass) {\n        if (collectionClass == null) {\n            throw new NullPointerException(\"Collection class must not be null.\");\n        }\n        if (map == null) {\n            throw new NullPointerException(\"Map must not be null.\");\n        }\n        return new MultiValueMap<>(map, collectionClass);\n    }\n\n    /**\n     * Factory method to create a MultiValueMap using a custom collection factory.\n     *\n     * @param <K>  the key type\n     * @param <V>  the value type\n     * @param map  the map to decorate, must not be null\n     * @param collectionFactory  the factory to use, must not be null\n     * @return a new MultiValueMap\n     * @throws NullPointerException if map or collectionClass is null\n     * @since 4.2\n     */\n    public static <K, V> MultiValueMap<K, V> multiValueMap(final Map<K, ? super Collection<V>> map,\n                                                         final Transformer<? super K, ? extends Collection<V>> collectionFactory) {\n        if (collectionFactory == null) {\n            throw new NullPointerException(\"Collection factory must not be null.\");\n        }\n        if (map == null) {\n            throw new NullPointerException(\"Map must not be null.\");\n        }\n        return new MultiValueMap<>(map, collectionFactory);\n    }\n\n\n    //-----------------------------------------------------------------------\n    /**\n     * Constructor that wraps (not copies) another Map.\n     * <p>\n     * The collectionClass must implement the {@link java.util.Collection}\n     * interface or a runtime exception will be thrown when the map is used.\n     * Unknown unchecked exceptions from the underlying map may also be thrown\n     * when the map is used.\n     *\n     * @param map  the map to decorate, must not be null\n     * @param collectionClass  the collection class, must not be null\n     * @throws NullPointerException if map is null\n     */\n    protected MultiValueMap(final Map<K, ? super Collection<V>> map, final Class<? extends Collection<V>> collectionClass) {\n        super(map);\n        if (collectionClass == null) {\n            throw new NullPointerException(\"Collection class must not be null.\");\n        }\n        this.collectionClass = collectionClass;\n        this.collectionFactory = null;\n    }\n\n    /**\n     * Constructor that wraps (not copies) another Map and provides a\n     * custom collection factory.\n     *\n     * @param map  the map to decorate, must not be null\n     * @param collectionFactory  the factory to use, must not be null\n     * @throws NullPointerException if map is null\n     * @since 4.2\n     */\n    protected MultiValueMap(final Map<K, ? super Collection<V>> map,\n                           final Transformer<? super K, ? extends Collection<V>> collectionFactory) {\n        super(map);\n        if (collectionFactory == null) {\n            throw new NullPointerException(\"Collection factory must not be null.\");\n        }\n        this.collectionClass = null;\n        this.collectionFactory = collectionFactory;\n    }\n\n    private void readObject(final ObjectInputStream ois) throws IOException, ClassNotFoundException {\n        ois.defaultReadObject();\n        final String className = ois.readUTF();\n        if (className != null) {\n            try {\n                this.collectionClass = Class.forName(className).asSubclass(Collection.class);\n            } catch (final ClassNotFoundException ex) { // NOPMD\n                // ignore\n            }\n        }\n\n    }\n\n    private void writeObject(final ObjectOutputStream oos) throws IOException {\n        oos.defaultWriteObject();\n        // serialize the collection class\n        String className = null;\n        if (this.collectionClass != null) {\n            className = this.collectionClass.getName();\n        }\n        oos.writeUTF(className);\n    }\n\n\n    //-----------------------------------------------------------------------\n    @Override\n    public void putAll(final Map<? extends K, ? extends V> map) {\n       map.forEach(this::put);\n    }\n\n    @Override\n    public boolean containsValue(final Object value) {\n        return values().stream().anyMatch(c -> c.contains(value));\n    }\n\n    @Override\n    public Collection<V> get(final Object key) {\n        return wrappedMap().computeIfAbsent((K) key, this::createCollection);\n    }\n\n    @Override\n    public Collection<V> remove(final Object key) {\n        return wrappedMap().remove(key);\n    }\n\n    @Override\n    public boolean removeMapping(final Object key, final Object value) {\n        Collection<V> coll = wrappedMap().get(key);\n        if (coll == null) {\n            return false;\n        }\n\n        boolean changed = coll.remove(value);\n        if (coll.isEmpty()) {\n            wrappedMap().remove(key);\n        }\n\n        return changed;\n    }\n\n    //-----------------------------------------------------------------------\n    @Override\n    protected Collection<V> decorate(final Collection<V> coll) {\n        if (coll == null) {\n            return null;\n        }\n        return new AbstractCollectionDecorator<V>(coll) {\n            @Override\n            public boolean add(final V object) {\n                return decorated().add(object);\n            }\n        };\n    }\n\n    private Collection<V> createCollection(final K key) {\n        if (collectionFactory != null) {\n            return collectionFactory.transform(key);\n        }\n        if (collectionClass == null) {\n            return new ArrayList<>();\n        }\n\n        try {\n            return collectionClass.newInstance();\n        } catch (final Exception e) {\n            throw new UnsupportedOperationException(\"Cannot instantiate collection class: \" + collectionClass.getName());\n        }\n\n    }\n\n\n    //-----------------------------------------------------------------------\n    @Override\n    public Collection<Collection<V>> values() {\n        return new AbstractCollectionDecorator<Collection<V>>(super.values()) {\n            @Override\n            public boolean add(final Collection<V> collection) {\n                for (final V v : collection) {\n                    add(v);\n                }\n                return true;\n            }\n\n            @Override\n            public boolean remove(final Object o) {\n                for (final Map.Entry<K, Collection<V>> entry : wrappedMap().entrySet()) {\n                    final Collection<V> c = entry.getValue();\n                    if (c == o || (c != null && c.equals(o))) {\n                        wrappedMap().remove(entry.getKey());\n                        return true;\n                    }\n                }\n\n                return false;\n            }\n        };\n    }\n}\n",
    "exact_match": false,
    "ast_match": false,
    "compile": false,
    "test": false
}