{
    "generation": "import java.io.IOException;\nimport java.io.ObjectInputStream;\nimport java.io.ObjectOutputStream;\nimport java.util.Collection;\nimport java.util.HashMap;\nimport java.util.Map;\n\nimport org.apache.commons.collections4.CollectionUtils;\n\n/**\n * A {@link Map} implementation that allows for multiple values for a given key.\n * <p>\n * This map is implemented internally using a {@link HashMap} to map keys to\n * {@link Collection}s. It also has the ability to return null for both the\n * {@link #get(Object)} and {@link #put(Object, Object)} operations.\n * </p>\n * <p>\n * This class is not thread-safe. When it is necessary to use this map from\n * multiple threads, it must be synchronized externally.\n * </p>\n *\n * @param <K> the type of the keys in this map\n * @param <V> the type of the values in this map\n * @since 3.0\n */\npublic class MultiValueMap<K, V> implements Map<K, Object> {\n\n    /**\n     * The map used to store the data\n     */\n    private Map<K, Collection<V>> map;\n\n    /**\n     * The collection class to use\n     */\n    private final Class<? extends Collection<V>> collectionClass;\n\n    /**\n     * Instantiates a new MultiValueMap with a {@link HashMap}\n     * and {@link ArrayList}s.\n     *\n     * @param collectionClass the collection class to use\n     */\n    public MultiValueMap(final Class<? extends Collection<V>> collectionClass) {\n        this(new HashMap<K, Collection<V>>(), collectionClass);\n    }\n\n    /**\n     * Instantiates a new MultiValueMap with the given map and {@link ArrayList}s.\n     *\n     * @param map             the map to use\n     * @param collectionClass the collection class to use\n     */\n    public MultiValueMap(final Map<K, Collection<V>> map, final Class<? extends Collection<V>> collectionClass) {\n        this.map = map;\n        this.collectionClass = collectionClass;\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Write the map out using a custom routine.\n     *\n     * @param out the stream to write to\n     * @throws IOException any exception\n     */\n    private void writeObject(final ObjectOutputStream out) throws IOException {\n        out.defaultWriteObject();\n        out.writeObject(map);\n    }\n\n    /**\n     * Read the map in using a custom routine.\n     *\n     * @param in the stream to read from\n     * @throws IOException            any exception\n     * @throws ClassNotFoundException any exception\n     */\n    @SuppressWarnings(\"unchecked\")\n    private void readObject(final ObjectInputStream in) throws IOException, ClassNotFoundException {\n        in.defaultReadObject();\n        map = (Map<K, Collection<V>>) in.readObject();\n        if (!collectionClass.isInterface() && !CollectionUtils.isSubCollection(collectionClass, Collection.class)) {\n            throw new UnsupportedOperationException(\"Suspicious collection class: \" + collectionClass.getName());\n        }\n    }\n\n}",
    "exact_match": false,
    "ast_match": false,
    "compile": false,
    "test": false
}