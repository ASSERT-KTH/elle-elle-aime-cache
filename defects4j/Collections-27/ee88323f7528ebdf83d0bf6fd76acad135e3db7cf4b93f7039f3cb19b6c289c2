{
    "generation": "import java.io.IOException;\nimport java.io.ObjectInputStream;\nimport java.io.ObjectOutputStream;\nimport java.util.Collection;\nimport java.util.HashMap;\nimport java.util.Map;\n\nimport org.apache.commons.collections4.Factory;\nimport org.apache.commons.collections4.FunctorException;\nimport org.apache.commons.collections4.MultiSet;\nimport org.apache.commons.collections4.multiset.AbstractMultiSetDecorator;\n\n/**\n * Provides a very simple multiset implementation that supports the {@code MultiSet} interface.\n * <p>\n * As the name implies, this is a simple implementation that is based on grouping keys and values\n * together into a pair.\n *\n * @since 4.1\n * @param <K> the type held by the multiset\n * @deprecated since 4.2, use {@link org.apache.commons.collections4.multiset.HashMultiSet} instead\n */\n@Deprecated\npublic final class MultiValueMap<K, V> extends AbstractMultiSetDecorator<K, V>\n        implements Map<K, Object>, Cloneable, java.io.Serializable {\n\n    /** Serialisation version */\n    private static final long serialVersionUID = 20150612L;\n\n    /** The factory to use to create value collections */\n    private final Factory<? extends Collection<V>> collectionFactory;\n\n    /**\n     * Creates a new empty {@code MultiValueMap} using\n     * {@link org.apache.commons.collections4.map.AbstractMultiValueMap.DefaultValueCollectionFactory}\n     * to create the value collections.\n     *\n     * @param <K> the key type\n     * @param <V> the element type\n     * @return a new multi value map\n     * @deprecated use {@link org.apache.commons.collections4.multiset.HashMultiSet} instead\n     */\n    @Deprecated\n    public static <K, V> MultiValueMap<K, V> multiValueMap() {\n        return new MultiValueMap<>(new HashMap<K, Collection<V>>());\n    }\n\n    /**\n     * Creates a new empty {@code MultiValueMap} using the supplied\n     * {@link Factory} to create the value collections.\n     *\n     * @param <K> the key type\n     * @param <V> the element type\n     * @param collectionFactory a factory to create new collection objects to store value\n     * @return a new multi value map\n     * @throws NullPointerException if the factory is null\n     * @deprecated use {@link org.apache.commons.collections4.multiset.HashMultiSet} instead\n     */\n    @Deprecated\n    public static <K, V> MultiValueMap<K, V> multiValueMap(final Factory<? extends Collection<V>> collectionFactory) {\n        return new MultiValueMap<>(new HashMap<K, Collection<V>>(), collectionFactory);\n    }\n\n    /**\n     * Creates a new {@code MultiValueMap} that wraps the specified map.\n     *\n     * @param <K> the key type\n     * @param <V> the element type\n     * @param map the map to wrap\n     * @return a new multi value map\n     * @deprecated use {@link org.apache.commons.collections4.multiset.HashMultiSet} instead\n     */\n    @Deprecated\n    public static <K, V> MultiValueMap<K, V> multiValueMap(final Map<K, ? extends Collection<V>> map) {\n        return new MultiValueMap<>(map);\n    }\n\n    /**\n     * Creates a new empty {@code MultiValueMap} using the supplied\n     * map and {@link Factory} to create the value collections.\n     *\n     * @param <K> the key type\n     * @param <V> the element type\n     * @param map the map to wrap\n     * @param collectionFactory a factory to create new collection objects to store value\n     * @return a new multi value map\n     * @throws NullPointerException if the map or factory is null\n     * @deprecated use {@link org.apache.commons.collections4.multiset.HashMultiSet} instead\n     */\n    @Deprecated\n    public static <K, V> MultiValueMap<K, V> multiValueMap(final Map<K, ? extends Collection<V>> map,\n                                                            final Factory<? extends Collection<V>> collectionFactory) {\n        return new MultiValueMap<>(map, collectionFactory);\n    }\n\n    /**\n     * Creates a new {@code MultiValueMap} using\n     * {@link org.apache.commons.collections4.map.AbstractMultiValueMap.DefaultValueCollectionFactory}\n     * to create the value collections.\n     *\n     * @param <K> the key type\n     * @param <V> the element type\n     * @param map the map to wrap, which is copied\n     * @param collectionClass the class of collection to use\n     * @return a new multi value map\n     * @deprecated use {@link org.apache.commons.collections4.multiset.HashMultiSet} instead\n     */\n    @Deprecated\n    public static <K, V> MultiValueMap<K, V> multiValueMap(final Map<K, ? extends Collection<V>> map,\n                                                            final Class<?> collectionClass) {\n        return new MultiValueMap<>(map, collectionClass);\n    }\n\n    /**\n     * Creates a new {@code MultiValueMap} that wraps the specified map\n     * and creates value collections of the specified class.\n     *\n     * @param <K> the key type\n     * @param <V> the element type\n     * @param collectionClass the class of collection to use\n     * @return a new multi value map\n     * @deprecated use {@link org.apache.commons.collections4.multiset.HashMultiSet} instead\n     */\n    @Deprecated\n    public static <K, V> MultiValueMap<K, V> multiValueMap(final Class<?> collectionClass) {\n        return new MultiValueMap<>(new HashMap<K, Collection<V>>(), collectionClass);\n    }\n\n    // -----------------------------------------------------------------------\n    /**\n     * Constructor.\n     *\n     * @deprecated use {@link org.apache.commons.collections4.multiset.HashMultiSet} instead\n     */\n    @Deprecated\n    public MultiValueMap() {\n        this(new HashMap<K, Collection<V>>(), new DefaultValueCollectionFactory<V>());\n    }\n\n    /**\n     * Constructor that uses the supplied map and\n     * {@link org.apache.commons.collections4.map.AbstractMultiValueMap.DefaultValueCollectionFactory}.\n     *\n     * @param map the map to decorate\n     * @deprecated use {@link org.apache.commons.collections4.multiset.HashMultiSet} instead\n     */\n    @Deprecated\n    public MultiValueMap(final Map<K, ? extends Collection<V>> map) {\n        this(map, new DefaultValueCollectionFactory<V>());\n    }\n\n    /**\n     * Constructor.\n     *\n     * @param map the map to decorate\n     * @param collectionFactory a factory to create new collection objects to store value\n     * @deprecated use {@link org.apache.commons.collections4.multiset.HashMultiSet} instead\n     */\n    @Deprecated\n    public MultiValueMap(final Map<K, ? extends Collection<V>> map,\n                         final Factory<? extends Collection<V>> collectionFactory) {\n        super(map);\n        if (collectionFactory == null) {\n            throw new NullPointerException(\"collectionFactory\");\n        }\n        this.collectionFactory = collectionFactory;\n    }\n\n    /**\n     * Constructor.\n     *\n     * @param map the map to decorate\n     * @param collectionClass the class of collection to use\n     * @deprecated use {@link org.apache.commons.collections4.multiset.HashMultiSet} instead\n     */\n    @Deprecated\n    public MultiValueMap(final Map<K, ? extends Collection<V>> map, final Class<?> collectionClass) {\n        this(map, new ReflectionBasedCollectionFactory<V>(collectionClass));\n    }\n\n    /**\n     * Constructor.\n     *\n     * @param collectionClass the class of collection to use\n     * @deprecated use {@link org.apache.commons.collections4.multiset.HashMultiSet} instead\n     */\n    @Deprecated\n    public MultiValueMap(final Class<?> collectionClass) {\n        this(new HashMap<K, Collection<V>>(), collectionClass);\n    }\n\n    // -----------------------------------------------------------------------\n    @Override\n    public int size() {\n        int size = 0;\n        for (final Collection<V> col : decorated().values()) {\n            if (col != null) {\n                size += col.size();\n            }\n        }\n        return size;\n    }\n\n    @Override\n    public boolean isEmpty() {\n        return decorated().isEmpty();\n    }\n\n    @Override\n    public boolean containsValue(final Object value) {\n        for (final Collection<V> col : decorated().values()) {\n            if (col != null && col.contains(value)) {\n                return true;\n            }\n        }\n        return false;\n    }\n\n    @Override\n    public boolean containsKey(final Object key) {\n        return decorated().containsKey(key);\n    }\n\n    @Override\n    public int getCount(final Object object) {\n        final Collection<V> col = getCollection(object);\n        return col == null ? 0 : col.size();\n    }\n\n    @Override\n    public boolean add(final K object) {\n        return add(object, 1);\n    }\n\n    /**\n     * Adds a number of occurrences of the specified object to the multiset.\n     *\n     * @param object  the object to add\n     * @param occurrences  the number of occurrences to add, may be zero,\n     * in which case no change is made to the multiset\n     * @return {@code true} if the multiset changed\n     */\n    public boolean add(final K object, final int occurrences) {\n        if (occurrences < 1) {\n            return false;\n        }\n        final Collection<V> current = getCollection(object);\n        if (current == null) {\n            decorated().put(object, createCollection(occurrences));\n        } else {\n            for (int i = 0; i < occurrences; i++) {\n                current.add(null);\n            }\n        }\n        return true;\n    }\n\n    @Override\n    public int add(final K key, final V value) {\n        getCollection(key).add(value);\n        return 1;\n    }\n\n    @Override\n    public int remove(final Object object, final int occurrences) {\n        if (occurrences < 1) {\n            return 0;\n        }\n\n        final Collection<V> current = getCollection(object);\n        if (current == null) {\n            return 0;\n        }\n\n        final int oldSize = current.size();\n        if (occurrences > current.size()) {\n            current.clear();\n        } else {\n            for (int i = 0; i < occurrences; i++) {\n                current.remove(null);\n            }\n        }\n        if (current.isEmpty()) {\n            decorated().remove(object);\n        }\n        return oldSize - current.size();\n    }\n\n    @Override\n    public boolean remove(final Object key, final Object value) {\n        final Collection<V> valuesForKey = getCollection(key);\n        final boolean result = valuesForKey != null && valuesForKey.remove(value);\n        if (valuesForKey != null && valuesForKey.isEmpty()) {\n            remove(key);\n        }\n        return result;\n    }\n\n    @Override\n    public void clear() {\n        decorated().clear();\n    }\n\n    @Override\n    public Object put(final K key, final Object value) {\n        return decorated().put(key, (Collection<V>) value);\n    }\n\n    /**\n     * Gets the collection of values associated with the specified key.\n     * This method will never return null, but may return an empty collection.\n     *\n     * @param key the key to retrieve\n     * @return the {@code Collection} of values, will return an empty {@code Collection}\n     * if the key is not present\n     */\n    public Collection<V> getCollection(final Object key) {\n        return decorated().get(key);\n    }\n\n    /**\n     * Gets the collection of values associated with the specified key.\n     *\n     * @param key the key to retrieve\n     * @param create  {@code true} to create the collection if it doesn't exist\n     * @return the {@code Collection} of values, will return {@code null}\n     * if the key is not present and {@code create} is {@code false}\n     */\n    public Collection<V> getCollection(final Object key, final boolean create) {\n        Collection<V> collection = decorated().get(key);\n        if (collection == null && create) {\n            collection = createCollection(1);\n            decorated().put((K) key, collection);\n        }\n        return collection;\n    }\n\n    /**\n     * Removes all values associated with the specified key.\n     *\n     * @param key the key to remove values from\n     * @return the {@code Collection} of values that were associated with the key,\n     * or {@code null} if the key was not present\n     */\n    @Override\n    public Collection<V> remove(final Object key) {\n        final Collection<V> collection = decorated().remove(key);\n        return collection == null ? null : createCollection(collection);\n    }\n\n    /**\n     * Creates a new instance of the value collection.\n     *\n     * @param size  the initial size of the value collection\n     * @return a new value collection\n     */\n    private Collection<V> createCollection(final int size) {\n        final Collection<V> collection = collectionFactory.create();\n        return collection == null ? null : createCollection(collection);\n    }\n\n    /**\n     * Creates a new empty value collection.\n     * <p>\n     * This is called internally to create a new entry for a key.\n     * The created collection will be returned by {@code getCollection} and\n     * {@code getValues}.\n     * </p>\n     * <p>\n     * The default implementation uses the factory to create an empty collection.\n     * Subclasses may provide their own implementation of this method.\n     * </p>\n     *\n     * @return a new, empty value collection\n     */\n    protected Collection<V> createCollection() {\n        return createCollection(1);\n    }\n\n    /**\n     * Creates a collection based on an existing collection.\n     * <p>\n     * This is called internally to copy value collections.\n     * </p>\n     *\n     * @param coll  the existing collection, may be null\n     * @return a new collection containing the data from the parameter collection\n     */\n    protected Collection<V> createCollection(final Collection<V> coll) {\n        if (coll == null) {\n            return null;\n        }\n        final Collection<V> collection = collectionFactory.create();\n        if (collection == null) {\n            return null;\n        }\n        collection.addAll(coll);\n        return collection;\n    }\n\n    // -----------------------------------------------------------------------\n    @Override\n    public MultiSet<K> uniqueSet() {\n        return decorated().keySet();\n    }\n\n    /**\n     * Write the map out using a custom routine.\n     * @param out the stream to write to\n     * @throws IOException if an error occurs while writing to the stream\n     */\n    private void writeObject(final ObjectOutputStream out) throws IOException {\n        out.defaultWriteObject();\n        out.writeObject(decorated());\n    }\n\n    /**\n     * Read the map in using a custom routine.\n     * @param in the stream to read from\n     * @throws IOException if an error occurs while reading from the stream\n     * @throws ClassNotFoundException if an error occurs while reading from the stream\n     */\n    @SuppressWarnings(\"unchecked\") // (HashMap)\n    private void readObject(final ObjectInputStream in)\n            throws IOException, ClassNotFoundException {\n        in.defaultReadObject();\n        decorated((Map<K, ? extends Collection<V>>) in.readObject());\n    }\n\n    /**\n     * Default collection factory.\n     */\n    private static class DefaultValueCollectionFactory<V> implements Factory<Collection<V>>, Serializable {\n        /** Serial version */\n        private static final long serialVersionUID = 20150612L;\n\n        @Override\n        public Collection<V> create() {\n            return new ArrayList<V>();\n        }\n    }\n\n    /**\n     * Reflection based collection factory.\n     */\n    private static class ReflectionBasedCollectionFactory<V> implements Factory<Collection<V>>, Serializable {\n        /** Serial version */\n        private static final long serialVersionUID = 20150612L;\n\n        /** The class of the collection */\n        private final Class<?> collectionClass;\n\n        /**\n         * Create the factory.\n         * @param collectionClass the collection class\n         * @throws NullPointerException if the collection class is null\n         */\n        public ReflectionBasedCollectionFactory(final Class<?> collectionClass) {\n            if (collectionClass == null) {\n                throw new NullPointerException(\"collectionClass\");\n            }\n            if (!Collection.class.isAssignableFrom(collectionClass)) {\n                throw new FunctorException(\"Specified class is not a Collection: \" + collectionClass.getName());\n            }\n            this.collectionClass = collectionClass;\n        }\n\n        @SuppressWarnings(\"unchecked\")\n        @Override\n        public Collection<V> create() {\n            return (Collection<V>) createCollection();\n        }\n\n        /**\n         * Create a collection.\n         * @return the collection\n         */\n        private Object createCollection() {\n            try {\n                return collectionClass.newInstance();\n            } catch (final InstantiationException ex) {\n                throw new FunctorException(\"Cannot instantiate class: \" + collectionClass.getName(), ex);\n            } catch (final IllegalAccessException ex) {\n                throw new FunctorException(\"Security denied while trying to instantiate class: \"\n                        + collectionClass.getName(), ex);\n            }\n        }\n\n        /**\n         * {@inheritDoc}\n         */\n        @Override\n        public boolean equals(final Object obj) {\n            if (obj instanceof ReflectionBasedCollectionFactory) {\n                return collectionClass.equals(((ReflectionBasedCollectionFactory<?>) obj).collectionClass);\n            }\n            return false;\n        }\n\n        /**\n         * {@inheritDoc}\n         */\n        @Override\n        public int hashCode() {\n            return collectionClass.hashCode();\n        }\n    }\n\n}",
    "exact_match": false,
    "ast_match": false,
    "compile": false,
    "test": false
}