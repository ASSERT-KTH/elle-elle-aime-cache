{
    "generation": "import java.io.IOException;\nimport java.io.ObjectInputStream;\nimport java.io.ObjectOutputStream;\nimport java.io.Serializable;\nimport java.util.ArrayList;\nimport java.util.Collection;\nimport java.util.HashMap;\nimport java.util.Map;\n\nimport org.apache.commons.collections4.CollectionUtils;\n\npublic class MultiValueMap<K, V> extends AbstractMapDecorator<K, Object>\n        implements MultiValuedMap<K, V>, Serializable {\n\n    /** Serialization version */\n    private static final long serialVersionUID = -2214199823759701872L;\n\n    /** The collection class */\n    private final Class<? extends Collection> collectionClass;\n\n\n    /**\n     * Factory method to create a MultiValueMap using the supplied map and Collection class.\n     * <p>\n     * The returned MultiValueMap uses the {@code HashMap} class for the map and {@code ArrayList} for the collection.\n     * It allows null keys and values.\n     *\n     * @param <K>  the key type\n     * @param <V>  the value type\n     * @return a new MultiValueMap\n     */\n    public static <K, V> MultiValueMap<K, V> multiValueMap() {\n        return multiValueMap(new HashMap<K, Object>(), ArrayList.class);\n    }\n\n    /**\n     * Factory method to create a MultiValueMap using the supplied map and Collection class.\n     *\n     * @param <K>             the key type\n     * @param <V>             the value type\n     * @param map             the map to decorate, must not be null\n     * @param collectionClass the collection class, must not be null\n     * @return a new MultiValueMap\n     * @throws NullPointerException if map or collectionClass is null\n     * @since 4.1\n     */\n    public static <K, V> MultiValueMap<K, V> multiValueMap(final Map<K, Object> map,\n                                                         final Class<? extends Collection> collectionClass) {\n        if (collectionClass == null) {\n            throw new NullPointerException(\"Collection class must not be null\");\n        }\n\n        if (collectionClass.equals(String.class) || collectionClass.equals(Integer.class) ||\n                collectionClass.equals(Character.class) || collectionClass.equals(Long.class) ||\n                collectionClass.equals(Short.class) || collectionClass.equals(Byte.class) ||\n                collectionClass.equals(Float.class) || collectionClass.equals(Double.class) ||\n                collectionClass.equals(Boolean.class) ) {\n            throw new UnsupportedOperationException(\"Cannot use primitive value or wrapper value as a collection\");\n        }\n        return new MultiValueMap<>(map, collectionClass);\n    }\n\n\n    /**\n     * Constructor.\n     *\n     * @param map the map to decorate\n     * @param collectionClass the collection class\n     * @since 4.1\n     */\n    protected MultiValueMap(final Map<K, Object> map, final Class<? extends Collection> collectionClass) {\n        super(map);\n        this.collectionClass = collectionClass;\n    }\n\n    //-----------------------------------------------------------------------\n    private void writeObject(final ObjectOutputStream out) throws IOException {\n        out.defaultWriteObject();\n    }\n\n    private void readObject(final ObjectInputStream in) throws IOException, ClassNotFoundException {\n        in.defaultReadObject();\n        if (collectionClass.equals(String.class) || collectionClass.equals(Integer.class) ||\n                collectionClass.equals(Character.class) || collectionClass.equals(Long.class) ||\n                collectionClass.equals(Short.class) || collectionClass.equals(Byte.class) ||\n                collectionClass.equals(Float.class) || collectionClass.equals(Double.class) ||\n                collectionClass.equals(Boolean.class) ) {\n            throw new UnsupportedOperationException(\"Cannot use primitive value or wrapper value as a collection\");\n        }\n    }\n\n\n    //-----------------------------------------------------------------------\n\n    @Override\n    public boolean containsValue(final Object value) {\n        return super.containsValue(value);\n    }\n\n    @Override\n    public Object put(final K key, final Object value) {\n        Collection<V> coll = getCollection(key);\n        final Object previous = coll == null ? null : coll.size();\n        coll.add((V) value); // unsafe cast to V\n        return previous;\n    }\n\n\n\n    @Override\n    @SuppressWarnings(\"unchecked\")\n    public Collection<V> get(final Object key) {\n        return (Collection<V>) decorated().get(key); // unsafe cast to Collection<V>\n    }\n\n\n    @Override\n    public Collection<V> remove(final Object key) {\n        return (Collection<V>) decorated().remove(key); // unsafe cast to Collection<V>\n    }\n\n\n    /**\n     * Gets a collection containing all the values in the map.\n     * <p>\n     * The returned collection is not backed by the MultiValueMap, changes in\n     * the returned list will not affect the MultiValueMap.\n     *\n     * @return a collection view of the values contained in this map\n     */\n    @Override\n    public Collection<V> values() {\n        final Collection<V> vs = CollectionUtils.createCollection(null, size());\n        for (final Object coll : decorated().values()) {\n            vs.addAll((Collection<V>) coll); // unsafe cast\n        }\n        return vs;\n    }\n\n\n    /**\n     * Gets the collection mapped to the specified key. This method is a convenience\n     * method to avoid creating the collection if it doesn't exist.\n     *\n     * @param key  the key to get\n     * @return the collection at the key, or empty collection if not found\n     */\n    @SuppressWarnings(\"unchecked\")\n    private Collection<V> getCollection(final Object key) {\n        Collection<V> coll = (Collection<V>) decorated().get(key); // unsafe cast\n        if (coll == null) {\n            try {\n                coll = collectionClass.newInstance();\n            } catch (final InstantiationException | IllegalAccessException ex) {\n                // we couldn't create a new instance, probably a class with parameters.\n                // create something that will work but warn\n                coll = new ArrayList<>();\n            }\n            decorated().put(key, coll);\n        }\n        return coll;\n    }\n\n\n    @Override\n    @SuppressWarnings(\"unchecked\")\n    public int size() {\n        int size = 0;\n        for (final Object coll : decorated().values()) {\n            size += ((Collection<V>) coll).size(); // unsafe cast\n        }\n        return size;\n    }\n\n    @Override\n    public boolean isEmpty() {\n        boolean empty = true;\n        for (final Collection<?> coll : (Collection<Collection<?>>) decorated().values()) { // unsafe cast\n            if (!coll.isEmpty()) {\n                empty = false;\n                break;\n            }\n        }\n        return empty;\n    }\n\n\n    @Override\n    public void clear() {\n        decorated().clear();\n    }\n\n}\n",
    "exact_match": false,
    "ast_match": false,
    "compile": false,
    "test": false
}