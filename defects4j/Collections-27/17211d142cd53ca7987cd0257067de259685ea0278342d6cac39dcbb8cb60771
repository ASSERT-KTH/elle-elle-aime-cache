{
    "generation": "import java.io.ByteArrayInputStream;\nimport java.io.ByteArrayOutputStream;\nimport java.io.ObjectInputStream;\nimport java.io.ObjectOutputStream;\nimport java.io.Serializable;\nimport java.util.ArrayList;\nimport java.util.Collection;\nimport java.util.HashMap;\nimport java.util.Map;\n\nimport org.apache.commons.collections4.MultiMap;\nimport org.apache.commons.collections4.collection.UnmodifiableCollection;\n\npublic class MultiValueMap<K, V> extends AbstractMapDecorator<K, Object>\n        implements MultiMap<K, V>, Serializable {\n\n    /** Serialization version */\n    private static final long serialVersionUID = -221605611225708919L;\n\n    /** The collection class to use */\n    private final Class<? extends Collection> collectionClass;\n\n    /**\n     * Creates a new MultiValueMap using the supplied Map and the specified\n     * Collection class to create collections.\n     * <p>\n     * This constructor exists to allow the collection class to be controlled.\n     * If the map contains any entries at construction time, the supplied map must\n     * use collections created by the specified collection class.\n     *\n     * @param map  the map to decorate, must not be null\n     * @param collectionClass  the collection class to use, must not be null\n     * @throws NullPointerException if map or collectionClass is null\n     * @throws ClassCastException if the map contains any entries using non-compliant collections\n     */\n    public static <K, V> MultiValueMap<K, V> multiValueMap(final Map<K, Object> map,\n                                                        final Class<? extends Collection<V>> collectionClass) {\n        return new MultiValueMap<>(map, collectionClass);\n    }\n\n    /**\n     * Factory method to create a MultiValueMap using an ArrayList as the\n     * default collection.\n     *\n     * @param map  the map to decorate, must not be null\n     * @throws NullPointerException if map is null\n     * @return a new multi value map\n     */\n    public static <K, V> MultiValueMap<K, V> multiValueMap(final Map<K, Object> map) {\n        return new MultiValueMap<>(map);\n    }\n\n    /**\n     * Factory method to create an empty MultiValueMap.\n     *\n     * @return a new multi value map\n     */\n    public static <K, V> MultiValueMap<K, V> multiValueMap() {\n        return new MultiValueMap<>();\n    }\n\n    // -----------------------------------------------------------------------\n    /**\n     * Constructor.\n     *\n     * @param map  the map to decorate, must not be null\n     * @param collectionClass  the collection class to use, must not be null\n     * @throws NullPointerException if map or collectionClass is null\n     * @throws ClassCastException if the map contains any entries using non-compliant collections\n     */\n    protected MultiValueMap(final Map<K, Object> map, final Class<? extends Collection<V>> collectionClass) {\n        super(map);\n        if (collectionClass == null) {\n            throw new NullPointerException(\"Collection class must not be null\");\n        }\n        this.collectionClass = collectionClass;\n        checkValue(map);\n    }\n\n    /**\n     * Constructor that uses an ArrayList as the default collection.\n     *\n     * @param map  the map to decorate, must not be null\n     * @throws NullPointerException if map is null\n     */\n    protected MultiValueMap(final Map<K, Object> map) {\n        this(map, ArrayList.class);\n    }\n\n    /**\n     * Default constructor.\n     */\n    protected MultiValueMap() {\n        this(new HashMap<>(), ArrayList.class);\n    }\n\n    // -----------------------------------------------------------------------\n    /**\n     * Checks that the map contains only allowed value types.\n     * @param map  the map to check\n     * @throws ClassCastException if the map contains any entries using non-compliant collections\n     */\n    private void checkValue(final Map<?, ?> map) {\n        for (final Map.Entry<?, ?> entry : map.entrySet()) {\n            if (!(collectionClass.isInstance(entry.getValue()))) {\n                throw new ClassCastException(\"Map contains value that is not a \" + collectionClass.getName());\n            }\n        }\n    }\n\n\n    // -----------------------------------------------------------------------\n    @Override\n    public void clear() {\n        decorated().clear();\n    }\n\n    @Override\n    public boolean containsKey(final Object key) {\n        return decorated().containsKey(key);\n    }\n\n    @Override\n    public boolean containsValue(final Object value) {\n        for (final Collection<V> collection : getCollections()) {\n            if (collection.contains(value)) {\n                return true;\n            }\n        }\n        return false;\n    }\n\n    @Override\n    public Collection<Map.Entry<K, Object>> entrySet() {\n        return decorated().entrySet();\n    }\n\n\n    @Override\n    public Object get(final Object key) {\n        return decorated().get(key);\n    }\n\n    @Override\n    public boolean isEmpty() {\n        return decorated().isEmpty();\n    }\n\n    @Override\n    public Collection<K> keySet() {\n        return decorated().keySet();\n    }\n\n    @Override\n    public Object put(final K key, final Object value) {\n        return decorated().put(key, value);\n    }\n\n    @Override\n    public void putAll(final Map<? extends K, ?> map) {\n        for (final Map.Entry<? extends K, ?> entry : map.entrySet()) {\n            put(entry.getKey(), entry.getValue());\n        }\n    }\n\n\n    @Override\n    public Object remove(final Object key) {\n        return decorated().remove(key);\n    }\n\n    @Override\n    public int size() {\n        int total = 0;\n        for (final Object element : decorated().values()) {\n            total += ((Collection<?>) element).size();\n        }\n        return total;\n    }\n\n    @Override\n    public Collection<Object> values() {\n        final Collection<Object> allValues = new ArrayList<>();\n        for (final Object element : decorated().values()) {\n            allValues.addAll((Collection<?>) element);\n        }\n        return allValues;\n    }\n\n    // -----------------------------------------------------------------------\n    @Override\n    public Collection<V> getCollection(final Object key) {\n        return (Collection<V>) decorated().get(key);\n    }\n\n    @Override\n    public Collection<V> remove(final Object key, final Object item) {\n        final Collection<V> values = getCollection(key);\n        if (values == null) {\n            return null;\n        }\n        values.remove(item);\n        if (values.isEmpty()) {\n            remove(key);\n            return null;\n        }\n        return values;\n    }\n\n    @Override\n    public boolean removeMapping(final Object key, final Object item) {\n        final Collection<V> values = getCollection(key);\n        if (values == null) {\n            return false;\n        }\n        final boolean removed = values.remove(item);\n        if (values.isEmpty()) {\n            remove(key);\n        }\n        return removed;\n    }\n\n    // -----------------------------------------------------------------------\n    private Collection<Collection<V>> getCollections() {\n        return (Collection<Collection<V>>) decorated().values();\n    }\n\n\n    private void writeObject(final ObjectOutputStream oos) throws Exception {\n        oos.defaultWriteObject();\n        oos.writeObject(decorated());\n    }\n\n    private void readObject(final ObjectInputStream ois) throws Exception {\n        ois.defaultReadObject();\n        final Map<K, Object> map = (Map<K, Object>) ois.readObject();\n        if (!collectionClass.isAssignableFrom(ArrayList.class) && !collectionClass.equals(ArrayList.class)) { // ArrayList is allowed for deserialization\n            throw new UnsupportedOperationException(\"Unsafe collection class requested for deserialization\");\n        }\n        setMap(map);\n        checkValue(map);\n    }\n\n\n}\n",
    "exact_match": false,
    "ast_match": false,
    "compile": false,
    "test": false
}