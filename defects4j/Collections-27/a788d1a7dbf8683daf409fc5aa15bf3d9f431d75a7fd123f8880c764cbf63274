{
    "generation": "import java.io.IOException;\nimport java.io.ObjectInputStream;\nimport java.io.ObjectOutputStream;\nimport java.io.Serializable;\nimport java.util.Collection;\nimport java.util.HashMap;\nimport java.util.List;\nimport java.util.Map;\n\nimport org.apache.commons.collections4.CollectionUtils;\nimport org.apache.commons.collections4.Factory;\nimport org.apache.commons.collections4.MultiMap;\nimport org.apache.commons.collections4.Transformer;\nimport org.apache.commons.collections4.functors.ConstantFactory;\nimport org.apache.commons.collections4.functors.FactoryTransformer;\n\npublic class MultiValueMap<K, V> extends AbstractMapDecorator<K, Object>\n        implements MultiMap<K, V>, Serializable {\n\n    /** Serialization version */\n    private static final long serialVersionUID = -2214169818218989337L;\n\n    /** The factory to use to create the value collections */\n    private final Factory<? extends Collection<V>> collectionFactory;\n\n    /**\n     * Factory method to create a MultiValueMap using the supplied map and a default collection factory.\n     * <p>\n     *  The default factory creates an {@link ArrayList} if no value collection is present.\n     * </p>\n     * @param <K> the key type\n     * @param <V> the value type\n     * @param map  the map to decorate, must not be null\n     * @return a new MultiValueMap\n     * @throws NullPointerException if map is null\n     * @since 4.1\n     */\n    public static <K, V> MultiValueMap<K, V> multiValueMap(final Map<K, ? super Collection<V>> map) {\n        return multiValueMap(map, ArrayList.class);\n    }\n\n    /**\n     * Factory method to create a MultiValueMap using the supplied map and collection factory.\n     * @param <K> the key type\n     * @param <V> the value type\n     * @param map  the map to decorate, must not be null\n     * @param collectionFactory  the factory to use to create value collections, must not be null\n     * @return a new MultiValueMap\n     * @throws NullPointerException if map or collectionFactory is null\n     * @since 4.1\n     */\n    public static <K, V> MultiValueMap<K, V> multiValueMap(final Map<K, ? super Collection<V>> map,\n                                                          final Factory<? extends Collection<V>> collectionFactory) {\n        if (map == null) {\n            throw new NullPointerException(\"Map must not be null.\");\n        }\n        if (collectionFactory == null) {\n            throw new NullPointerException(\"CollectionFactory must not be null.\");\n        }\n        return new MultiValueMap<>(map, collectionFactory);\n    }\n\n    /**\n     * Factory method to create a MultiValueMap using the supplied map and collection class.\n     * @param <K> the key type\n     * @param <V> the value type\n     * @param map  the map to decorate, must not be null\n     * @param collectionClass  the class to use to create value collections, must not be null\n     * @return a new MultiValueMap\n     * @throws NullPointerException if map or collectionClass is null\n     * @since 4.1\n     */\n    public static <K, V> MultiValueMap<K, V> multiValueMap(final Map<K, ? super Collection<V>> map,\n                                                          final Class<? extends Collection<V>> collectionClass) {\n        if (collectionClass == null) {\n            throw new NullPointerException(\"CollectionClass must not be null.\");\n        }\n        return multiValueMap(map, new ReflectionCollectionFactory<>(collectionClass));\n    }\n\n    // -----------------------------------------------------------------------\n    /**\n     * Creates a new MultiValueMap based on a decorated map and a default collection factory.\n     * <p>\n     *  The default factory creates an {@link ArrayList} if no value collection is present.\n     * </p>\n     * @param map  the map to decorate, must not be null\n     * @throws NullPointerException if map is null\n     */\n    protected MultiValueMap(final Map<K, ? super Collection<V>> map) {\n        this(map, new ReflectionCollectionFactory<>(ArrayList.class));\n    }\n\n    /**\n     * Creates a new MultiValueMap based on a decorated map and a supplied collection factory.\n     * @param map  the map to decorate, must not be null\n     * @param collectionFactory  the factory to use to create value collections, must not be null\n     * @throws NullPointerException if map or collectionFactory is null\n     */\n    protected MultiValueMap(final Map<K, ? super Collection<V>> map, final Factory<? extends Collection<V>> collectionFactory) {\n        super(map);\n        if (collectionFactory == null) {\n            throw new NullPointerException(\"CollectionFactory must not be null.\");\n        }\n        this.collectionFactory = collectionFactory;\n    }\n\n    // -----------------------------------------------------------------------\n    private void writeObject(final ObjectOutputStream out) throws IOException {\n        out.defaultWriteObject();\n        out.writeObject(map);\n    }\n\n    private void readObject(final ObjectInputStream in) throws IOException, ClassNotFoundException {\n        in.defaultReadObject();\n        map = (Map<K, Object>) in.readObject();\n    }\n\n    // -----------------------------------------------------------------------\n    @Override\n    public boolean containsValue(final Object value) {\n        return values().contains(value);\n    }\n\n    @Override\n    public Collection<V> get(final K key) {\n        return wrappedCollection(key);\n    }\n\n    /**\n     * Gets a wrapped collection of values for the given key.\n     * @param key the key in question\n     * @return the wrapped collection of values\n     */\n    Collection<V> wrappedCollection(final Object key) {\n        return new WrappedCollection(key);\n    }\n\n    @Override\n    public int size() {\n        int size = 0;\n        for (final Object value : decorated().values()) {\n            size += CollectionUtils.size(value);\n        }\n        return size;\n    }\n\n    @Override\n    public boolean isEmpty() {\n        return size() == 0;\n    }\n\n\n    @Override\n    public Collection<V> remove(final Object key) {\n        return (Collection<V>) decorated().remove(key);\n    }\n\n\n    @Override\n    public void clear() {\n        decorated().clear();\n    }\n\n\n    @Override\n    public Collection<V> values() {\n        final Collection<Collection<V>> values = (Collection<Collection<V>>) decorated().values();\n        return new FlattenedValues(values);\n    }\n\n    @Override\n    public Collection<Map.Entry<K, V>> entries() {\n        // Although not strictly incorrect, the use of a MultiMap may not be the best choice\n        // for this implementation since it does not comply with the Map.Entry contract\n        // (equals doesn't take into account the collection). Is there a better way?\n        final List<Map.Entry<K, V>> entries = new java.util.ArrayList<>();\n\n        for (final Map.Entry<K, Object> entry : decorated().entrySet()) {\n            final K key = entry.getKey();\n            for (final V value : (Collection<V>) entry.getValue()) {\n                entries.add(new Map.Entry<K, V>() {\n                    @Override\n                    public K getKey() {\n                        return key;\n                    }\n\n                    @Override\n                    public V getValue() {\n                        return value;\n                    }\n\n                    @Override\n                    public V setValue(final V value) {\n                        throw new UnsupportedOperationException();\n                    }\n\n                    @Override\n                    public int hashCode() {\n                        return (getKey() == null ? 0 : getKey().hashCode()) ^\n                               (getValue() == null ? 0 : getValue().hashCode());\n                    }\n\n                    @Override\n                    public boolean equals(final Object obj) {\n                        if (this == obj) {\n                            return true;\n                        }\n                        if (obj == null || !(obj instanceof Map.Entry)) {\n                            return false;\n                        }\n\n                        final Map.Entry other = (Map.Entry) obj;\n                        return (\n                                (getKey() == null ? other.getKey() == null : getKey().equals(other.getKey())) &&\n                                        (getValue() == null ? other.getValue() == null : getValue().equals(other.getValue())));\n                    }\n                });\n            }\n        }\n        return entries;\n    }\n\n    @Override\n    public void putAll(final Map<? extends K, ? extends V> map) {\n        for (final Map.Entry<? extends K, ? extends V> entry : map.entrySet()) {\n            put(entry.getKey(), entry.getValue());\n        }\n    }\n\n\n    // -----------------------------------------------------------------------\n    @Override\n    public boolean put(final K key, final V value) {\n        Collection<V> coll = get(key);\n\n        if (coll == null) {\n            coll = createCollection(1);\n            decorated().put(key, coll);\n        }\n\n        return coll.add(value);\n    }\n\n\n    /**\n     * Creates a new instance of the value collection, as returned by the {@link #collectionFactory}\n     * if no value collection exists for the given key.\n     * @param size the anticipated size of the collection\n     * @return a new collection instance\n     */\n    protected Collection<V> createCollection(final int size) {\n        return collectionFactory.create();\n    }\n\n    /**\n     * The collection wrapper class.\n     */\n    class WrappedCollection implements Collection<V>, Serializable {\n        /** Serialization version */\n        private static final long serialVersionUID = 5126599380359097760L;\n\n        /** The key to get the values from */\n        protected final Object key;\n\n        /**\n         * Constructor.\n         * @param key  the key\n         */\n        WrappedCollection(final Object key) {\n            this.key = key;\n        }\n\n        //-----------------------------------------------------------------------\n        @Override\n        public boolean add(final V value) {\n            Collection<V> coll = (Collection<V>) decorated().get(key);\n            if (coll == null) {\n                coll = createCollection(1);\n                decorated().put(key, coll);\n            }\n            return coll.add(value);\n        }\n\n        @Override\n        public boolean addAll(final Collection<? extends V> values) {\n            Collection<V> coll = (Collection<V>) decorated().get(key);\n            if (coll == null) {\n                coll = createCollection(values.size());\n                decorated().put(key, coll);\n            }\n            return coll.addAll(values);\n        }\n\n        @Override\n        public void clear() {\n            final Collection<V> coll = (Collection<V>) decorated().get(key);\n            if (coll != null) {\n                coll.clear();\n            }\n        }\n\n        @Override\n        public boolean contains(final Object o) {\n            final Collection<V> coll = (Collection<V>) decorated().get(key);\n            return coll == null ? false : coll.contains(o);\n        }\n\n        @Override\n        public boolean containsAll(final Collection<?> c) {\n            final Collection<V> coll = (Collection<V>) decorated().get(key);\n            return coll == null ? false : coll.containsAll(c);\n        }\n\n        @Override\n        public boolean isEmpty() {\n            final Collection<V> coll = (Collection<V>) decorated().get(key);\n            return coll == null ? true : coll.isEmpty();\n        }\n\n        @Override\n        public Iterator<V> iterator() {\n            final Collection<V> coll = (Collection<V>) decorated().get(key);\n            if (coll == null) {\n                return IteratorUtils.emptyIterator();\n            }\n            return coll.iterator();\n        }\n\n        @Override\n        public boolean remove(final Object o) {\n            final Collection<V> coll = (Collection<V>) decorated().get(key);\n            return coll == null ? false : coll.remove(o);\n        }\n\n        @Override\n        public boolean removeAll(final Collection<?> c) {\n            final Collection<V> coll = (Collection<V>) decorated().get(key);\n            return coll == null ? false : coll.removeAll(c);\n        }\n\n        @Override\n        public boolean retainAll(final Collection<?> c) {\n            final Collection<V> coll = (Collection<V>) decorated().get(key);\n            return coll == null ? false : coll.retainAll(c);\n        }\n\n        @Override\n        public int size() {\n            final Collection<V> coll = (Collection<V>) decorated().get(key);\n            return coll == null ? 0 : coll.size();\n        }\n\n        @Override\n        public Object[] toArray() {\n            final Collection<V> coll = (Collection<V>) decorated().get(key);\n            return coll == null ? new Object[0] : coll.toArray();\n        }\n\n        @Override\n        public <T> T[] toArray(final T[] a) {\n            final Collection<V> coll = (Collection<V>) decorated().get(key);\n            return coll == null ? a : coll.toArray(a);\n        }\n\n        @Override\n        public String toString() {\n            final Collection<V> coll = (Collection<V>) decorated().get(key);\n            return coll == null ? \"[null]\" : coll.toString();\n        }\n    }\n\n    /**\n     * The value collection returned by {@code values()}.\n     */\n    class FlattenedValues extends AbstractCollection<V> implements Serializable {\n        /** Serialization version */\n        private static final long serialVersionUID = -3756982536071129669L;\n\n        /** The values */\n        private final Collection<Collection<V>> values;\n\n\n        /**\n         * Constructor.\n         */\n        FlattenedValues(final Collection<Collection<V>> values) {\n            this.values = values;\n        }\n\n        @Override\n        public Iterator<V> iterator() {\n            final Transformer<Collection<V>, Iterator<V>> transformer =\n                    input -> input == null ? null : input.iterator();\n            return IteratorUtils.chainedIterator(\n                CollectionUtils.collect(values, transformer).iterator());\n        }\n\n\n        @Override\n        public int size() {\n            int size = 0;\n            for (final Collection<V> element : values) {\n                size += CollectionUtils.size(element);\n            }\n            return size;\n        }\n\n        @Override\n        public void clear() {\n            // As per clear contract, only remove if not null.\n            for (final Collection<V> value : values) {\n                if(value != null) {\n                    value.clear();\n                }\n            }\n        }\n    }\n\n    /**\n     * Inner class to create collection using reflection.\n     *\n     * @since 4.1\n     */\n    private static class ReflectionCollectionFactory<T extends Collection<?>> implements Factory<T>, Serializable {\n\n        /** Serialization version */\n        private static final long serialVersionUID = 2998173130757875740L;\n\n        /** Collection class */\n        private final Class<T> collectionClass;\n\n        /**\n         * Constructor that performs checks against supplied class.\n         * @param collectionClass  the class to create using reflection, must not be null\n         * @throws NullPointerException if collectionClass is null\n         * @throws IllegalArgumentException if collectionClass is abstract or doesn't implement Collection or Serializable\n         */\n        ReflectionCollectionFactory(final Class<T> collectionClass) {\n            if (collectionClass == null) {\n                throw new NullPointerException(\"Collection class must not be null.\");\n            }\n            if (collectionClass.isInterface() || collectionClass.isMemberClass() && !java.lang.reflect.Modifier.isStatic(collectionClass.getModifiers())) {\n                throw new IllegalArgumentException(\"Collection class must not be an interface or non-static inner class.\");\n            }\n            if (!Collection.class.isAssignableFrom(collectionClass)) {\n                throw new IllegalArgumentException(\"Collection class must implement Collection.\");\n            }\n            if (!Serializable.class.isAssignableFrom(collectionClass)) {\n                throw new IllegalArgumentException(\"Collection class must implement Serializable.\");\n            }\n            this.collectionClass = collectionClass;\n        }\n\n        @Override\n        public T create() {\n            try {\n                return collectionClass.newInstance();\n            } catch (final InstantiationException e) {\n                throw new IllegalArgumentException(\"Collection class must have a public no-arg constructor.\", e);\n            } catch (final IllegalAccessException e) {\n                throw new IllegalArgumentException(\"Collection class constructor must be public.\", e);\n            }\n        }\n\n        private void readObject(final ObjectInputStream is) throws IOException, ClassNotFoundException {\n            is.defaultReadObject();\n\n            // perform checks again when deserializing the factory\n            if (collectionClass == null) {\n                throw new NullPointerException(\"Collection class must not be null.\");\n            }\n            if (collectionClass.isInterface() || collectionClass.isMemberClass() && !java.lang.reflect.Modifier.isStatic(collectionClass.getModifiers())) {\n                throw new IllegalArgumentException(\"Collection class must not be an interface or non-static inner class.\");\n            }\n            if (!Collection.class.isAssignableFrom(collectionClass)) {\n                throw new IllegalArgumentException(\"Collection class must implement Collection.\");\n            }\n            if (!Serializable.class.isAssignableFrom(collectionClass)) {\n                throw new IllegalArgumentException(\"Collection class must implement Serializable.\");\n            }\n        }\n    }\n}\n",
    "exact_match": false,
    "ast_match": false,
    "compile": false,
    "test": false
}