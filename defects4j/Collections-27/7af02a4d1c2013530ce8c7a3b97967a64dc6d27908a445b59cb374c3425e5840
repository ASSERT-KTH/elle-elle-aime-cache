{
    "generation": "import java.util.Collection;\nimport java.util.Map;\n\nimport java.io.IOException;\nimport java.io.ObjectInputStream;\nimport java.io.ObjectOutputStream;\nimport java.io.Serializable;\n\n/**\n * @author Matt Hall, John Watkinson, Stephen Colebourne\n */\npublic class MultiValueMap<K, V> extends AbstractMapDecorator<K, Collection<V>>\n        implements MultiValuedMap<K, V>, Serializable, Cloneable {\n\n    /** Serialization version */\n    private static final long serialVersionUID = -2210278786587386284L;\n\n    //-----------------------------------------------------------------------\n    /**\n     * Factory method to create a MultiValueMap using the supplied map to hold the values.\n     * <p>\n     * If the map is null, a HashMap is used.\n     *\n     * @param <K>  the key type\n     * @param <V>  the value type\n     * @param map  the map to use\n     * @return a new multi value map\n     * @since 4.0\n     */\n    public static <K, V> MultiValueMap<K, V> multiValueMap(final Map<K, ? super Collection<V>> map) {\n        return multiValueMap(map, ArrayList.class);\n    }\n\n    /**\n     * Factory method to create a MultiValueMap using the supplied map to hold the values, and the specified\n     * collection class to use.\n     * <p>\n     * If the map is null, a HashMap is used.\n     *\n     * @param <K>  the key type\n     * @param <V>  the value type\n     * @param map  the map to use\n     * @param collectionClass  the collection class\n     * @return a new multi value map\n     * @throws NullPointerException if collectionClass is null\n     * @since 4.0\n     */\n    public static <K, V> MultiValueMap<K, V> multiValueMap(final Map<K, ? super Collection<V>> map, final Class<? extends Collection<V>> collectionClass) {\n        if (collectionClass == null) {\n            throw new NullPointerException(\"collectionClass must not be null\");\n        }\n        if (map == null) {\n            return new MultiValueMap<>(new HashMap<K, Collection<V>>(), collectionClass);\n        }\n        return new MultiValueMap<>(map, collectionClass);\n    }\n\n    //-----------------------------------------------------------------------\n    /** The factory to create empty collection instances. */\n    private final transient Class<? extends Collection<V>> collectionClass;\n\n    /**\n     * Constructor that wraps (not copies).\n     *\n     * @param map  the map to decorate, must not be null\n     * @param collectionClass  the collection class to use, must not be null\n     * @throws NullPointerException if map is null\n     */\n    protected MultiValueMap(final Map<K, ? super Collection<V>> map, final Class<? extends Collection<V>> collectionClass) {\n        super(map);\n        if (collectionClass == null) {\n            throw new NullPointerException(\"collectionClass must not be null\");\n        }\n        this.collectionClass = collectionClass;\n    }\n\n    /**\n     * Constructor that wraps (not copies).\n     *\n     * @param map  the map to decorate, must not be null\n     * @throws NullPointerException if map is null\n     */\n    protected MultiValueMap(final Map<K, ? super Collection<V>> map) {\n        super(map);\n        this.collectionClass = ArrayList.class;\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Write the map out using a custom routine.\n     *\n     * @param out  the output stream\n     * @throws IOException if an error occurs\n     */\n    private void writeObject(final ObjectOutputStream out) throws IOException {\n        out.defaultWriteObject();\n        out.writeObject(map);\n    }\n\n    /**\n     * Read the map in using a custom routine.\n     *\n     * @param in the input stream\n     * @throws IOException if an error occurs\n     * @throws ClassNotFoundException if an error occurs\n     */\n    @SuppressWarnings(\"unchecked\") // (1) should only fail if collectionClass is incorrect\n    private void readObject(final ObjectInputStream in) throws IOException, ClassNotFoundException {\n        in.defaultReadObject();\n        map = (Map<K, Collection<V>>) in.readObject();\n        if (!(collectionClass.isAssignableFrom(ArrayList.class) || collectionClass.isAssignableFrom(HashSet.class) ||\n              collectionClass.isAssignableFrom(LinkedList.class) || collectionClass.isAssignableFrom(TreeSet.class))) {\n            // (1)\n            throw new UnsupportedOperationException(\"Unexpected collection class: \" + collectionClass.getName());\n        }\n    }\n\n    //-----------------------------------------------------------------------\n    @Override\n    public boolean containsValue(final Object value) {\n        for (final Collection<V> collection : decorated().values()) {\n            if (collection.contains(value)) {\n                return true;\n            }\n        }\n        return false;\n    }\n\n    @Override\n    public Collection<V> get(final Object key) {\n        Collection<V> collection = decorated().get(key);\n        if (collection == null) {\n            collection = createCollection(1);\n            decorated().put((K) key, collection); // decorated() ensures cast is not useless\n        }\n        return collection;\n    }\n\n    /**\n     * Removes all values associated with the specified key.\n     * <p>\n     * This implementation returns {@code null}. If the collection is a\n     * {@code List}, then the {@link List#clear()} method is called.\n     *\n     * @param key  the key to remove values from\n     * @return null, the previous value associated with the key\n     */\n    @Override\n    public Collection<V> remove(final Object key) {\n        final Collection<V> values = decorated().remove(key);\n        if (values != null) {\n            values.clear();\n        }\n        return values;\n    }\n\n    //-----------------------------------------------------------------------\n    @Override\n    public boolean putAll(final Map<? extends K, ? extends V> mapToCopy) {\n        boolean changed = false;\n        for (final Map.Entry<? extends K, ? extends V> entry : mapToCopy.entrySet()) {\n            changed |= put(entry.getKey(), entry.getValue());\n        }\n        return changed;\n    }\n\n    @Override\n    public Collection<V> values() {\n        final Collection<V> allValues = createCollection(size());\n        for (final Collection<V> values : decorated().values()) {\n            allValues.addAll(values);\n        }\n        return allValues;\n    }\n\n    /**\n     * Gets the total size of the collection, which is the number of values.\n     *\n     * @return the total size of the collection\n     */\n    @Override\n    public int size() {\n        int total = 0;\n        for (final Collection<V> collection : decorated().values()) {\n            total += collection.size();\n        }\n        return total;\n    }\n\n    /**\n     * Clears the map, removing all entries.\n     */\n    @Override\n    public void clear() {\n        // For speed, only clear the values of the map if necessary\n        if (isEmpty() == false) {\n            for (final Collection<V> collection : decorated().values()) {\n                collection.clear();\n            }\n        }\n        decorated().clear();\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Adds the value to the collection associated with the specified key.\n     * <p>\n     * Unlike a normal map, this method returns {@code true} if the value\n     * was added, not if the entry was changed.\n     *\n     * @param key  the key to store to\n     * @param value  the value to store\n     * @return true if the collection changed\n     */\n    @Override\n    public boolean put(final K key, final V value) {\n        Collection<V> values = get(key);\n        return values.add(value);\n    }\n\n    /**\n     * Adds a collection of values to the collection associated with the specified key.\n     *\n     * @param key  the key to store to\n     * @param values  the values to store, may be null\n     * @return true if the collection changed\n     */\n    @Override\n    public boolean putAll(final K key, final Collection<V> values) {\n        if (values == null || values.size() == 0) {\n            return false;\n        }\n        final Collection<V> coll = get(key);\n        return coll.addAll(values);\n    }\n\n    @Override\n    public boolean remove(final Object key, final Object value) {\n        final Collection<V> values = decorated().get(key);\n        if (values == null) {\n            return false;\n        }\n        final boolean result = values.remove(value);\n        if (values.isEmpty()) {\n            decorated().remove(key);\n        }\n        return result;\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Creates a new instance of the collection this multi-value map will use.\n     *\n     * @param size  the collection size\n     * @return a new empty collection instance\n     */\n    protected Collection<V> createCollection(final int size) {\n        if (size <= 0) {\n            return createCollection();\n        }\n        try {\n            final Constructor<? extends Collection<V>> constructor = collectionClass.getDeclaredConstructor(Integer.TYPE);\n            return constructor.newInstance(size);\n        } catch (final NoSuchMethodException ex) {\n            // ignore\n        } catch (final IllegalAccessException ex) {\n            // ignore\n        } catch (final InstantiationException ex) {\n            // ignore\n        } catch (final InvocationTargetException ex) {\n            // ignore\n        }\n        // Failed to create with size, return default\n        return createCollection();\n    }\n\n    /**\n     * Creates a new instance of the collection this multi-value map will use.\n     *\n     * @return a new empty collection instance\n     */\n    protected Collection<V> createCollection() {\n        try {\n            return collectionClass.newInstance();\n        } catch (final IllegalAccessException ex) {\n            throw new IllegalArgumentException(\"The collection class \" + collectionClass.getName() +\n                \" must have a public no-arg constructor\", ex);\n        } catch (final InstantiationException ex) {\n            throw new IllegalArgumentException(\"The collection class \" + collectionClass.getName() +\n                \" must not be abstract\", ex);\n        }\n    }\n\n    /**\n     * Clones the map giving a shallow copy.\n     *\n     * @return a shallow copy\n     */\n    @Override\n    public Object clone() {\n        return new MultiValueMap<>(this);\n    }\n\n}",
    "exact_match": false,
    "ast_match": false,
    "compile": false,
    "test": false
}