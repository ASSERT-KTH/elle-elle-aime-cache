{
    "generation": "/**\n * Create an archive input stream from an input stream, autodetecting\n * the archive type from the first few bytes of the stream. The InputStream\n * must support marks, like BufferedInputStream.\n * \n * @param in the input stream\n * @return the archive input stream\n * @throws ArchiveException if the archiver name is not known\n * @throws IllegalArgumentException if the stream is null or does not support mark\n */\npublic ArchiveInputStream createArchiveInputStream(final InputStream in)\n        throws ArchiveException {\n    if (in == null) {\n        throw new IllegalArgumentException(\"Stream must not be null.\");\n    }\n\n    if (!in.markSupported()) {\n        throw new IllegalArgumentException(\"Mark is not supported.\");\n    }\n\n    final byte[] signature = new byte[12];\n    in.mark(signature.length);\n    try {\n        int signatureLength = in.read(signature);\n        in.reset();\n        if (ZipArchiveInputStream.matches(signature, signatureLength)) {\n            return new ZipArchiveInputStream(in);\n        } else if (JarArchiveInputStream.matches(signature, signatureLength)) {\n            return new JarArchiveInputStream(in);\n        } else if (ArArchiveInputStream.matches(signature, signatureLength)) {\n            return new ArArchiveInputStream(in);\n        } else if (CpioArchiveInputStream.matches(signature, signatureLength)) {\n            return new CpioArchiveInputStream(in);\n        }\n\n        // Dump needs a bigger buffer to check the signature;\n        final byte[] dumpsig = new byte[32];\n        in.mark(dumpsig.length);\n        signatureLength = in.read(dumpsig);\n        in.reset();\n        if (DumpArchiveInputStream.matches(dumpsig, signatureLength)) {\n            return new DumpArchiveInputStream(in);\n        }\n\n        // Tar needs an even bigger buffer to check the signature; read the first block\n        final byte[] tarheader = new byte[512];\n        in.mark(tarheader.length);\n        signatureLength = in.read(tarheader);\n        in.reset();\n        if (TarArchiveInputStream.matches(tarheader, signatureLength)) {\n            try {\n                TarArchiveInputStream tais = new TarArchiveInputStream(new ByteArrayInputStream(tarheader));\n                tais.getNextEntry();\n                return new TarArchiveInputStream(in);\n            } catch (Exception e) { \n                // Ignore and continue to the final check\n            }\n        } \n        // Additional check to ensure non-archive streams are not mistakenly identified\n        if (signatureLength < signature.length) {\n            // Stream is too short to be a valid archive\n            throw new ArchiveException(\"No Archiver found for the stream signature\");\n        }\n        // Check if the stream starts with a plausible text file content rather than an archive signature\n        if (looksLikeText(signature, signatureLength)) {\n            throw new ArchiveException(\"No Archiver found for the stream signature\");\n        }\n\n        throw new ArchiveException(\"No Archiver found for the stream signature\");\n    } catch (IOException e) {\n        throw new ArchiveException(\"Could not use reset and mark operations.\", e);\n    }\n}\n\n// Helper method to check if the signature resembles text file content\nprivate boolean looksLikeText(byte[] signature, int length) {\n    int nonTextBytes = 0;\n    for (int i = 0; i < length; i++) {\n        byte b = signature[i];\n        if (b < 9 || b == 127 || (b >= 14 && b <= 31) || b >= 128) {\n            nonTextBytes++;\n            if (nonTextBytes > length / 2) {\n                return false; // More than half are non-text, likely not text\n            }\n        }\n    }\n    return true; // Looks like text, not an archive\n}",
    "exact_match": false,
    "ast_match": false,
    "compile": true,
    "test": false
}