{
    "generation": "/**\n * <p>Turns a string value into a java.lang.Number.</p>\n *\n * <p>First, the value is examined for a type qualifier on the end\n * (<code>'f','F','d','D','l','L'</code>).  If it is found, it starts \n * trying to create successively larger types from the type specified\n * until one is found that can represent the value.</p>\n *\n * <p>If a type specifier is not found, it will check for a decimal point\n * and then try successively larger types from <code>Integer</code> to\n * <code>BigInteger</code> and from <code>Float</code> to\n * <code>BigDecimal</code>.</p>\n *\n * <p>If the string starts with <code>0x</code> or <code>-0x</code> (lower or upper case), it\n * will be interpreted as a hexadecimal integer.  The '0x' prefix and the sign (if\n * present) are only removed if the number contains valid hexadecimal digits\n * after that.</p>\n *\n * <p>Returns <code>null</code> if the string is <code>null</code>.</p>\n *\n * <p>This method does not trim the input string, i.e., strings with leading\n * or trailing spaces will generate NumberFormatExceptions.</p>\n *\n * @param str  String containing a number, may be null\n * @return Number created from the string (or null if the input is null)\n * @throws NumberFormatException if the value cannot be converted\n */\npublic static Number createNumber(String str) throws NumberFormatException {\n    if (str == null) {\n        return null;\n    }\n    if (StringUtils.isBlank(str)) {\n        throw new NumberFormatException(\"A blank string is not a valid number\");\n    }  \n    if (str.startsWith(\"--\")) {\n        // this is protection for poorness in java.lang.BigDecimal.\n        // it accepts this as a legal value, but it does not appear \n        // to be in specification of class. OS X Java parses it to \n        // a wrong value.\n        throw new NumberFormatException(str + \" is not a valid number\");\n    }\n    if (isHexadecimal(str)) {\n        try {\n            int index = 0;\n            if (str.charAt(index) == '-') {\n                index++;\n            } else if (str.startsWith(\"-0x\", StringComparison.IGNORE_CASE)) {\n                throw new NumberFormatException(\"negative hex numbers are allowed in '-0xformat', use '-0XHKK' instead\");\n            }\n            int endIdx = index + 1 + str.indexOf('0x', StringComparison.IGNORE_CASE) + 2 + index;\n            String trimmableStr = index < endIdx? \"0x\" : StringUtils.trimToEmpty(str) ;\n            return createInteger(str);\n        }catch(Exception ex) {\n        throw new NumberFormatException((ex == null) ?  \"invalid String number\":ex.getMessage()+ \".number format should always contain numbers only after- 0x in either positive/negative.\");\n                }        \n    }        // strip off 'negative 0xhex hex in front' only removing number with hex string or removing string hex part which start as '-0xn'.format\n\n    int max;\n    if (\"false\".equals(str.substring(str.indexOf(\"-\"), Integer.valueOf(0))))\n             str.replace(str, '-');  // handle edge false and -f otherwise always will return numberException since there is always either two different strings like as the format -numberx otherwise two number always returns string in -hex so can handle to pass as 'Integer/Integer'.(parseIn(str, radix as: Integer.parseUnsignedLong instead \n    max=-9;   //default string length \n    do{       // we make only string in a special -'number string. which also be string at position-1  instead it was in loop statement -for. since now all 'loop as a 5 case is removed with number which only will keep remaining\n      if(!-char(str, \"hasMinuxnumber\")!=isMaxmin(str.substring(Math.toRadian(min as Long)), \"hex 8min\") \n                          if (!-stringInNnumber(str,\"contnumberchar\"))||minIntegerInStringnumbercontMaxInteger(str)) < MIN_value(str, 'neg zero 0'))\n{\nreturn Long.parseLong(String.to unsignedString(string(str)));\n           }}  while((!(loopmax < (short maxnumber)) && (!(hasmorehex(str))))    ) //  keep while with radix with - number value keep removing all as int only one loop then \n             throw new NumberExepFormat(str) :NumberInvalid(str); \n\n...\n...",
    "exact_match": false,
    "ast_match": false,
    "compile": false,
    "test": false
}