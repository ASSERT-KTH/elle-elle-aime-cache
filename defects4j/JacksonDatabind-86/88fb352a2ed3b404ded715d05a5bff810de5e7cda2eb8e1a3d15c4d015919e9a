{
    "generation": "package com.fasterxml.jackson.databind.type;\n\nimport java.lang.reflect.TypeVariable;\nimport java.util.*;\n\nimport com.fasterxml.jackson.databind.JavaType;\n\n/**\n * Base class for type implementations, which must implement\n * {@link JavaType} as well as {@link Type}.\n */\npublic abstract class TypeBase\n    extends JavaType\n    implements Type\n{\n    private static final long serialVersionUID = 2;\n\n    protected final TypeFactory _typeFactory;\n\n    protected final JavaType _superClass;\n\n    protected final JavaType[] _superInterfaces;\n\n    protected final JavaType[] _typeParameters;\n\n    /**\n     * Cached hash code, since it is sometimes needed for comparison.\n     */\n    protected int _hashCode;\n\n    protected TypeBase(Class<?> raw, int hash, TypeFactory tf,\n            JavaType superClass, JavaType[] superInts, JavaType[] typeParams)\n    {\n        super(raw, hash);\n        _typeFactory = tf;\n        _superClass = superClass;\n        _superInterfaces = superInts;\n        _typeParameters = typeParams;\n    }\n\n    @Override\n    public abstract StringBuilder getGenericSignature(StringBuilder sb);\n\n    @Override\n    public abstract StringBuilder getErasedSignature(StringBuilder sb);\n\n    @Override\n    public String getGenericSignature() {\n        StringBuilder sb = new StringBuilder(40);\n        getGenericSignature(sb);\n        return sb.toString();            \n    }\n    \n    @Override\n    public String getErasedSignature() {\n        StringBuilder sb = new StringBuilder(40);\n        getErasedSignature(sb);\n        return sb.toString();\n    }\n    \n    @Override\n    public JavaType getSuperClass() { return _superClass; }\n\n    @Override\n    public List<JavaType> getInterfaces() {\n        if (_superInterfaces == null) {\n            return Collections.emptyList();\n        }\n        switch (_superInterfaces.length) {\n        case 0:\n            return Collections.emptyList();\n        case 1:\n            return Collections.singletonList(_superInterfaces[0]);\n        }\n        return Arrays.asList(_superInterfaces);\n    }\n\n    @Override\n    public final List<JavaType> getBindings() {\n        if (_typeParameters == null || _typeParameters.length == 0) {\n            return Collections.emptyList();\n        }\n        return Arrays.asList(_typeParameters);\n    }\n\n    @Override\n    public JavaType findSuperType(Class<?> rawTarget) {\n        if (rawTarget == _class) {\n            return this;\n        }\n        if (rawTarget.isInterface()) {\n            if (_superInterfaces != null) {\n                for (JavaType it : _superInterfaces) {\n                    JavaType type = it.findSuperType(rawTarget);\n                    if (type != null) {\n                        return type;\n                    }\n                }\n            }\n        } else if (_superClass != null) {\n            JavaType type = _superClass.findSuperType(rawTarget);\n            if (type != null) {\n                return type;\n            }\n        }\n        return null;\n    }\n    \n    @Override\n    public <T> T getBindingsAsArray() {\n        return (T) _typeParameters;\n    }\n\n    @Override\n    public final JavaType findTypeParameters(Class<?> expType)\n    {\n        JavaType match = findSuperType(expType);\n        if (match != null) {\n            return match.getBindingsAsArray();\n        }\n        return null;\n    }\n\n    @Override\n    @Deprecated // since 2.7\n    public JavaType[] findTypeParameters(Class<?> expType, TypeBindings context) {\n        return findTypeParameters(expType);\n    }\n\n    /**\n     * Method for accessing simple type parameters, in cases where the number\n     * of parameters is known to be fixed and non-zero.\n     * This should work for most cases, although ideally we'd improve\n     * type resolution mechanism to be able to handle other cases as well.\n     *<p>\n     * Note that starting with version 1.6, this method returns the\n     * first type parameter for Collection- and Map- types, regardless of\n     * actual declared type parameters. This is done as a kind of \"hack\"\n     * to compensate for common use case where type is accessed and explicit\n     * cast is done (often to Object or String), and thereby masking the\n     * underlying problem that Jackson won't necessarily have type information\n     * about contents\n     *\n     * @deprecated Since 2.7 call {@link #getBinding(int)} instead, using the type's contained type\n     */\n    @Deprecated\n    public final JavaType containedType(int index) {\n        if (index < 0 || _typeParameters == null || index >= _typeParameters.length) {\n            return null;\n        }\n        return _typeParameters[index];\n    }\n\n    /**\n     * Alias for {@link #containedType(int)}, for backwards compatibility\n     *\n     * @deprecated Since 2.7 call {@link #getBinding(int)} instead, using the type's contained type\n     */\n    @Deprecated\n    public final JavaType getContentType() {\n        if (_typeParameters == null || _typeParameters.length == 0) {\n            return null;\n        }\n        return _typeParameters[0];\n    }\n\n    /**\n     * Alias for {@link #containedType(int)}, for backwards compatibility\n     *\n     * @deprecated Since 2.7 call {@link #getBinding(int)} instead, using the type's contained type\n     */\n    @Deprecated\n    public final JavaType getKeyType() {\n        if (_typeParameters == null || _typeParameters.length < 1) {\n            return null;\n        }\n        // Quite a few oddities wrt Map/Collection: ideally we'd check declaration...\n        return _typeParameters[0];\n    }\n\n    @Override\n    public TypeFactory getTypeFactory() {\n        return _typeFactory;\n    }\n\n    @Override\n    public JavaType getReferencedType() { return null; }\n\n    @Override\n    public int containedTypeCount() {\n        return (_typeParameters == null) ? 0 : _typeParameters.length;\n    }\n\n    @Override\n    public JavaType containedType(int index) {\n        if (index < 0 || _typeParameters == null || index >= _typeParameters.length) {\n            return null;\n        }\n        return _typeParameters[index];\n    }\n    \n    @Override\n    public String toString()\n    {\n        StringBuilder sb = new StringBuilder(40).append(\"[type: \");\n        sb.append(buildCanonicalName());\n        if (_typeParameters != null && _typeParameters.length > 0) {\n            sb.append('<');\n            boolean first = true;\n            for (JavaType param : _typeParameters) {\n                if (first) {\n                    first = false;\n                } else {\n                    sb.append(',');\n                }\n                sb.append(param.getGenericSignature());\n            }\n            sb.append('>');\n        }\n        sb.append(']');\n        return sb.toString();\n    }\n\n    protected String buildCanonicalName() {\n        String name = _class.getName();\n        if (_typeParameters != null && _typeParameters.length > 0) {\n            StringBuilder sb = new StringBuilder(name);\n            sb.append('<');\n            for (int i = 0, len = _typeParameters.length; i < len; ++i) {\n                JavaType t = _typeParameters[i];\n                if (i > 0) {\n                    sb.append(',');\n                }\n                sb.append(t.toCanonical());\n            }\n            sb.append('>');\n            name = sb.toString();\n        }\n        return name;\n    }\n\n    @Override\n    public boolean equals(Object o)\n    {\n        if (o == this) return true;\n        if (o == null) return false;\n        if (o.getClass() != getClass()) return false;\n\n        TypeBase other = (TypeBase) o;\n\n        if (_class != other._class) { return false; }\n        // Might want to improve efficiency here in future, but for now,\n        // simplest to use \"naive\" approach\n        if (_hashCode != other._hashCode) {\n            return false;\n        }\n\n        // but let's avoid recomputing if possible\n        int len = _typeParameters.length;\n        if (len != other._typeParameters.length) {\n            return false;\n        }\n\n        JavaType sup1 = getSuperClass();\n        JavaType sup2 = other.getSuperClass();\n        if (sup1 == null) {\n            if (sup2 != null) return false;\n        } else if (sup2 == null || !sup1.equals(sup2)) {\n            return false;\n        }\n\n        // and finally, ensure type parameters are compatible\n        for (int i = 0; i < len; ++i) {\n            if (!(_typeParameters[i].equals(other._typeParameters[i]))) {\n                return false;\n            }\n        }\n        return true;\n    }\n\n    @Override\n    public int hashCode() { return _hashCode; }\n\n    protected JavaType _narrow(Class<?> subclass)\n    {\n        // Might need to change this behavior in future -- but for now assumed that\n        // type parameters should remain as is\n        return new SimpleType(subclass, _typeParameters, _superClass, _superInterfaces,\n                _hashCode, _typeFactory, null);\n    }    \n}",
    "exact_match": false,
    "ast_match": false,
    "compile": false,
    "test": false
}