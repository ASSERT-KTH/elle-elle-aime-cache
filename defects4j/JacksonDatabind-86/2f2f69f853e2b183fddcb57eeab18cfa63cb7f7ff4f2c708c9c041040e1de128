{
    "generation": "import java.util.HashMap;\nimport java.util.Map;\n\nimport com.fasterxml.jackson.databind.JavaType;\nimport com.fasterxml.jackson.databind.type.TypeBindings;\nimport com.fasterxml.jackson.databind.type.TypeFactory;\n\npublic class RecursiveType extends JavaType {\n    private static final long serialVersionUID = 1L;\n\n    /**\n     * Placeholder used before actual type is resolved.\n     */\n    protected final Class<?> _placeholder;\n\n    protected JavaType _referencedType;\n\n    protected final JavaType _superClass;\n    protected final JavaType[] _interfaceTypes;\n\n    public RecursiveType(Class<?> erasedType, JavaType selfReference) {\n        super(erasedType, 0, selfReference, null, null,\n                false, null, null);\n        _placeholder = erasedType;\n        _referencedType = null;\n        _superClass = null;\n        _interfaceTypes = null;\n    }\n\n    /**\n     * \"Copy-constructor\" used for creating resolved, fluent-copy.\n     */\n    private RecursiveType(JavaType type, Class<?> erasedType, JavaType selfReference,\n            JavaType superClass, JavaType[] interfaces)\n    {\n        super(erasedType, type.hashCode(), selfReference, type.getBindings(), type._typeHandler,\n                type._asStatic, type._valueHandler, type._typeAnnotations);\n        _placeholder = null;\n        _referencedType = selfReference;\n        _superClass = superClass;\n        _interfaceTypes = interfaces;\n    }\n\n    @Override\n    public JavaType withContentType(JavaType contentType) {\n        throw new IllegalArgumentException(\"Cannot override content type of \" + this.getClass().getName());\n    }\n\n    @Override\n    public JavaType withTypeHandler(Object h) {\n        return new RecursiveType(this, _rawClass, _referencedType, _superClass, _interfaceTypes);\n    }\n\n    @Override\n    public JavaType withContentTypeHandler(Object h) {\n        return new RecursiveType(this, _rawClass, _referencedType, _superClass, _interfaceTypes);\n    }\n\n    @Override\n    public JavaType withValueHandler(Object h) {\n        return new RecursiveType(this, _rawClass, _referencedType, _superClass, _interfaceTypes);\n    }\n\n    @Override\n    public JavaType withContentValueHandler(Object h) {\n        return new RecursiveType(this, _rawClass, _referencedType, _superClass, _interfaceTypes);\n    }\n\n    @Override\n    public JavaType withStaticTyping() {\n        if (_asStatic) {\n            return this;\n        }\n        return new RecursiveType(this, _rawClass, _referencedType, _superClass, _interfaceTypes);\n    }\n\n    @Override\n    public JavaType refine(Class<?> rawType, TypeBindings bindings, JavaType superClass, JavaType[] superInterfaces) {\n        throw new IllegalArgumentException(\"Cannot refine \" + this.getClass().getName());\n    }\n\n    @Override\n    protected JavaType _narrow(Class<?> subclass) {\n        return new RecursiveType(this, subclass, _referencedType, _superClass, _interfaceTypes);\n    }\n\n    @Override\n    public boolean isContainerType() {\n        return false;\n    }\n\n    @Override\n    public boolean hasRawClass(Class<?> clz) {\n        // usually we might want to return (this == clz), but for lazy eval\n        // need to be careful\n        if (_rawClass == clz) {\n            return true;\n        }\n        if (_referencedType != null) {\n            return _referencedType.hasRawClass(clz);\n        }\n        return false;\n    }\n\n    @Override\n    public boolean isTypeOrSubTypeOf(Class<?> clz) {\n        if (_rawClass == clz) {\n            return true;\n        }\n        if (_referencedType != null) {\n            return _referencedType.isTypeOrSubTypeOf(clz);\n        }\n        return false;\n    }\n\n    @Override\n    public String toString() {\n        if (_referencedType != null) {\n            return _referencedType.toString();\n        }\n        // this should never happen, but\n        return \"RecursiveType(unresolved)\";\n    }\n\n    @Override\n    public boolean equals(Object o) {\n        if (o == this) return true;\n        if (o == null) return false;\n        if (o.getClass() != getClass()) return false;\n\n        RecursiveType other = (RecursiveType) o;\n\n        if (_referencedType == null) {\n            return other._referencedType == null;\n        }\n        return _referencedType.equals(other._referencedType);\n    }\n\n    public boolean _isCircular() {\n        if (_referencedType == null) return false;\n        Map<Class<?>, Boolean> seen = new HashMap<>();\n        seen.put(_rawClass, true);\n        return _isCircular(_referencedType, seen);\n    }\n\n    private boolean _isCircular(JavaType type, Map<Class<?>, Boolean> seen) {\n        if (type instanceof RecursiveType) {\n            RecursiveType rt = (RecursiveType) type;\n            if (rt._referencedType != null) {\n                Class<?> refRaw = rt._referencedType.getRawClass();\n                if (seen.containsKey(refRaw)) {\n                    return true;\n                }\n                seen.put(refRaw, Boolean.TRUE);\n                return _isCircular(rt._referencedType, seen);\n            }\n            return false;\n        }\n        return false;\n    }\n\n    /**\n     * Method that is called if the reference is available to resolve\n     * recursive self-reference.\n     */\n    public JavaType selfReferencedType(JavaType ref)\n    {\n        if (_referencedType != null) {\n            return this;\n        }\n        // and otherwise, need to re-create the whole type thing...\n        return new RecursiveType(this, _rawClass, ref.copy(),\n                _superClass, _interfaceTypes);\n    }\n\n    @Override\n    public JavaType getSuperClass() {\n        return _superClass;\n    }\n\n    @Override\n    public JavaType getContentType() {\n        return null;\n    }\n\n    @Override\n    public int containedTypeCount() {\n        return 0;\n    }\n\n    @Override\n    public JavaType containedType(int index) {\n        return null;\n    }\n\n    @Override\n    public String containedTypeName(int index) {\n        return null;\n    }\n\n    @Override\n    public Class<?> getParameterSource() {\n        return null;\n    }\n}",
    "exact_match": false,
    "ast_match": false,
    "compile": false,
    "test": false
}