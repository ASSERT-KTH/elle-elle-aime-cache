{
    "generation": "package com.fasterxml.jackson.databind.type;\n\nimport java.lang.reflect.Type;\n\nimport com.fasterxml.jackson.databind.JavaType;\n\n/**\n * Base class for type implementations, used by {@link TypeFactory}.\n *\n * @since 2.7\n */\npublic abstract class TypeBase extends JavaType\n{\n    private static final long serialVersionUID = 1L;\n\n    protected final TypeBindings _bindings;\n\n    protected final JavaType _superClass;\n\n    protected final JavaType[] _superInterfaces;\n\n    protected int _hashCode;\n\n    protected TypeBase(TypeBindings bindings, JavaType superClass, JavaType[] superInts,\n            int hashCode) {\n        super();\n        _bindings = (bindings == null) ? TypeBindings.emptyBindings() : bindings;\n        _superClass = superClass;\n        _superInterfaces = superInts;\n        _hashCode = hashCode;\n    }\n\n    @Override\n    public abstract JavaType withContentType(JavaType contentType);\n\n    @Override\n    public abstract JavaType withTypeHandler(Object h);\n\n    @Override\n    public abstract JavaType withContentTypeHandler(Object h);\n\n    @Override\n    public abstract JavaType withValueHandler(Object h);\n    \n    @Override\n    public abstract JavaType withContentValueHandler(Object h);\n\n    @Override\n    public abstract JavaType withStaticTyping();\n\n    @Override\n    protected abstract String buildCanonicalName();\n\n    @Override\n    public TypeBindings getBindings() {\n        return _bindings;\n    }\n\n    @Override\n    public int containedTypeCount() { return _bindings.size(); }\n\n    @Override\n    public JavaType containedType(int index) {\n        return _bindings.getBoundType(index);\n    }\n    \n    @Override\n    @Deprecated\n    public String containedTypeName(int index) {\n        return _bindings.getBoundName(index);\n    }\n\n    @Override\n    public JavaType getSuperClass() { return _superClass; }\n\n    @Override\n    public final int hashCode() { return _hashCode; }\n\n    @Override\n    public boolean equals(Object o)\n    {\n        if (o == this) return true;\n        if (o == null) return false;\n        if (o.getClass() != getClass()) return false;\n\n        TypeBase other = (TypeBase) o;\n\n        if (_hashCode != other._hashCode) return false;\n        return _bindings.equals(other._bindings)\n                && _superClass == other._superClass // ok, as TypeBase has no generics\n                && java.util.Arrays.equals(_superInterfaces, other._superInterfaces);\n    }\n\n\n    protected JavaType _narrow(Class<?> subclass) {\n        // If already of type, return self:\n        if (getRawClass() == subclass) {\n            return this;\n        }\n        // Otherwise, must be a subtype by definition, so:\n        return _widen(subclass);\n    }\n\n    protected JavaType _widen(Class<?> superclass)\n    {\n        // If already of type, return self:\n        if (getRawClass() == superclass) {\n            return this;\n        }\n        // Otherwise, must be a super-type, so just construct resolved:\n        return new ResolvedRecursiveType(superclass, _bindings).setReference(this, _superClass);\n        // NOTE: sub-classes MUST merge _superInterfaces, _superClass info\n    }\n}",
    "exact_match": false,
    "ast_match": false,
    "compile": false,
    "test": false
}