{
    "generation": "package com.fasterxml.jackson.databind.type;\n\nimport java.lang.reflect.TypeVariable;\nimport java.util.*;\n\nimport com.fasterxml.jackson.databind.JavaType;\n\n/**\n * Base class for type implementations, other than the built-in\n * Java types.\n */\npublic abstract class TypeBase\n    extends JavaType\n    implements Type\n{\n    private static final long serialVersionUID = 1L;\n\n    protected final JavaType _superClass;\n\n    protected final JavaType[] _superInterfaces;\n\n    /**\n     * Lazily constructed hash code value of this type; assigned on\n     * first access (instead of in constructor, since the hash codes\n     * of contained types may not be available at that point)\n     */\n    protected int _hashCode;\n    \n    protected TypeBase(Class<?> raw, int hash, JavaType superClass, JavaType[] superInts,\n            Object valueHandler, Object typeHandler, boolean asStatic)\n    {\n        super(raw, hash, valueHandler, typeHandler, asStatic);\n        _superClass = superClass;\n        _superInterfaces = superInts;\n    }\n\n    @Override\n    public JavaType getSuperClass() { return _superClass; }\n\n    @Override\n    public List<JavaType> getInterfaces() {\n        if (_superInterfaces == null) {\n            return Collections.emptyList();\n        }\n        switch (_superInterfaces.length) {\n        case 0:\n            return Collections.emptyList();\n        case 1:\n            return Collections.singletonList(_superInterfaces[0]);\n        }\n        return Arrays.asList(_superInterfaces);\n    }\n\n    @Override\n    public final int hashCode()\n    {\n        int h = _hashCode;\n        if (h == 0) {\n            h = (getRawClass().getName().hashCode() + 31) * 31 + _superClass.hashCode();\n            if (_superInterfaces != null) {\n                for (JavaType intType : _superInterfaces) {\n                    h = (h * 31) + intType.hashCode();\n                }\n            }\n            _hashCode = h;\n        }\n        return h;\n    }\n\n    @Override\n    public String toString()\n    {\n        StringBuilder sb = new StringBuilder(40);\n        sb.append(\"[type: \").append(getRawClass().getName());\n        if (_superClass != null) {\n            sb.append(\" extends \").append(_superClass.toString());\n        }\n        if (_superInterfaces != null && _superInterfaces.length > 0) {\n            sb.append(\" implements \");\n            for (int i = 0, len = _superInterfaces.length; i < len; ++i) {\n                if (i > 0) {\n                    sb.append(\",\");\n                }\n                sb.append(_superInterfaces[i].toString());\n            }\n        }\n        sb.append(\"]\");\n        return sb.toString();\n    }\n\n    @Override protected JavaType _narrow(Class<?> subclass) {\n        return new SimpleType(subclass, _hash, _superClass, _superInterfaces,\n                _valueHandler, _typeHandler, _asStatic);\n    }\n    \n    @Override\n    public JavaType refine(Class<?> rawType, TypeBindings bindings, JavaType superClass, JavaType[] superInterfaces) {\n        if (rawType != _class) {\n            return null;\n        }\n        // 24-May-2016, tatu: Not sure why, but looks like super types can change\n        //    (with super type being resolved to recursive type during resolution)\n        if ((superClass == _superClass) && Arrays.equals(superInterfaces, _superInterfaces)) {\n            return this;\n        }\n        return new SimpleType(_class, _hash, superClass, superInterfaces,\n                _valueHandler, _typeHandler, _asStatic);\n    }\n\n    protected static JavaType _bogusSuperClass(Class<?> cls) {\n        Class<?> parent = cls.getSuperclass();\n        // If there is no parent, Object is resolved to null, must find non-null\n        while (parent != null && parent == Object.class) {\n            parent = parent.getSuperclass();\n        }\n        // shouldn't happen, but\n        if (parent == null) {\n            return null;\n        }\n        // shouldn't happen either, unless we have truly broken hierarchy\n        JavaType sup = new SimpleType(parent);\n        TypeBindings b = new TypeBindings().withHandlers(sup);\n        TypeVariable<?>[] vars = parent.getTypeParameters();\n        for (TypeVariable<?> var : vars) {\n            b.addBinding(var.getName(), sup); // won't work, but avoids exception\n        }\n        return new SimpleType(parent, -1, sup, null, null, null, false);\n    }\n}",
    "exact_match": false,
    "ast_match": false,
    "compile": false,
    "test": false
}