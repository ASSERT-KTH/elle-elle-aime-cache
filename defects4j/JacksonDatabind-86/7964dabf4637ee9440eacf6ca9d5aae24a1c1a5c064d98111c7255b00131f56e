{
    "generation": "package com.fasterxml.jackson.databind.type;\n\nimport java.lang.reflect.TypeVariable;\nimport java.util.*;\n\nimport com.fasterxml.jackson.databind.JavaType;\n\n/**\n * Specialized {@link TypeBase} implementation that handles cases where type\n * information includes type parameters that may recursively reference\n * type itself. Due to this, resolution of type metadata may have to be\n * deferred until full structure is known.\n */\npublic class RecursiveType extends TypeBase\n{\n    private static final long serialVersionUID = 1L;\n\n    /**\n     * Placeholder used before actual resolved type is known.\n     */\n    protected JavaType _placeholder;\n\n    /*\n    /**********************************************************\n    /* Life cycle\n    /**********************************************************\n     */\n\n    public RecursiveType(Class<?> erasedType, TypeBindings bindings)\n    {\n        super(erasedType, bindings, null, null, 0, null, null, false);\n        _placeholder = null;\n    }\n\n    /**\n     * Method that needs to be called once we know what concrete\n     * type instance this recursive type represents\n     */\n    public void setReference(JavaType ref)\n    {\n        // sanity check (should never happen)\n        if (ref == null) {\n            throw new IllegalArgumentException(\"Can not pass null argument\");\n        }\n        if (_placeholder != null) {\n            throw new IllegalArgumentException(\"Trying to re-set self reference; old value:\"+_placeholder+\", new:\"+ref);\n        }\n        // And then update with recursive information\n        _placeholder = ref;\n        // And since it's now resolved, can also convert type bounds\n        if (_bindings == null) {\n            _bindings = TypeBindings.emptyBindings();\n        } else {\n            _bindings = _bindings.withHandlers(this);\n        }\n        // 21-Mar-2016, tatu: Should we try to eagerly update handlers of contained\n        //   types too? For now, don't...\n    }\n\n    @Override\n    public JavaType withContentType(JavaType contentType) {\n        throw new IllegalArgumentException(\"Can not set content-type on a recursive type\");\n    }\n\n    @Override\n    public JavaType withTypeHandler(Object h) {\n        if (_placeholder != null) {\n            return _placeholder.withTypeHandler(h);\n        }\n        return cloneAsAbstractType(this)._narrow(h);\n    }\n\n    @Override\n    public JavaType withContentTypeHandler(Object h) {\n        if (_placeholder != null) {\n            return _placeholder.withContentTypeHandler(h);\n        }\n        return cloneAsAbstractType(this)._narrowContent(h);\n    }\n\n    @Override\n    public JavaType withValueHandler(Object h) {\n        if (_placeholder != null) {\n            return _placeholder.withValueHandler(h);\n        }\n        return cloneAsAbstractType(this)._narrowValue(h);\n    }\n\n    @Override\n    public JavaType withContentValueHandler(Object h) {\n        if (_placeholder != null) {\n            return _placeholder.withContentValueHandler(h);\n        }\n        return cloneAsAbstractType(this)._narrowContentValue(h);\n    }\n\n    @Override\n    protected JavaType _narrow(Object toReturn) {\n        // almost same as super-class, but need to clear placeholder\n        // to avoid tripping infinite loops\n        return new SimpleType(_class, _bindings, _superClass, _interfaces,\n                _valueHandler, _typeHandler, _asStatic, _hashCode)\n            .withContentValueHandler(_contentValueHandler);\n    }\n\n    /**\n     * Method that is to create a new instance of this type, but with\n     * different {@link JavaType} for value handler.\n     */\n    protected abstract JavaType cloneAsAbstractType(RecursiveType base);\n\n    /*\n    /**********************************************************\n    /* Methods for resolving concrete type\n    /**********************************************************\n     */\n\n    @Override\n    public boolean isFullyKnown() { return (_placeholder == null); }\n\n    /**\n     * Method that must be called to check whether this type\n     * is referring to the type being constructed (via type parameters).\n     * This is basically done to detect infinite recursion; problem is that\n     * this is not easy, and since it is possible to construct self-linked\n     * types...\n     */\n    public boolean isReferencing(Class<?> type)\n    {\n        return (_class == type);\n    }\n\n    /**\n     * Method that can be used to check whether this type\n     * has a variable name that suggests that it might make use of\n     * recursive type (denoted by type variable name being same\n     * as type variable name of at least one of its bounds).\n     * Note, however, that a positive return does NOT guarantee\n     * that such resolution is possible, just that it might be.\n     */\n    public boolean mayBeRecursive()\n    {\n        // First: we can only be recursive if we actually have type vars...\n        if (_bindings == null) {\n            return false;\n        }\n        // And from there on, we can delegate the work\n        return _bindings.mayBeRecursive();\n    }\n    \n    /*\n    /**********************************************************\n    /* Accessor methods for ASKING resolution of subtypes\n    /**********************************************************\n     */\n\n    @Override\n    public JavaType refine(Class<?> rawType, TypeBindings bindings,\n            JavaType superClass, JavaType[] superInterfaces)\n    {\n        if (!isFullyResolved()) {\n            throw new IllegalArgumentException(\"Can not refine RecursiveType that is not yet resolved\");\n        }\n        // But can delegate to resolved instance...\n        return _placeholder.refine(rawType, bindings, superClass, superInterfaces);\n    }\n\n    @Override\n    public JavaType forcedNarrowBy(Class<?> subclass)\n    {\n        // If so, we can do type refinement:\n        if (isFullyResolved()) {\n            // If so, we can do type refinement:\n            return _placeholder.forcedNarrowBy(subclass);\n        }\n        // Otherwise, need to Create bogus Placeholder matching new subtype\n        return _placeholder.narrow(subclass);\n    }\n\n    /**\n     * This method is overridden to return effective (recursive) type\n     * to use: this is done since in most cases methods are implemented\n     * on concrete 'bottom' type, even if declared in an interface or\n     * such.\n     */\n    @Override\n    public JavaType getSuperClass() {\n        if (isFullyResolved()) {\n            return _placeholder.getSuperClass();\n        }\n        return super.getSuperClass();\n    }\n\n    @Override\n    public TypeBindings getBindings()\n    {\n        if (_placeholder != null) {\n            return _placeholder.getBindings();\n        }\n        if (_bindings == null) {\n            _bindings = TypeBindings.emptyBindings();\n        }\n        return _bindings;\n    }\n    \n    @Override\n    public JavaType findSuperType(Class<?> rawTarget) {\n        if (isFullyResolved()) {\n            return _placeholder.findSuperType(rawTarget);\n        }\n        // But may still be found from partially resolved type\n        return super.findSuperType(rawTarget);\n    }\n\n    @Override\n    public Class<?> getParameterSource() {\n        /* 10-Nov-2015, tatu: Not sure whether this should return null\n         *   or not; likely should point to the original erased class\n         *   in case it's ever used.\n         */\n        return _class; \n    }\n    \n    @Override\n    protected JavaType _narrow(Class<?> subclass, TypeBindings newBindings,\n            JavaType newSuperClass, JavaType[] newSuperInterfaces)\n    {\n        // Can not do much, since placeholder may not yet be assigned...\n        return this;\n    }\n\n    /*\n    /**********************************************************\n    /* Accessors\n    /**********************************************************\n     */\n\n    @Override\n    public boolean isContainerType() {\n        if (_placeholder != null) {\n            return _placeholder.isContainerType();\n        }\n        return false;\n    }\n\n    @Override\n    public boolean hasRawClass(Class<?> clz) {\n        if (isFullyResolved()) {\n            return _placeholder.hasRawClass(clz);\n        }\n        // Type may be resolved later; but if not, calling super is fine\n        return super.hasRawClass(clz);\n    }\n\n    @Override\n    public boolean isTypeOrSubTypeOf(Class<?> clz) {\n        if (isFullyResolved()) {\n            return _placeholder.isTypeOrSubTypeOf(clz);\n        }\n        // Type may be resolved later; but if not, calling super is fine\n        return super.isTypeOrSubTypeOf(clz);\n    }\n\n    @Override\n    public String toCanonical()\n    {\n        if (_placeholder != null) {\n            return _placeholder.toCanonical();\n        }\n        return super.toCanonical();\n    }\n\n    @Override\n    public String toString()\n    {\n        /* Note: do NOT try to get textual representation if the type itself\n         * may be recursively defined; this can lead to infinite loops\n         */\n        if (_placeholder != null) {\n            return _placeholder.toString();\n        }\n        StringBuilder sb = new StringBuilder(40).append(\"[recursive type; \");\n        if (_class != null) {\n            sb = sb.append(TypeFactory.classForTyping(_class).getName());\n        } else {\n            sb = sb.append('?');\n        }\n        sb.append(']');\n        return sb.toString();\n    }\n\n    @Override\n    public boolean equals(Object o)\n    {\n        if (o == this) return true;\n        if (o == null) return false;\n        if (o.getClass() != getClass()) return false;\n\n        RecursiveType other = (RecursiveType) o;\n        if (_placeholder != null) {\n            return _placeholder.equals(other._placeholder);\n        }\n        // Otherwise, worry about placeholder...\n        return (_class == other._class);\n    }\n\n    @Override\n    public JavaType getContentType() {\n        if (_placeholder != null) {\n            return _placeholder.getContentType();\n        }\n        return null;\n    }\n\n    @Override\n    public JavaType getReferencedType() {\n        return (_placeholder != null) ? _placeholder : this;\n    }\n\n    /*\n    /**********************************************************\n    /* Internal methods\n    /**********************************************************\n     */\n\n    @Override\n    protected JavaType _migrate(Class<?> newRawClass, TypeBindings newBindings,\n            JavaType newSuperClass, JavaType[] newInterfaces) {\n        if (_placeholder != null) {\n            return _placeholder._migrate(newRawClass, newBindings,\n                    newSuperClass, newInterfaces);\n        }\n        throw new IllegalArgumentException(\"Illegal to migrate on non-resolved RecursiveType (\"+getClass().getName()+\")\");\n    }\n\n    /**\n     * Helper method we need for handling contained types: since\n     * this class can not be mutated, method is just to ensure\n     * that method signature is compatible with {@link TypeBase}\n     */\n    protected RecursiveType _uncheckedNarrow(Class<?> subclass) {\n        // We'll assume it works as expected; not much we can do here...\n        // This does mean that the 'this' reference is only updated once,\n        // but seems like it should work ok\n        _class = subclass;\n        _hashCode = subclass.getName().hashCode();\n        return this;\n    }\n\n    /*\n    /**********************************************************\n    /* Extended API for relationship to resolved concrete type\n    /**********************************************************\n     */\n\n    /**\n     * Method that can be used to get actual fully resolved type, if\n     * that is possible. This means that call is only legal to make\n     * if caller knows that type has been completely resolved.\n     * \n     * @return Resolved type if resolution complete; null otherwise\n     */\n    public JavaType getSelfReferencedType() { return _placeholder; }\n\n    /*\n    /**********************************************************\n    /* Helper class(es)\n    /**********************************************************\n     */\n\n    /**\n     * This helper class is used to \"hide\" recursive relationships,\n     * mostly for benefit of {@link TypeBindings}\n     */\n    public static class RecursiveTypeHandler\n        implements java.io.Serializable\n    {\n        private static final long serialVersionUID = 1L;\n\n        private final Class<?> _erasedType;\n        /**\n         * Name of type variable within {@link #_erasedType}\n         */\n        private final String _typeVariableName;\n\n        protected JavaType _referencedType;\n\n        public RecursiveTypeHandler(Class<?> erasedType, String tvName)\n        {\n            _erasedType = erasedType;\n            _typeVariableName = tvName;\n        }\n\n        public void setReference(JavaType type) {\n            if (_referencedType != null) {\n                throw new IllegalStateException(\"Trying to reset 'reference' from \"+_referencedType+\" to \"+type);\n            }\n            _referencedType = type;\n        }\n\n        public JavaType getSelfReference(JavaType type, TypeBindings typeBindings)\n        {\n            if (_referencedType != null) {\n                return _referencedType;\n            }\n            if (typeBindings == null) {\n                return JavaType.unknownType();\n            }\n            // Is this recursive reference?\n            return typeBindings.findBoundType(_typeVariableName);\n        }\n\n        @Override\n        public String toString() { return _erasedType.getName()+\"#\"+_typeVariableName; }\n    }\n}",
    "exact_match": false,
    "ast_match": false,
    "compile": false,
    "test": false
}