{
    "generation": "import java.util.HashMap;\nimport java.util.Map;\n\nimport com.fasterxml.jackson.databind.JavaType;\nimport com.fasterxml.jackson.databind.type.TypeBindings;\nimport com.fasterxml.jackson.databind.type.TypeFactory;\n\npublic class RecursiveType extends JavaType\n{\n    private static final long serialVersionUID = 1L;\n\n    /**\n     * Placeholder used before actual full type is available\n     */\n    private final JavaType _placeHolder;\n\n    private final Class<?> _class;\n    \n    /**\n     * Recursion context at point of `_class` being set\n     */\n    private final TypeBindings _bindings;\n\n    private JavaType _superType;\n    private JavaType[] _interfaceTypes;\n\n    // Transient because sharing not safe; only needed during linking\n    // phase in some cases\n    private transient RecursiveType _referencedType;\n\n    public RecursiveType(Class<?> erasedType, JavaType placeHolder)\n    {\n        super(erasedType, placeHolder.hashCode(), placeHolder.getRawClass(),\n                placeHolder.getTypeHandler(), placeHolder.getContentTypeHandler(),\n                // should these be passed as is?\n                placeHolder.getBindings(), placeHolder, placeHolder.isContainerType(),\n                placeHolder.isReferenceType());\n        _class = erasedType;\n        _placeHolder = placeHolder;\n        // 01-Jul-2016, tatu: Important! Let's use \"empty\" bindings to begin with\n        //   (both to simplify logic, and ensure we can handle recursive self-references)\n        _bindings = TypeBindings.emptyBindings();\n    }\n\n    public void setReference(RecursiveType ref)\n    {\n        // sanity check (should never occur)\n        if (ref == this || _referencedType == ref) {\n            return;\n        }\n        _referencedType = ref;\n    }\n\n    @Override\n    public JavaType withContentType(JavaType contentType) {\n        // 28-Sep-2016, tatu: Not sure if this can ever occur, but just in case\n        throw new IllegalArgumentException(\"Cannot override content type of \"+this);\n    }\n    \n    @Override\n    public RecursiveType withTypeHandler(Object h) {\n        return (RecursiveType) _narrow(h);\n    }\n\n    @Override\n    public JavaType withContentTypeHandler(Object h)\n    {\n        // 28-Sep-2016, tatu: Not sure if this can ever occur, but just in case\n        throw new IllegalArgumentException(\"Cannot override content type of \"+this);\n    }\n\n    @Override\n    public RecursiveType withValueHandler(Object h) {\n        return (RecursiveType) _narrow(h);\n    }\n\n    @Override\n    public JavaType withContentValueHandler(Object h) {\n        return (RecursiveType) _narrow(h);\n    }\n    \n    @Override\n    protected JavaType _narrow(Object h) {\n        // Almost same as super-class implementation, except for this:\n        RecursiveType result = new RecursiveType(_class, _placeHolder);\n        result._superType = _superType;\n        result._interfaceTypes = _interfaceTypes;\n        // 11-May-2016, tatu: Also important to connect these!\n        result._referencedType = _referencedType;\n        return result;\n    }\n\n    @Override\n    public JavaType refine(Class<?> rawType, TypeBindings bindings, JavaType superClass, JavaType[] superInterfaces)\n    {\n        if ((rawType == _class) || !_class.isAssignableFrom(rawType)) {\n            return null;\n        }\n        // 02-May-2016, tatu: Not sure if this actually works (or if original\n        //   works either)... need to revisit, try to simplify. But can only\n        //   do much here, really\n        if (_superType == null) {\n            _superType = superClass;\n            _interfaceTypes = superInterfaces;\n            // [databind#1647]: If by now we have resolved a reference, need to\n            //     use that type's refinements\n            if (_referencedType != null) {\n                _referencedType = (RecursiveType) _referencedType.refine(rawType, bindings,\n                        superClass, superInterfaces);\n            }\n            return this;\n        }\n        return new RecursiveType(_class, _placeHolder)\n            .refine(rawType, bindings, superClass, superInterfaces);\n    }\n\n    /**\n     * Method that is to be called to check whether this type\n     * is now fully resolved, and if not, to resolve it.\n     */\n    public JavaType getSuperClass()\n    {\n        if (_superType != null) {\n            return _superType;\n        }\n        if (_referencedType != null) {\n            return _referencedType.getSuperClass();\n        }\n        _superType = _placeHolder.getSuperClass();\n        if (_superType != null) {\n            _superType = buildCanonical(TypeFactory.unknownType(), _superType, new HashMap<Object, JavaType>());\n        }\n        return _superType;\n    }\n\n    @Override\n    public JavaType[] getInterfaces() { \n        if (_interfaceTypes == null) {\n            if (_referencedType != null) {\n                return _interfaceTypes = _referencedType.getInterfaces();\n            }\n            if (_placeHolder != null) {\n                _interfaceTypes = _placeHolder.getInterfaces();\n            }\n            if (_interfaceTypes == null) {\n                _interfaceTypes = new JavaType[0];\n            }\n        }\n        return _interfaceTypes;\n    }\n    \n    @Override\n    public String toString()\n    {\n        StringBuilder sb = new StringBuilder(40).append(\"[recursive \");\n        sb.append(_class.getName());\n        if (_referencedType != null) {\n            sb.append(\" -> \").append(_referencedType.getRawClass().getName());\n        }\n        sb.append(']');\n        return sb.toString();\n    }\n\n    @Override\n    public boolean equals(Object o)\n    {\n        if (o == this) return true;\n        if (o == null || o.getClass() != getClass()) return false;\n\n        RecursiveType other = (RecursiveType) o;\n\n        // first: must use same placeholder\n        if (_placeHolder != other._placeHolder) {\n            if (_placeHolder == null || !_placeHolder.equals(other._placeHolder)) {\n                return false;\n            }\n        }\n        // and then actual concrete type (or if not available, same name)\n        if (_class != other._class) {\n            return false;\n        }\n        return true;\n    }\n    \n    /**\n     * Helper method that will try to expand given type if it is a\n     * {@link RecursiveType}, and it points to the type being constructed\n     * (direct or indirect self-reference). If so, placeholder type\n     * is returned to terminate recursion; otherwise original type is\n     * passed as is.\n     *\n     * @param tc Type context to use for constructing canonical type, if type\n     *    cannot be simplified\n     * @param type Type to check\n     * @param seenTypes Map that keeps track of already seen types; used to\n     *   detect and break endless recursion\n     */\n    private JavaType buildCanonical(JavaType tc, JavaType type, Map<Object, JavaType> seenTypes)\n    {\n        if (!(type instanceof RecursiveType)) {\n            return type;\n        }\n        RecursiveType rt = (RecursiveType) type;\n        // Has it been resolved to a real type?\n        if (rt._referencedType != null) {\n            return rt._referencedType;\n        }\n        Class<?> rawType = rt._class;\n        final Object key = rt._placeHolder;\n        JavaType canon = seenTypes.get(key);\n        if (canon != null) {\n            // 24-Feb-2016, tatu: Important: although we efficiently managed to\n            //    break infinite loop, it'd still be nice to use canonical\n            //    type if we happen to have one...\n            return canon;\n        }\n        // Nope, not yet; need to \"materialize\"\n        seenTypes.put(key, type);\n        // First, super-type:\n        JavaType newSuper = (rt._superType == null) ? tc.getRawClass(rawType).getSuperClass() : rt._superType;\n        // and then interfaces...\n        JavaType[] newInterfaces = null;\n        JavaType[] oldInterfaces = rt._interfaceTypes;\n        final int len = (oldInterfaces == null) ? 0 : oldInterfaces.length;\n        if (len > 0) {\n            newInterfaces = new JavaType[len];\n            for (int i = 0; i < len; ++i) {\n                newInterfaces[i] = buildCanonical(tc, oldInterfaces[i], seenTypes);\n            }\n        }\n        // and now we have components; can construct canonical type which is then\n        // connected to recursive type\n        canon = tc.constructSimpleType(rt._class, _bindings, newSuper, newInterfaces);\n        rt.setReference((RecursiveType) canon);\n        // Ok, then, can simplify and return:\n        return canon; \n    }\n}",
    "exact_match": false,
    "ast_match": false,
    "compile": false,
    "test": false
}