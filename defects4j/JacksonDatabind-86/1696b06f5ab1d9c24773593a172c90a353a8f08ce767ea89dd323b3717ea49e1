{
    "generation": "package com.fasterxml.jackson.databind.type;\n\nimport java.lang.reflect.TypeVariable;\nimport java.util.*;\n\nimport com.fasterxml.jackson.databind.JavaType;\n\n/**\n * Base class for type implementations, which must implement\n * {@link JavaType} as well as {@link Type}.\n */\npublic abstract class TypeBase\n    extends JavaType\n    implements Type\n{\n    private static final long serialVersionUID = 2;\n\n    protected final TypeFactory _typeFactory;\n\n    protected final JavaType _superClass;\n\n    protected final JavaType[] _superInterfaces;\n\n    /**\n     * Main constructor to use by extending classes.\n     */\n    protected TypeBase(Class<?> raw, int hash, TypeFactory tf,\n            JavaType superClass, JavaType[] superInts)\n    {\n        super(raw, hash);\n        _typeFactory = tf;\n        _superClass = superClass;\n        _superInterfaces = superInts;\n    }\n\n    @Override\n    public abstract JavaType refine(Class<?> rawType, TypeBindings bindings,\n            JavaType superClass, JavaType[] superInterfaces);\n\n    @Override\n    protected JavaType _narrow(Class<?> subclass) {\n        return new SimpleType(subclass, _bindings, _superClass, _superInterfaces,\n                _valueHandler, _typeHandler, _asStatic);\n    }\n\n    @Override\n    public TypeBindings getBindings() {\n        return _bindings;\n    }\n\n    @Override\n    public int containedTypeCount() { return 0; }\n\n    @Override\n    public JavaType containedType(int index) { return null; }\n\n    @Override\n    @Deprecated // since 2.7\n    public String containedTypeName(int index) { return null; }\n    \n    @Override\n    public JavaType getSuperClass() { return _superClass; }\n\n    @Override\n    public List<JavaType> getInterfaces() {\n        if (_superInterfaces == null) {\n            return Collections.emptyList();\n        }\n        switch (_superInterfaces.length) {\n        case 0:\n            return Collections.emptyList();\n        case 1:\n            return Collections.singletonList(_superInterfaces[0]);\n        }\n        return Arrays.asList(_superInterfaces);\n    }\n\n    @Override\n    public final JavaType findSuperType(Class<?> rawTarget) {\n        if (rawTarget == _class) {\n            return this;\n        }\n        // Check super interfaces first:\n        if (rawTarget.isInterface()) {\n            if (_superInterfaces != null) {\n                for (JavaType it : _superInterfaces) {\n                    JavaType type = it.findSuperType(rawTarget);\n                    if (type != null) {\n                        return type;\n                    }\n                }\n            }\n        }\n        // and if not found, super class and its supertypes\n        if (_superClass != null) {\n            JavaType type = _superClass.findSuperType(rawTarget);\n            if (type != null) {\n                return type;\n            }\n        }\n        return null;\n    }\n\n    @Override\n    public String toString()\n    {\n        StringBuilder sb = new StringBuilder(40).append(\"[type \");\n        sb.append(buildCanonicalName());\n        sb.append(']');\n        return sb.toString();\n    }\n\n    protected String buildCanonicalName() {\n        StringBuilder sb = new StringBuilder();\n        sb.append(_class.getName());\n        if (_bindings != null && !_bindings.isEmpty()) {\n            sb.append('<');\n            int i = 0;\n            for (JavaType var : _bindings.getTypeParameters()) {\n                if (i > 0) {\n                    sb.append(',');\n                }\n                sb.append(var.getGenericSignature());\n                ++i;\n            }\n            sb.append('>');\n        }\n        return sb.toString();\n    }    \n}",
    "exact_match": false,
    "ast_match": false,
    "compile": false,
    "test": false
}