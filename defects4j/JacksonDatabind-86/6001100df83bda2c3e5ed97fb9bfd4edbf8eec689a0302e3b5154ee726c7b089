{
    "generation": "package com.fasterxml.jackson.databind.type;\n\nimport java.lang.reflect.TypeVariable;\nimport java.util.*;\n\nimport com.fasterxml.jackson.databind.JavaType;\n\n/**\n * We need a custom variant of {@link TypeBase} to handle\n * caching properly, during recursive resolution.\n */\npublic abstract class RecursiveType extends TypeBase\n{\n    /**\n     * Actual fully resolved type; assigned only at the end of\n     * resolution if/when resolution succeeds.\n     */\n    protected JavaType _resolvedType;\n\n    /*\n    /**********************************************************\n    /* Life-cycle\n    /**********************************************************\n     */\n\n    public RecursiveType(Class<?> cls, TypeBindings bindings,\n            JavaType superClass, JavaType[] superInts,\n            Object valueHandler, Object typeHandler, boolean asStatic)\n    {\n        super(cls, bindings, superClass, superInts, 0, valueHandler, typeHandler, asStatic);\n    }\n\n    @Override\n    public RecursiveType withTypeHandler(Object h) {\n        if (h == _typeHandler) {\n            return this;\n        }\n        // sanity check to avoid infinite loops...\n        if (_resolvedType != null) {\n            return (RecursiveType) _resolvedType.withTypeHandler(h);\n        }\n        return (RecursiveType) _narrow(h);\n    }\n\n    @Override\n    public JavaType withContentTypeHandler(Object h)\n    {\n        // sanity check to avoid infinite loops...\n        if (_resolvedType != null) {\n            return _resolvedType.withContentTypeHandler(h);\n        }\n        return this;\n    }\n    \n    @Override\n    public RecursiveType withValueHandler(Object h) {\n        if (h == _valueHandler) {\n            return this;\n        }\n        // sanity check to avoid infinite loops...\n        if (_resolvedType != null) {\n            return (RecursiveType) _resolvedType.withValueHandler(h);\n        }\n        return (RecursiveType) _narrow(h);\n    }\n\n    @Override\n    public JavaType withContentValueHandler(Object h) {\n        // sanity check to avoid infinite loops...\n        if (_resolvedType != null) {\n            return _resolvedType.withContentValueHandler(h);\n        }\n        return this;\n    }\n\n    @Override\n    public JavaType withStaticTyping() {\n        if (_asStatic) {\n            return this;\n        }\n        // sanity check to avoid infinite loops...\n        if (_resolvedType != null) {\n            return _resolvedType.withStaticTyping();\n        }\n        return _narrow(_valueHandler, _typeHandler, true);\n    }\n\n    public void setResolvedType(JavaType t) {\n        _resolvedType = t;\n    }\n\n    /*\n    /**********************************************************\n    /* Methods for RP resolution\n    /**********************************************************\n     */\n\n    /**\n     * Method that must be called for the type to refine itself,\n     * given the actual full type information now known.\n     * Operation may fail if type cannot be self-resolved, in\n     * which case {@link #getSelfReferencedType()} can be used\n     * to detect and possibly work around such resolution problem.\n     * \n     * @param context Access to resolved types in case unresolved\n     *    type requires resolution; as well as factory to use\n     *    for resolving still missing types.\n     *\n     * @return This type, if resolution succeeds; or \n     *   {@link #getSelfReferencedType()} if it fails\n     */\n    public abstract JavaType refine(TypeBindingsBindings context);\n\n    /**\n     * Method that can be used to check whether call to\n     * {@link #refine} is likely to succeed or not: if it returns\n     * a non-null value, it will fail (and return value is this type);\n     * if it returns null, it will succeed.\n     * Note, however, that it is still possible that resolution\n     * fails, as it may depend on contents of the whole graph.\n     */\n    public abstract JavaType getSelfReferencedType();\n\n    /*\n    /**********************************************************\n    /* Overridden methods\n    /**********************************************************\n     */\n\n    @Override\n    public boolean isContainerType() { return false; }\n\n    @Override\n    public String toCanonical() {\n        if (_resolvedType != null) {\n            return _resolvedType.toCanonical();\n        }\n        StringBuilder sb = new StringBuilder();\n        _class.getName();\n        if (_bindings != null) {\n            sb.append('<');\n            int i = 0;\n            for (JavaType type : _bindings.getTypeParameters()) {\n                if (i > 0) {\n                    sb.append(',');\n                }\n                sb.append(type.toCanonical());\n                ++i;\n            }\n            sb.append('>');\n        }\n        return sb.toString();\n    }\n\n    @Override\n    public String toString()\n    {\n        if (_resolvedType != null) {\n            return _resolvedType.toString();\n        }\n        StringBuilder sb = new StringBuilder(40);\n        sb.append(\"[recursive type; \");\n        if (_resolvedType != null) {\n            sb.append(\"resolved to \").append(_resolvedType.getRawClass().getName());\n        } else {\n            sb.append(\"unresolved\");\n        }\n        sb.append(']');\n        return sb.toString();\n    }\n\n    @Override\n    public boolean equals(Object o)\n    {\n        if (o == this) return true;\n        if (o == null || o.getClass() != getClass()) return false;\n        RecursiveType other = (RecursiveType) o;\n        if (_resolvedType != null) {\n            return _resolvedType.equals(other._resolvedType);\n        }\n        // Otherwise, worry about raw type and type parameters\n        return (_class == other._class)\n            && (_bindings != null)\n            && (_bindings.equals(other._bindings))\n            ;\n    }\n\n    @Override\n    public JavaType getSuperClass() {\n        // 30-Jul-2019, tatu: Need to override for this specific case;\n        //   otherwise we get infinite loop\n        if (_resolvedType != null) {\n            return _resolvedType.getSuperClass();\n        }\n        return super.getSuperClass();\n    }\n\n    protected abstract JavaType _narrow(Object valueHandler, Object typeHandler, boolean asStatic);\n\n    /**\n     * Overridable method that subtype implementations may use to\n     * try to find \"better\" type to return if there is recursion.\n     * It is often not possible, or desirable, to eagerly resolve\n     * type during construction, but this method is a work-around\n     * that can be used to alleviate problems from recursion.\n     */\n    protected JavaType _concrete(TypeBindingsBindings context, TypeBindings typeBindings) {\n        if (typeBindings != null) {\n            return context.resolveAndBind(typeBindings);\n        }\n        return TypeFactory.unknownType();\n    }\n    \n    /*\n    /**********************************************************\n    /* Helper classes\n    /**********************************************************\n     */\n\n    /**\n     * As a full type resolution may require multiple resolution\n     * steps, we may need to use temporary placeholders.\n     */\n    public static class PlaceholderForType extends RecursiveType\n    {\n        protected final TypeBindings _actual;\n\n        public PlaceholderForType(Class<?> cls, TypeBindings tparams)\n        {\n            super(cls, tparams, null, null, null, null, false);\n            _actual = tparams;\n        }\n\n        @Override\n        public JavaType getSelfReferencedType() {\n            return this;\n        }\n\n        @Override\n        public JavaType refine(TypeBindingsBindings context) {\n            JavaType t = _concrete(context, _actual);\n            _resolvedType = t;\n            return t;\n        }\n\n        @Override\n        protected JavaType _narrow(Object valueHandler, Object typeHandler, boolean asStatic) {\n            // should never get called\n            throw new IllegalStateException(\"Should never try to adjust placeholder type\");\n        }\n    }\n\n    /**\n     * We actually need somewhat complex representation here, to allow for\n     * type variables to be properly resolved.\n     */\n    public static class TypeBindingsBindings\n    {\n        private final TypeBindingsBindings _parent;\n\n        private final Map<String,JavaType> _types;\n\n        private List<UnresolvedRecursiveType> _unresolvedTypes;\n\n        public TypeBindingsBindings(TypeBindingsBindings parent, TypeVariable<?>[] vars,\n                JavaType[] types)\n        {\n            _parent = parent;\n            if ((vars == null) || (vars.length == 0)) {\n                _types = Collections.emptyMap();\n            } else {\n                int len = vars.length;\n                Map<String,JavaType> m = new HashMap<String,JavaType>(len);\n                for (int i = 0; i < len; ++i) {\n                    m.put(vars[i].getName(), types[i]);\n                }\n                _types = m;\n            }\n        }\n\n        /**\n         * Alternate constructor used for cases where we get a Map of types directly,\n         * not via type parameters\n         *\n         * @since 2.9\n         */\n        public TypeBindingsBindings(TypeBindingsBindings parent,\n                Map<String,JavaType> types)\n        {\n            _parent = parent;\n            _types = types;\n        }\n        \n        public JavaType findType(String name)\n        {\n            if (_types.containsKey(name)) {\n                return _types.get(name);\n            }\n            if (_parent != null) {\n                return _parent.findType(name);\n            }\n            return null;\n        }\n\n        /**\n         * @since 2.7\n         */\n        public void addUnresolvedType(UnresolvedRecursiveType type) {\n            if (_unresolvedTypes == null) {\n                _unresolvedTypes = new ArrayList<UnresolvedRecursiveType>();\n            }\n            _unresolvedTypes.add(type);\n        }\n\n        /**\n         * @since 2.7\n         */\n        public boolean hasUnresolvedTypes() {\n            return _unresolvedTypes != null && !_unresolvedTypes.isEmpty();\n        }\n\n        /**\n         * Method called to resolve types that have self-references (direct\n         * or indirect)\n         * \n         * @since 2.7\n         */\n        public List<JavaType> resolve() {\n            if (_unresolvedTypes == null) {\n                return Collections.emptyList();\n            }\n            int count = _unresolvedTypes.size();\n            List<JavaType> resolvedTypes = new ArrayList<JavaType>(count);\n            for (int i = 0; i < count; ++i) {\n                resolvedTypes.add(null);\n            }\n            int i = 0;\n            for (UnresolvedRecursiveType unresolved : _unresolvedTypes) {\n                JavaType resolved = unresolved.resolve();\n                // 28-Jun-2016, tatu: Not sure why, but this is necessary...\n                if (resolved instanceof RecursiveType) {\n                    ((RecursiveType) resolved).refine(this);\n                }\n                resolvedTypes.set(i, resolved);\n                ++i;\n            }\n            return resolvedTypes;\n        }\n\n        /**\n         * @since 2.9\n         */\n        public JavaType resolveAndBind(TypeBindings typeBindings) {\n            // First, basic resolution of type parameters:\n            int len = typeBindings.size();\n            JavaType[] typeParams;\n            if (len == 0) {\n                typeParams = NO_TYPES;\n            } else {\n                typeParams = new JavaType[len];\n                for (int i = 0; i < len; ++i) {\n                    JavaType t = typeBindings.getBoundType(i);\n                    if (t instanceof PlaceholderForType) {\n                        // Self-reference; needs re-processing later\n                        t = _resolveTypePlaceholder(this, (PlaceholderForType) t);\n                    } else {\n                        t = _resolveType(this, t);\n                    }\n                    typeParams[i] = t;\n                }\n            }\n            // And then either use resolved parameters, create placeholder, or fail:\n            JavaType realType = typeBindings.getType();\n            if (realType instanceof UnresolvedRecursiveType) {\n                realType = _resolveTypePlaceholder(this, (UnresolvedRecursiveType) realType);\n            } else {\n                realType = _resolveType(this, realType);\n            }\n            if (realType.isTypeOrSubTypeOf(typeBindings.getType().getRawClass())) {\n                return realType.refine(this, typeBindings, typeParams);\n            }\n            // If not, it's good as is, already:\n            return realType;\n        }\n\n        protected JavaType _resolveTypePlaceholder(TypeBindingsBindings context,\n                PlaceholderForType placeholderType) {\n            // Self-reference; needs re-processing later\n            JavaType t = placeholderType.refine(context);\n            // 17-Feb-2017, tatu: Not 100% sure why we need this check but:\n            if (t instanceof PlaceholderForType) {\n                t = _resolveTypePlaceholder(context, (PlaceholderForType) t);\n            }\n            return t;\n        }\n\n        protected JavaType _resolveTypePlaceholder(TypeBindingsBindings context,\n                UnresolvedRecursiveType unresolvedType)\n        {\n            // Self-reference; needs re-processing later\n            addUnresolvedType(unresolvedType);\n            return unresolvedType.getPlaceholder();\n        }\n\n        protected JavaType _resolveType(TypeBindingsBindings context, JavaType t) {\n            if (t instanceof RecursiveType) {\n                // A placeholder?\n                if (t instanceof PlaceholderForType) {\n                    return _resolveTypePlaceholder(context, (PlaceholderForType) t);\n                }\n                return ((RecursiveType) t).refine(context);\n            }\n            return t;\n        }\n    }\n}",
    "exact_match": false,
    "ast_match": false,
    "compile": false,
    "test": false
}