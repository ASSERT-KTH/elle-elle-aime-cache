{
    "generation": "package com.fasterxml.jackson.databind.type;\n\nimport java.lang.reflect.TypeVariable;\nimport java.util.*;\n\nimport com.fasterxml.jackson.databind.JavaType;\n\n/**\n * We need a custom variant of {@link TypeBindings} which is aware\n * of recursive types.\n */\npublic class RecursiveTypeBinding extends TypeBindings\n{\n    private static final long serialVersionUID = 1L;\n\n    private final JavaType _target;\n    private List<TypeBinding> _extraBindings;\n\n    public RecursiveTypeBinding(JavaType target) {\n        super(NO_STRINGS, NO_TYPES);\n        _target = target;\n        _extraBindings = new ArrayList<TypeBinding>(1);\n    }\n\n    @Override\n    public JavaType findBoundType(int index) {\n        if (index < _bindings.length) {\n            return _bindings[index];\n        }\n        int idx = index - _bindings.length;\n        if (idx < _extraBindings.size()) {\n            return _extraBindings.get(idx).getBoundType(0);\n        }\n        return null;\n    }\n\n    @Override\n    public int getBindingCount() {\n        return _bindings.length + _extraBindings.size();\n    }\n\n    @Override\n    public JavaType getBoundType(int index)\n    {\n        // First, regular bindings\n        if (index < _bindings.length) {\n            return _bindings[index];\n        }\n        int idx = index - _bindings.length;\n        // and if beyond, loop through extra bindings\n        if (idx < _extraBindings.size()) {\n            return _extraBindings.get(idx).getBoundType(0);\n        }\n        return null;\n    }\n\n    @Override\n    public List<JavaType> getTypeParameters() {\n        if (!_extraBindings.isEmpty()) {\n            List<JavaType> types = new ArrayList<JavaType>(getBindingCount());\n            types.addAll(Arrays.asList(_bindings));\n            for (TypeBinding b : _extraBindings) {\n                types.add(b.getBoundType(0));\n            }\n            return Collections.unmodifiableList(types);\n        }\n        return Collections.emptyList();\n    }\n\n    @Override\n    public boolean isEmpty() {\n        return (_extraBindings.isEmpty() && (_bindings.length == 0));\n    }\n\n    @Override\n    public String toString() {\n        if (_bindings.length == 0) {\n            StringBuilder sb = new StringBuilder(\"[empty]\");\n            if (!_extraBindings.isEmpty()) {\n                sb.append('(').append(_extraBindings).append(')');\n            }\n            return sb.toString();\n        }\n        StringBuilder sb = new StringBuilder();\n        sb.append('[');\n        for (int i = 0, len = getBindingCount(); i < len; ++i) {\n            if (i > 0) {\n                sb.append(',');\n            }\n            sb.append(getBoundType(i).toString());\n        }\n        sb.append(']');\n        return sb.toString();\n    }\n    \n    @Override\n    public TypeBindings withUnboundVariable(String name)\n    {\n        // not supported by recursive entries (should it?)\n        return this;\n    }\n\n    public TypeBindings withBinding(TypeVariable<?> variable, JavaType type)\n    {\n        // First: if we already have bindings, delegate to resolve()\n        if (_bindings.length > 0) {\n            return resolve(variable, type);\n        }\n        // if not, slight shortcut:\n        String varName = variable.getName();\n        int i = _extraBindings.size();\n        while (i-- > 0) {\n            TypeBinding binding = _extraBindings.get(i);\n            if (binding.hasVariable(varName)) {\n                _extraBindings.set(i, binding.withSubstitutedVariable(varName, type));\n                return this;\n            }\n        }\n        _extraBindings.add(TypeBinding.create(variable, type));\n        return this;\n    }\n    \n    @Override\n    protected String getBoundName(int index)\n    {\n        if (index >= _bindings.length) {\n            int ix = index - _bindings.length;\n            if (ix < _extraBindings.size()) {\n                return _extraBindings.get(ix)._variableStrs[0];\n            }\n        }\n        return super.getBoundName(index);\n    }\n\n    @Override\n    public JavaType resolveType(JavaType contextType, TypeBindings parentBindings,\n            TypeFactory tf, TypeVariable<?> variable)\n    {\n        // First: if we already have bindings, delegate to resolve()\n        if (_bindings.length > 0) {\n            return resolve(variable, tf.unknownType());\n        }\n        // if not, slight shortcut:\n        String varName = variable.getName();\n        int i = _extraBindings.size();\n        while (i-- > 0) {\n            TypeBinding binding = _extraBindings.get(i);\n            if (binding.hasVariable(varName)) {\n                // If so, we have the fully resolved value; return:\n                return binding.getBoundType(0);\n            }\n        }\n        // Otherwise, need to create a placeholder to eventually be resolved, if at all:\n        JavaType type = _target.withTypeHandler(_target.getTypeHandler());\n        _extraBindings.add(TypeBinding.create(varName, type));\n        return type;\n    }\n\n    @Override\n    public boolean hasUnbound(String name) {\n        // first: only empty one is unbound\n        if (_bindings.length == 0) {\n            // and all extra ones are unbound\n            return true;\n        }\n        // but if bound, may have dynamically resolved answer\n        for (int i = _bindings.length;  (--i) >= 0; ) {\n            if (name.equals(_variableStrs[i])) {\n                return false;\n            }\n        }\n        return true;\n    }\n\n    @Override\n    public Object asKey(TypeFactory tf) {\n        return _target.getRawClass().getName();\n    }\n\n    private TypeBindings resolve(TypeVariable<?> variable, JavaType type)\n    {\n        // First: we may have it as one of regular bindings...\n        TypeBindings tb = bind(variable, type);\n        if (tb.size() > 0) {\n            return tb;\n        }\n        // or, recursively via one of extra bindings\n        String varName = variable.getName();\n        int i = _extraBindings.size();\n        while (i-- > 0) {\n            TypeBinding binding = _extraBindings.get(i);\n            if (binding.hasVariable(varName)) {\n                _extraBindings.set(i, binding.withSubstitutedVariable(varName, type));\n                // this is bit messy, but we may have 'gone recursive', and have\n                // more bindings to apply at this point\n                if (_bindings.length > 0) {\n                    return TypeBindings.create(variable.getGenericDeclaration(), _bindings);\n                }\n                return TypeBindings.emptyBindings();\n            }\n        }\n        // if not, queue for later resolution\n        _extraBindings.add(TypeBinding.create(variable, type));\n        // this is bit messy, but we may have 'gone recursive', and have\n        // more bindings to apply at this point\n        if (_bindings.length > 0) {\n            return TypeBindings.create(variable.getGenericDeclaration(), _bindings);\n        }\n        return TypeBindings.emptyBindings();\n    }\n}",
    "exact_match": false,
    "ast_match": false,
    "compile": false,
    "test": false
}