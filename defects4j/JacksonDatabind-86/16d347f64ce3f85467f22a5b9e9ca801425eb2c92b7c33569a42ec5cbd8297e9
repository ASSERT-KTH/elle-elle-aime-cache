{
    "generation": "package com.fasterxml.jackson.databind.type;\n\nimport java.lang.reflect.TypeVariable;\nimport java.util.*;\n\nimport com.fasterxml.jackson.databind.JavaType;\n\n/**\n * Implementation of {@link JavaType} for recursive type definitions (recursive via\n * type parameters).\n * Specifically, values are:\n *<ul>\n * <li>Values that can be resolved are {@link #_referencedType} (link back to the\n *    type definition itself, which is a placeholder for recursive definition).\n *  </li>\n * <li>For fully resolved types, {@link #_superClass} has full type information\n *  </li>\n * </ul>\n * In addition to that, full resolution adds information on various Collections,\n * Maps, Arrays.\n */\npublic class RecursiveType extends TypeBase\n{\n    private static final long serialVersionUID = 1L;\n\n    /**\n     * Placeholder for recursive definition of what the actual type is.\n     *<p>\n     * Note that this is initially set as <code>null</code>, and only during\n     * resolution process filled in (once recursion is detected)\n     */\n    protected JavaType _referencedType;\n\n    protected RecursiveType(Class<?> erasedType, TypeBindings bindings) {\n        super(erasedType, bindings, null, null, 0, null, null, false);\n    }\n\n    public static RecursiveType construct(Class<?> erasedType, TypeBindings bindings) {\n        return new RecursiveType(erasedType, bindings);\n    }\n\n    @Override\n    public JavaType refine(Class<?> rawType, TypeBindings bindings, JavaType superClass, JavaType[] superInterfaces) {\n        throw new IllegalArgumentException(\"Cannot refine a RecursiveType; not a resolved type\");\n    }\n    \n    @Override\n    protected JavaType _narrow(Class<?> subclass) {\n        if (_erasedType == subclass) { // is this even legal?\n            return this;\n        }\n        // Should we create subtype?\n        RecursiveType newType = new RecursiveType(subclass, _bindings);\n        newType._referencedType = _referencedType; // could this work?\n        return newType;\n    }\n\n    @Override\n    public boolean equals(Object o)\n    {\n        if (o == this) return true;\n        if (o == null) return false;\n        if (o.getClass() != getClass()) return false;\n        RecursiveType other = (RecursiveType) o;\n\n        if (_erasedType != other._erasedType) return false;\n\n        if (_referencedType == null) {\n            return (other._referencedType == null);\n        }\n        return _referencedType.equals(other._referencedType);\n    }\n\n    @Override\n    public JavaType getSuperClass() {\n        if (_referencedType != null) {\n            return _referencedType.getSuperClass();\n        }\n        return _superClass;\n    }\n\n    @Override\n    public String toString()\n    {\n        StringBuilder sb = new StringBuilder(200);\n        sb.append(\"[recursive type; \");\n        if (_referencedType != null) {\n            sb.append(\"resolved to:\").append(_referencedType.toString());\n        } else {\n            sb.append(\"unresolved\");\n        }\n        sb.append(']');\n        return sb.toString();\n    }\n\n    /**\n     * Method that is called to find actual type this placeholder refers\n     * to, if any; and may be called recursively.\n     */\n    public JavaType getReferencedType() { return _referencedType; }\n\n    public void setReference(JavaType t)\n    {\n        // sanity check (should never happen)\n        if (_referencedType != null) {\n            throw new IllegalStateException(\"Trying to re-set self reference; old value = \"+_referencedType+\", new = \"+t);\n        }\n        _referencedType = t;\n    }\n\n    @Override\n    public JavaType withContentType(JavaType contentType) {\n        return _referencedType.withContentType(contentType);\n    }\n\n    @Override\n    public JavaType withTypeHandler(Object h) {\n        return _referencedType.withTypeHandler(h);\n    }\n\n    @Override\n    public JavaType withContentTypeHandler(Object h) {\n        return _referencedType.withContentTypeHandler(h);\n    }\n\n    @Override\n    public JavaType withValueHandler(Object h) {\n        return _referencedType.withValueHandler(h);\n    }\n\n    @Override\n    public JavaType withContentValueHandler(Object h) {\n        return _referencedType.withContentValueHandler(h);\n    }\n\n    @Override\n    public JavaType withStaticTyping() {\n        return _referencedType.withStaticTyping();\n    }\n    \n    @Override\n    public JavaType withKeyType(JavaType keyType) {\n        return _referencedType.withKeyType(keyType);\n    }\n    \n    @Override\n    public JavaType withContentValueType(JavaType contentType) {\n        return _referencedType.withContentValueType(contentType);\n    }\n}",
    "exact_match": false,
    "ast_match": false,
    "compile": false,
    "test": false
}