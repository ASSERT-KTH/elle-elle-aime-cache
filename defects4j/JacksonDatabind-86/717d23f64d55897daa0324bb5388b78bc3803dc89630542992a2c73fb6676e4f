{
    "generation": "package com.fasterxml.jackson.databind.type;\n\nimport java.lang.reflect.*;\nimport java.util.*;\n\nimport com.fasterxml.jackson.databind.JavaType;\nimport com.fasterxml.jackson.databind.type.TypeBase;\n\n/**\n * Base class for type implementations, other than the \"raw\" types\n * (instances of {@link SimpleType}).\n */\npublic abstract class TypeBase\n    extends JavaType\n    implements Serializable\n{\n    private static final long serialVersionUID = 1L;\n\n    protected final TypeBindings _bindings;\n\n    protected final JavaType _superClass;\n\n    /**\n     * Lazily constructed hash code value of this type; assigned when\n     * first needed.\n     */\n    protected transient int _hashCode;\n\n    protected TypeBase(Class<?> raw, TypeBindings bindings, JavaType superClass,\n            JavaType[] superInts, int hash, Object valueHandler, Object typeHandler,\n            boolean asStatic)\n    {\n        super(raw, hash, valueHandler, typeHandler, asStatic);\n        _bindings = (bindings == null) ? TypeBindings.emptyBindings() : bindings;\n        _superClass = superClass;\n        // 17-Dec-2014, tatu: Related to [databind#558], may need to link to resolved\n        //   super-interfaces. This is handled by improving caching aspects, so that\n        //   we only do it if necessary...\n        if (superInts == null) {\n             _superInterfaces =  _noSuperInterfaces;\n        } else {\n            if (superInts.length == 0) {\n                _superInterfaces = _noSuperInterfaces;\n            } else {\n                _superInterfaces = superInts;\n            }\n        }\n    }\n\n    protected TypeBase(TypeBase base) {\n        super(base);\n        _bindings = base._bindings;\n        _superClass = base._superClass;\n        _superInterfaces = base._superInterfaces;\n        _hashCode = base._hashCode;\n    }\n    \n    @Override\n    public String toCanonical() {\n        StringBuilder sb = new StringBuilder();\n        sb.append(buildCanonicalName());\n        if (_bindings.size() > 0) {\n            sb.append('<');\n            sb.append(_bindings.toCanonical());\n            sb.append('>');\n        }\n        return sb.toString();\n    }\n    \n    protected String buildCanonicalName() {\n        String name = _class.getName();\n        if (name.startsWith(\"java.\")) {\n            // 17-Dec-2014, tatu: As per [databind#558], need to canonicalize.\n            //   But, only core JDK types for now, as there are potential\n            //   complications wrt shading and custom things, to consider later\n            //   on.\n            // 12-Jan-2017, tatu: and just in case someone renames `java.util.List`\n            //   or something, let's just check explicitly to make sure it all works.\n            Class<?> cls = _class;\n            if (cls == Map.class) {\n                return \"java.util.Map\";\n            }\n            if (cls == List.class) {\n                return \"java.util.List\";\n            }\n            if (cls == Set.class) {\n                return \"java.util.Set\";\n            }\n            if (cls == Collection.class) {\n                return \"java.util.Collection\";\n            }            \n        }\n        return name;\n    }\n    \n    @Override\n    public abstract StringBuilder getGenericSignature(StringBuilder sb);\n\n    @Override\n    public abstract StringBuilder getErasedSignature(StringBuilder sb);\n\n    @Override\n    public TypeBindings getBindings() {\n        return _bindings;\n    }\n\n    @Override\n    public int containedTypeCount() { return _bindings.size(); }\n\n    @Override\n    public JavaType containedType(int index) {\n        return _bindings.getBoundType(index);\n    }\n    \n    @Override\n    @Deprecated\n    public String containedTypeName(int index) {\n        return _bindings.getBoundName(index);\n    }\n    \n    @Override\n    public JavaType getSuperClass() {\n        return _superClass;\n    }\n\n    @Override\n    protected void _reportContainedType(int index) {\n        if (index < 0 || index >= _bindings.size()) {\n            throw new IllegalArgumentException(\"Illegal type index: \"+index+\", array size \"+_bindings.size());\n        }\n        _bindings.getBoundType(index)._report();\n    }\n    \n    @Override\n    public boolean equals(Object o)\n    {\n        if (o == this) return true;\n        if (o == null) return false;\n        if (o.getClass() != getClass()) return false;\n\n        TypeBase other = (TypeBase) o;\n\n        if (_class != other._class) return false;\n\n        // 14-May-2017, tatu: To pass equality after canonicalization, must\n        //   ensure that same canonical name used:\n        if (!buildCanonicalName().equals(other.buildCanonicalName())) return false;\n\n        return _bindings.equals(other._bindings);\n    }\n\n    @Override public int hashCode() {\n        int h = _hashCode;\n        if (h == 0) {\n            h = (_class.getName().hashCode() + _bindings.hashCode());\n            _hashCode = h;\n        }\n        return h;\n    }\n}\n",
    "exact_match": false,
    "ast_match": false,
    "compile": false,
    "test": false
}