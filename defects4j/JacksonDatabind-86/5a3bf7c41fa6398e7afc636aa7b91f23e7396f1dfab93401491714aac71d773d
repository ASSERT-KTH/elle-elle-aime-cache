{
    "generation": "public ResolvedRecursiveType buildUnresolvedType(Type type, TypeBindings bindings, JavaType superType)\n{\n    _notClosed(); // in case recursion goes through constructor (successors of super)\n    RecursionCounter recCtr = new RecursionCounter(); // note: do we need new counter every time?\n    \n    RecursionContext returnCtr = getRecursionContext(_primaryType,\n            RecursionContextStack.findContext());\n    recCtr.onBegin();\n    \n    TypeUtil.toResolvedClassIfKnown(type);\n\n    final AtomicReference<Class<?>> fallbackContainer = _maybeTryDefaultContainerTypeResolution(_configuredClassForResolution.get(type));\n    \n    UnresolvedRecursiveContext currentContainerToTryFallbackContainerTypesWithin = buildRecursiveRecursionContextFor(type, recCtr);\n    return ResolvedRecursiveType.withReferenceAsRootClassIfAsEmptyOrResolvedForSameAndSubtypesOnNewIfOtherwise(_updateResolvedStateWhenConstructNew(\n                    UnresolvedResolvedTypeRefKey.from(this,\n                    RecursionState._recursiveResolve(_cached, true))::equals\n                            && type.getTypeIdClassContainerForClassSuperAndIdBoundIfObjectBoundUnwrapsSelf(_key\n                            (_updateIdUnresolvedResolutionAndUseDefaultContainer\n                                    = findRecursionContainerTargetSubTypeRecursively(recCtr,\n                                                    new ContextInContextWithBoundAsParam<RecursionState.TypeClassRecursionTypeMarker.TypeKeyWithConfig, \n                                            ResolvedRecursiveWithPrimaryAsSubSuperReferenceFromId,?>(_baseLookupContext(type)) {},_maybeCurrentResolutionAttemptRecursionResolvesWithinOtherPrimaryTarget,\n                                                                 superType = null)).maybeAsSamePrimaryRecursiveInTargetResolvedContextPrimaryUnresolvedOnUnResolved),\n           !(_currentlyWithinTypeSubConstruction? buildSubState(recCtr): super::superWithinNonSuper) \n           ? ((targetFoundBeforeOrNextIfFromDefaultUnBoundForAllKnown,  primaryMatchOfSuperByStateBoundResolvingWhenWithForContainerForAnd)  = findBaseFromOtherPrimariesSuperFromPrimTargetSuperSuperWithinForToBuildNonResolvedBefore(type,\n                                        typeClassMarkerFromThisMarker(this.findFromAndNonAnyOfAny, new ToDefaultForDefaultInResolutionOnFromEmptyMarker())\n                     || resolvedOnFindBuildOnIdTypeMaybeAnyTypeSameInFoundStateBeforeContainerBuildOfToDefaultAsResolvable))).\n            state()// set id so as id build before find type resolve non primary when sub.\n                  , maybeUpdateBeforeSetState(findAnyResolved, true)))\n}",
    "exact_match": false,
    "ast_match": false,
    "compile": false,
    "test": false
}