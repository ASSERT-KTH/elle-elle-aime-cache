{
    "generation": "package com.fasterxml.jackson.databind.type;\n\nimport java.lang.reflect.TypeVariable;\nimport java.util.*;\n\nimport com.fasterxml.jackson.databind.JavaType;\nimport com.fasterxml.jackson.databind.util.LRUMap;\n\n/**\n * Implementation of {@link TypeFactory} which is backed by a simple cache\n * to prevent construction of multiple instances for same types.\n */\npublic abstract class TypeFactory\n{\n    protected final static TypeBindings EMPTY_BINDINGS = TypeBindings.emptyBindings();\n\n    protected final static JavaType[] NO_TYPES = new JavaType[0];\n\n    /*\n    /**********************************************************\n    /* Caching\n    /**********************************************************\n     */\n\n    /**\n     * We will use a single main-level instance for non-primitive\n     * types, and per-primitive instances for primitives.\n     */\n    protected final LRUMap<Object, JavaType> _typeCache;\n\n    /*\n    /**********************************************************\n    /* Construction, configuration\n    /**********************************************************\n     */\n\n    protected TypeFactory() {\n        this(null);\n    }\n\n    protected TypeFactory(LRUMap<Object,JavaType> typeCache) {\n       _typeCache = (typeCache == null) ? new LRUMap<>(16, 100) : typeCache;\n    }\n    \n    /*\n    /**********************************************************\n    /* Methods for sub-classes\n    /**********************************************************\n     */\n\n    protected abstract JavaType _fromClass(Class<?> clz, TypeBindings context);\n\n    protected abstract JavaType _fromParamType(Class<?> clz, TypeBindings context);\n    \n    protected abstract JavaType _fromArrayType(Class<?> clz, TypeBindings context,\n            JavaType elementType, Object valueHandler);\n\n    protected abstract JavaType _fromCollectionType(Class<?> clz, TypeBindings context,\n            JavaType elementType, Object valueHandler);\n\n    protected abstract JavaType _fromMapType(Class<?> clz, TypeBindings context,\n            JavaType keyType, JavaType valueType, Object valueHandler);\n\n    protected abstract JavaType _fromWellKnownClass(Class<?> clz, TypeBindings context,\n            JavaType[] subtypes, int containedTypeCount);\n\n    protected abstract JavaType _fromWellKnownInterface(Class<?> clz, TypeBindings context,\n            JavaType[] subtypes, int containedTypeCount);\n\n    public abstract TypeFactory withModifier(TypeModifier mod);\n\n    /*\n    /**********************************************************\n    /* Public factory methods\n    /**********************************************************\n     */\n\n    public JavaType constructType(Type type) {\n        return _constructType(type, EMPTY_BINDINGS);\n    }\n    \n    public JavaType constructType(Type type, TypeBindings bindings) {\n        return _constructType(type, bindings);\n    }\n\n    public JavaType constructType(Class<?> clz) {\n        return _constructType(clz, EMPTY_BINDINGS);\n    }\n\n    public JavaType constructType(Class<?> clz, TypeBindings bindings) {\n        return _constructType(clz, bindings);\n    }\n\n    public JavaType constructSpecializedType(JavaType baseType, Class<?> subclass)\n    {\n        // simple optimization to avoid costly introspection if type-erased type does NOT differ\n        final Class<?> rawBase = baseType.getRawClass();\n        if (rawBase == subclass) {\n            return baseType;\n        }\n\n        // 03-Oct-2016, tatu: needs to be done carefully to avoid infinite loops\n        //   and hence some sanity checks\n        if (!rawBase.isAssignableFrom(subclass)) {\n            throw new IllegalArgumentException(String.format(\"Class %s not subtype of %s\",\n                    subclass.getName(), rawBase.getName()));\n        }\n\n        JavaType newType;\n\n        TypeBindings baseBindings = baseType.getBindings();\n\n        if (baseType.isContainerType() || baseType.isReferenceType()) {\n            // 19-May-2016, tatu: Sub-classing of `ArrayType` is mostly done by core\n            //    types anyway, so this should not be triggered commonly. But when it\n            //    is, need to avoid recursive resolution.\n            if (baseType.isArrayType()) {\n                newType = _fromArrayType(subclass, baseBindings, baseType.getContentType(), null);\n            } else if (baseType.isMapLikeType()) {\n                JavaType keyType = baseType.getKeyType();\n                JavaType contentType = baseType.getContentType();\n                newType = _fromMapType(subclass, baseBindings, keyType, contentType, baseType.getValueHandler());\n            } else if (baseType.isCollectionLikeType()) {\n                JavaType contentType = baseType.getContentType();\n                newType = _fromCollectionType(subclass, baseBindings, contentType, baseType.getValueHandler());\n            } else { // ReferenceType\n                newType = _fromWellKnownClass(subclass, baseBindings,\n                        baseType.getBindings().getTypeParameters(), 0);\n                if (newType == null) {\n                    newType = _fromClass(subclass, baseBindings);\n                }\n                newType = baseType.refine(subclass, newType.getBindings(), newType.getContentType(), newType.getValueHandler());\n            }\n        } else {\n            if (baseType.isInterface()) {\n                newType = _fromWellKnownInterface(subclass, baseBindings,\n                        baseBindings.getTypeParameters(), 0);\n            } else { // class; probably some known type\n                newType = _fromWellKnownClass(subclass, baseBindings,\n                        baseBindings.getTypeParameters(), 0);\n            }\n            if (newType == null) {\n                // or if not known, standard class\n                newType = _fromClass(subclass, baseBindings);\n            }\n        }\n\n        return newType;\n    }    \n\n    protected JavaType _constructType(Type type, TypeBindings context)\n    {\n        JavaType resultType;\n\n        final Object key = new TypeKey(type, context);\n\n        synchronized (_typeCache) {\n            resultType = _typeCache.get(key);\n        }\n        if (resultType != null) {\n            return resultType;\n        }\n\n        if (type instanceof Class<?>) {\n            Class<?> cls = (Class<?>) type;\n            /* 19-Feb-2015, tatu: For final classes we should not try to\n             *   refine; benefits are minimal at best and problems insidious.\n             *   Related to [databind#709]\n             */\n            if (cls.isArray()) {\n                resultType = _fromArrayType(cls, context, null, null);\n            } else {\n                if (cls.isEnum()) {\n                    resultType = _fromParamType(cls, context);\n                } else if (cls == String.class) {\n                    // [databind#686]: Make String a special case to prevent failures with some\n                    // JDK versions (specifically, Android):\n                    resultType = new SimpleType(cls);\n                } else {\n                    if (Collection.class.isAssignableFrom(cls)) {\n                        resultType = _fromCollectionType(cls, context, null, null);\n                    } else if (Map.class.isAssignableFrom(cls)) {\n                        resultType = _fromMapType(cls, context, null, null, null);\n                    } else {\n                        resultType = _fromClass(cls, context);\n                    }\n                }\n            }\n        } else if (type instanceof ParameterizedType) {\n            resultType = _fromParamType(type, context);\n        } else if (type instanceof GenericArrayType) {\n            resultType = _fromArrayType(type, context);\n        } else if (type instanceof TypeVariable<?>) {\n            resultType = _fromVariable(type, context);\n        } else if (type instanceof WildcardType) {\n            resultType = _fromWildcard(type, context);\n        } else {\n            // sanity check\n            throw new IllegalArgumentException(\"Unrecognized Type: \"+(type == null ? \"[null]\" : type.toString()));\n        }\n\n        // 17-Dec-2014, tatu: Should we try to protect against recursive resolution?\n        //   Not sure if this should ever occur...\n\n        synchronized (_typeCache) {\n            _typeCache.put(key, resultType);\n        }\n        return resultType;\n    }\n    \n    protected JavaType _fromParamType(Type type, TypeBindings context)\n    {\n        /* First: ParameterizedType is only returned for members (methods,\n         * constructors; not fields), so we can assume we have\n         * a class/interface to start with.\n         */\n        if (!(type instanceof ParameterizedType)) {\n            throw new IllegalArgumentException(\"Type \"+type.getClass().getName()\n                    +\" not a ParameterizedType\");\n        }\n        ParameterizedType pt = (ParameterizedType) type;\n        // And raw type should be a Class<?>:\n        Class<?> rawType = (Class<?>) pt.getRawType();\n        Type[] args = pt.getActualTypeArguments();\n        int argCount = (args == null) ? 0 : args.length;\n        JavaType[] pt = (argCount == 0) ? NO_TYPES : new JavaType[argCount];\n        for (int i = 0; i < argCount; ++i) {\n            pt[i] = _constructType(args[i], context);\n        }\n        // 16-Jun-2016, tatu: For our caching purposes, must consider\n        //   bindings as part of key, due to aliasing...\n        TypeBindings newBindings = context.childInstance();\n\n        // !!! TBI: should this actually be done every time? or just if non-empty?\n        newBindings = newBindings.withGenerics(rawType, pt);\n        \n        if (Collection.class.isAssignableFrom(rawType)) {\n            return _fromCollectionType(rawType, newBindings, pt[0], null);\n        }\n        if (Map.class.isAssignableFrom(rawType)) {\n            return _fromMapType(rawType, newBindings, pt[0], pt[1], null);\n        }\n        // Bindings are important since we may have type variable with recursive definition\n        return _fromWellKnownClass(rawType, newBindings, pt, 0);\n    }\n    \n    protected JavaType _fromArrayType(Type type, TypeBindings context)\n    {\n        if (!(type instanceof GenericArrayType)) {\n            throw new IllegalArgumentException(\"Type \"+type.getClass().getName()\n                    +\" not a GenericArrayType\");\n        }\n        JavaType compType = _constructType(((GenericArrayType) type).getGenericComponentType(),\n                context);\n        return _fromArrayType(compType.getRawClass(), context, compType, null);\n    }\n\n    protected JavaType _fromVariable(Type type, TypeBindings context)\n    {\n        if (!(type instanceof TypeVariable<?>)) {\n            throw new IllegalArgumentException(\"Type \"+type.getClass().getName()\n                    +\" not a TypeVariable\");\n        }\n        TypeVariable<?> var = (TypeVariable<?>) type;\n        // 22-Apr-2016, tatu: For now prevent infinite loops by not trying\n        // to resolve recursively -- may need to change in future but that's\n        // least likely place for failure, and unlike with recursive types,\n        // it is fairly safe to avoid infinite recursion this way\n        String name = var.getName();\n        JavaType typeInfo = context.findBoundType(name);\n        if (typeInfo != null) {\n            return typeInfo;\n        }\n        // and if nothing bound, resolve as \"untyped\"\n        return _constructType(Object.class, context);\n    }\n\n    protected JavaType _fromWildcard(Type type, TypeBindings context)\n    {\n        if (!(type instanceof WildcardType)) {\n            throw new IllegalArgumentException(\"Type \"+type.getClass().getName()\n                    +\" not a WildcardType\");\n        }\n        WildcardType wildcard = (WildcardType) type;\n        // Ideally should resolve bounds, but for now, just use Object.class\n        return _constructType(Object.class, context);\n    }\n    \n    /*\n    /**********************************************************\n    /* Actual construction of \"raw\" variants\n    /**********************************************************\n     */\n\n    /**\n     * Method for constructing an {@link ArrayType}.\n     *<p>\n     * NOTE: even if element type is known to be an array type, will construct\n     * a new array type; meaning that inner type will NOT be shared between\n     * parent and child instances. This may become problematic if there are\n     * long chains of array types, as construction may become expensive;\n     * this is mostly left as is since problems are rare, and fixing adds\n     * complexity.\n     */\n    public ArrayType constructArrayType(Class<?> elementType) {\n        return ArrayType.construct(_constructType(elementType, null), null);\n    }\n    \n    public ArrayType constructArrayType(JavaType elementType) {\n        return ArrayType.construct(elementType, null);\n    }    \n\n    public CollectionType constructCollectionType(Class<? extends Collection> collectionClass,\n            Class<?> elementClass) {\n        return constructCollectionType(collectionClass,\n                _constructType(elementClass, EMPTY_BINDINGS));\n    }\n\n    public CollectionType constructCollectionType(Class<? extends Collection> collectionClass,\n            JavaType elementType) {\n        TypeBindings bindings = TypeBindings.create(collectionClass, elementType);\n        // and may need to further refine based on raw class of element type\n        CollectionType result = (CollectionType) _fromCollectionType(collectionClass, bindings,\n                elementType, null);\n        // Note: not caching yet; may want to, but may miss some subtleties\n        return result;\n    }\n\n    public CollectionLikeType constructCollectionLikeType(Class<?> collectionClass, Class<?> elementClass) {\n        return constructCollectionLikeType(collectionClass,\n                _constructType(elementClass, EMPTY_BINDINGS));\n    }\n    \n    public CollectionLikeType constructCollectionLikeType(Class<?> collectionClass, JavaType elementType) {\n        JavaType type = _fromCollectionType(collectionClass, TypeBindings.createIfNeeded(collectionClass, elementType),\n                elementType, null);\n        if (type instanceof CollectionLikeType) {\n            return (CollectionLikeType) type;\n        }\n        return CollectionLikeType.upgradeFrom(type, elementType);\n    }\n\n    public MapType constructMapType(Class<? extends Map> mapClass,\n            Class<?> keyClass, Class<?> valueClass) {\n        JavaType kt = _constructType(keyClass, EMPTY_BINDINGS);\n        JavaType vt = _constructType(valueClass, EMPTY_BINDINGS);\n        return constructMapType(mapClass, kt, vt);\n    }\n\n    public MapType constructMapType(Class<? extends Map> mapClass,\n            JavaType keyType, JavaType valueType) {\n        TypeBindings bindings = TypeBindings.create(mapClass, new JavaType[] { keyType, valueType });\n        return (MapType) _fromMapType(mapClass, bindings, keyType, valueType, null);\n    }\n\n    public MapLikeType constructMapLikeType(Class<?> mapClass,\n            Class<?> keyClass, Class<?> valueClass) {\n        JavaType kt = _constructType(keyClass, EMPTY_BINDINGS);\n        JavaType vt = _constructType(valueClass, EMPTY_BINDINGS);\n        return constructMapLikeType(mapClass, kt, vt);\n    }\n\n    public MapLikeType constructMapLikeType(Class<?> mapClass,\n            JavaType keyType, JavaType valueType) {\n        JavaType type = _fromMapType(mapClass, TypeBindings.createIfNeeded(mapClass, new JavaType[] { keyType, valueType }),\n                keyType, valueType, null);\n        if (type instanceof MapLikeType) {\n            return (MapLikeType) type;\n        }\n        return MapLikeType.upgradeFrom(type, keyType, valueType);\n    }\n    \n    public JavaType constructSimpleType(Class<?> rawType, JavaType[] parameterTypes) {\n        return _constructSimpleType(rawType, EMPTY_BINDINGS, parameterTypes, NO_TYPES);\n    }\n\n    public JavaType constructSimpleType(Class<?> rawType, TypeBindings parameterTypes,\n            JavaType[] typeParameters, JavaType[] typeArguments) {\n        return _constructSimpleType(rawType, parameterTypes, typeParameters, typeArguments);\n    }\n\n    protected JavaType _constructSimpleType(Class<?> rawType, TypeBindings context,\n            JavaType[] typeParameters, JavaType[] typeArguments)\n    {\n        JavaType result;\n        TypeVariable<?>[] vars = rawType.getTypeParameters();\n        int varLen = (vars == null) ? 0 : vars.length;\n        if (varLen > 0) {\n            JavaType[] pt;\n            int len = typeParameters.length;\n            if (len == varLen) {\n                pt = typeParameters;\n            } else {\n                // if wrong number, use other method... but should we warn?\n                pt = new JavaType[varLen];\n                for (int i = 0; i < varLen; ++i) {\n                    pt[i] = (i < len) ? typeParameters[i] : _unknownType();\n                }\n            }\n            // !!! TBI: should this actually be done every time? or just if non-empty?\n            context = context.withGenerics(rawType, pt);\n        }\n\n        // [databind#804]: also consider type arguments passed; these are important for\n        // non-generic static types, where parameterization needs to come from actual\n        // usage, not static declaration.\n        if (typeArguments.length > 0) {\n            context = context.withTypeParameters(rawType, typeArguments);\n        }\n\n        if (rawType == String.class) {\n            return new SimpleType(rawType);\n        }\n\n        // [databind#192]: primitive types are slightly special, need to avoid processing\n        // via factory methods that may do incorrect caching...\n\n        if (rawType.isPrimitive()) {\n            result = new SimpleType(rawType);\n        } else if (rawType == Object.class) {\n            result = new SimpleType(rawType);\n        } else if (rawType == Comparable.class) {\n            result = new SimpleType(rawType);\n        } else { // anything else...\n            result = _fromClass(rawType, context);\n        }\n        return result;\n    }\n\n    /**\n     * Method that will try to construct a {@link JavaType} for given\n     * abstract class, using suggested implementation class. If construction\n     * fails, will return the {@link JavaType} for the abstract class.\n     */\n    @SuppressWarnings(\"unchecked\")\n    public JavaType constructFromCanonical(String canonical) throws IllegalArgumentException\n    {\n        SimpleType simple = SimpleType.construct(canonical);\n        if (simple != null) {\n            return simple;\n        }\n        try {\n            Class<?> cls = Class.forName(canonical);\n            return constructType(cls);\n        } catch (ClassNotFoundException e) {\n            throw new IllegalArgumentException(String.format(\"Can not construct type from canonical name '%s'\", canonical), e);\n        }\n    }\n\n    /*\n    /**********************************************************\n    /* Helper methods\n    /**********************************************************\n     */\n\n    protected JavaType _unknownType() {\n        return _constructType(Object.class, EMPTY_BINDINGS);\n    }\n    \n    protected static final class TypeKey\n    {\n        private final Type _type;\n        private final TypeBindings _bindings;\n\n        public TypeKey(Type t, TypeBindings b) {\n            _type = t;\n            _bindings = b;\n        }\n\n        @Override public int hashCode() {\n            return _type.hashCode() + _bindings.hashCode();\n        }\n        \n        @Override public boolean equals(Object o) {\n            if (o == this) return true;\n            if (o == null) return false;\n            if (o.getClass() != getClass()) return false;\n            TypeKey other = (TypeKey) o;\n            return (_type == other._type) && _bindings.equals(other._bindings);\n        }\n    }    \n}",
    "exact_match": false,
    "ast_match": false,
    "compile": false,
    "test": false
}