{
    "generation": "package com.fasterxml.jackson.databind.type;\n\nimport java.lang.reflect.TypeVariable;\nimport java.util.Arrays;\nimport java.util.Collections;\n\nimport com.fasterxml.jackson.databind.JavaType;\n\npublic class RecursiveType extends TypeBase\n{\n    private static final long serialVersionUID = 1L;\n\n    /**\n     * Type-erased version of the full type.\n     */\n    protected final JavaType _erasedType;\n\n    protected JavaType _referencedType;\n\n    public RecursiveType(JavaType erasedType, TypeVariable<?>[] typeVars) {\n        super(erasedType.getRawClass(), erasedType.hashCode(), erasedType._valueHandler,\n                erasedType._typeHandler, erasedType.isContainerType(), erasedType.isEnumType());\n        _erasedType = erasedType;\n        _typeParameters = typeVars;\n    }\n\n    @Override\n    public JavaType withContentType(JavaType contentType) {\n        throw new IllegalArgumentException(\"Illegal to call withContentType() on \"+getClass().getName());\n    }\n\n    @Override\n    public JavaType withTypeHandler(Object h) {\n        if (h == _typeHandler) {\n            return this;\n        }\n        return new RecursiveType(_erasedType, _typeParameters).withContentTypeHandler(h);\n    }\n\n    @Override\n    public JavaType withContentTypeHandler(Object h) {\n        if (h == _contentTypeHandler) {\n            return this;\n        }\n        return new RecursiveType(_erasedType, _typeParameters).withTypeHandler(_typeHandler)\n                .withValueHandler(_valueHandler).withContentTypeHandler(h);\n    }\n\n    @Override\n    public JavaType withValueHandler(Object h) {\n        if (h == _valueHandler) {\n            return this;\n        }\n        return new RecursiveType(_erasedType, _typeParameters).with(h, _typeHandler, _contentTypeHandler);\n    }\n\n    @Override\n    public JavaType withStaticTyping() {\n        if (_asStatic) {\n            return this;\n        }\n        return new RecursiveType(_erasedType.withStaticTyping(), _typeParameters).with(this);\n    }\n\n    public RecursiveType with(Object valueHandler, Object typeHandler, Object contentTypeHandler) {\n        RecursiveType rt = new RecursiveType(_erasedType, _typeParameters);\n        rt._valueHandler = valueHandler;\n        rt._typeHandler = typeHandler;\n        rt._contentTypeHandler = contentTypeHandler;\n        rt._asStatic = _asStatic;\n        return rt;\n    }\n\n    public void setReferencedType(JavaType t) {\n        if (_referencedType != null) {\n            throw new IllegalStateException(\"Trying to re-set self reference; old value = \"+_referencedType+\", new = \"+t);\n        }\n        _referencedType = t;\n    }\n\n    @Override\n    public String toString()\n    {\n        StringBuilder sb = new StringBuilder(40 + _erasedType.getRawClass().getName().length());\n        sb.append(\"[recursive type; \");\n        sb.append(_erasedType.getRawClass().getName());\n        if (_referencedType != null) {\n            sb.append(\" -> \").append(_referencedType.toCanonical());\n        }\n        sb.append(']');\n        return sb.toString();\n    }\n\n    @Override\n    public boolean equals(Object o)\n    {\n        if (o == this) return true;\n        if (o == null) return false;\n        if (o.getClass() != getClass()) return false;\n\n        RecursiveType other = (RecursiveType) o;\n\n        if (_erasedType != other._erasedType && !_erasedType.equals(other._erasedType)) {\n            return false;\n        }\n        if (_referencedType == null) {\n            return (other._referencedType == null);\n        }\n        return _referencedType.equals(other._referencedType);\n    }\n\n    @Override\n    protected JavaType _narrow(Class<?> subclass) {\n        /* 02-Nov-2015, tatu: Not 100% sure if right, but assuming that inheritance\n         *    of generic types is never resolved recursively; meaning that possible\n         *    type variables from subclass won't resolve to same instance in this\n         *    type.\n         */\n        if (_erasedType.getRawClass() == subclass) { // right?\n            return this;\n        }\n        return new SimpleType(subclass, _typeParameters,\n                _erasedType.getSuperClass(), // won't matter usually, may be important with recursive ref\n                ObjectArrays.copyOf(_bindings, _bindings.length), _asStatic);\n    }\n\n\n    @Override\n    public JavaType getSuperClass() {\n        if (_referencedType != null) {\n            return _referencedType.getSuperClass();\n        }\n        return _erasedType.getSuperClass();\n    }\n\n    @Override\n    public JavaType findSuperType(Class<?> rawTarget)\n    {\n        if (rawTarget == _erasedType.getRawClass()) {\n            return this;\n        }\n        if (_referencedType != null) {\n            return _referencedType.findSuperType(rawTarget);\n        }\n        return null;\n    }\n\n    @Override\n    public JavaType getContentType() {\n        return null;\n    }\n\n    @Override\n    public JavaType getKeyType() {\n        return null;\n    }\n\n\n    @Override\n    public JavaType refine(Class<?> rawType, TypeBindings bindings,\n            JavaType superClass, JavaType[] superInterfaces)\n    {\n        if (rawType != _erasedType.getRawClass()) {\n            return null; // does not match, can not refine\n        }\n        if (bindings.isEmpty() && (superClass == _superClass) && Arrays.equals(superInterfaces, _interfaces)) {\n            return this; // already resolved, nothing more\n        }\n        if (_referencedType != null) { // or, if fully resolved\n            return _referencedType.refine(rawType, bindings, superClass, superInterfaces);\n        }\n        // if not yet resolved, must create new instance to avoid infinite loop\n        JavaType newSuper = (superClass == null) ? this : superClass;\n        return new RecursiveType(_erasedType, _typeParameters)\n                        .with(this)\n                        .refine(bindings, newSuper, superInterfaces);\n    }\n\n    @Override\n    protected String buildCanonicalName() {\n        return _erasedType.getRawClass().getName();\n    }\n    \n    protected JavaType refine(TypeBindings bindings,\n            JavaType superClass, JavaType[] superInterfaces)\n    {\n        TypeBindings newBindings;\n        if (bindings.isEmpty()) {\n            newBindings = _bindings;\n        } else {\n            if (_bindings.isEmpty()) {\n                newBindings = bindings;\n            } else {\n                newBindings = _bindings.childInstance();\n                for (int i = 0, len = bindings.size(); i < len; ++i) {\n                    newBindings = newBindings.withAdditionalBinding(bindings.getBoundName(i), bindings.getBoundType(i));\n                }\n            }\n        }\n        JavaType[] newInterfaces = _interfaces;\n        if (superInterfaces.length > 0) { // allow overriding...\n            if (_interfaces == null || _interfaces.length == 0) {\n                newInterfaces = superInterfaces;\n            } else { // but merge if we have existing interfaces already\n                newInterfaces = Arrays.copyOf(_interfaces, _interfaces.length + superInterfaces.length);\n                System.arraycopy(superInterfaces, 0, newInterfaces, _interfaces.length, superInterfaces.length);\n                // 24-Feb-2019, tatu: Need to consider dedups/re-sorting?\n                Collections.sort(Arrays.asList(newInterfaces));\n            }\n        }\n        return new ResolvedRecursiveType(_erasedType.getRawClass(), newBindings,\n                superClass, newInterfaces);\n    }\n}",
    "exact_match": false,
    "ast_match": false,
    "compile": false,
    "test": false
}