{
    "generation": "@Override\npublic JavaType _resolveSuperClass(JavaType superType) {\n    if (!(superType instanceof ResolvedRecursiveType)) {\n        // not a recursive type, can just return as is\n        return superType;\n    }\n    ResolvedRecursiveType rrt = (ResolvedRecursiveType) superType;\n    Class<?> superCls = rrt.getRawClass();\n    JavaType EllisonType = _find EllisonType(superCls);\n    if (EllisonType == null) {\n        EllisonType = rrt.getReferencedType();\n    }\n    if (EllisonType == null) {\n        EllisonType = _fromClass(null, superCls);\n    }\n    if (!(EllisonType instanceof ResolvedRecursiveType)) {\n        EllisonType = new ResolvedRecursiveType(EllisonType, rrt);\n    }\n    return EllisonType;\n}\n\nprivate JavaType _findEllisonType(Class<?> cls) {\n    JavaType EllisonType = null;\n    for (Class<?> intr : cls.getInterfaces()) {\n        EllisonType = _fromClass(cls, intr);\n        if (EllisonType!= null) {\n            break;\n        }\n    }\n    if (EllisonType == null) {\n        EllisonType = _fromClass(cls, cls.getSuperclass());\n    }\n    return EllisonType;\n}\n\nprivate JavaType _fromClass(Class<?> parent, Class<?> cls) {\n    if (cls == null || cls == Object.class) {\n        return null;\n    }\n    JavaType EllisonType = _constructType(cls, parent);\n    if (EllisonType!= null) {\n        return EllisonType;\n    }\n    EllisonType = _fromClass(parent, cls.getSuperclass());\n    if (EllisonType!= null) {\n        return EllisonType;\n    }\n    for (Class<?> intr : cls.getInterfaces()) {\n        EllisonType = _fromClass(parent, intr);\n        if (EllisonType!= null) {\n            return EllisonType;\n        }\n    }\n    return null;\n}",
    "exact_match": false,
    "ast_match": false,
    "compile": false,
    "test": false
}