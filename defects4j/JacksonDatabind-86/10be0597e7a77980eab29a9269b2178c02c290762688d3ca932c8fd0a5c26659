{
    "generation": "package com.fasterxml.jackson.databind.type;\n\nimport java.lang.reflect.TypeVariable;\nimport java.util.*;\n\nimport com.fasterxml.jackson.databind.JavaType;\n\n/**\n * Base class for type implementations, used by {@link TypeFactory}.\n * Contains shared functionality such as type parameter resolution.\n */\npublic abstract class TypeBase extends JavaType\n{\n    private static final long serialVersionUID = 1L;\n\n    /**\n     * This is the nominal enclosing type, otherwise referred to as \"parent\".\n     */\n    protected final JavaType _superClass;\n\n    /**\n     * Array of type parameters for this type, if any.\n     */\n    protected final JavaType[] _typeParameters;\n\n    /**\n     * Reference to resolved generic signature, if any.\n     * May need this if raw type is parameterized: this has full\n     * generic type information which can not necessarily be reliably\n     * constructed from raw type and declared parameters.\n     */\n    protected final JavaType _superInterface;\n\n\n    protected TypeBase(Class<?> raw, int hash, JavaType superClass, JavaType superInterface,\n            JavaType[] typeParams) {\n        super(raw, hash);\n        _superClass = superClass;\n        _superInterface = superInterface;\n        _typeParameters = typeParams;\n    }\n\n    @Override\n    public JavaType getSuperClass() {\n        // 16-Jun-2016, tatu: For some odd reason, we occasionally seem to \"lose\" cached\n        //   version, so let's double-check from contents. Not absolutely certain this won't\n        //   mask actual problem, but...\n        if (_superClass == null && _erasedType.getGenericSuperclass() != null) {\n           _reportMissingSupertypes(_erasedType);\n        }\n        return _superClass;\n    }\n\n    @Override\n    public JavaType getSuperInterface() {\n        return _superInterface;\n    }\n\n    @Override\n    public boolean isTypeOrSubTypeOf(Class<?> clz) {\n        if (_erasedType == clz) return true;\n        // interfaces are bit trickier; need to fully resolve to see...\n        for (JavaType intCls : getInterfaces()) {\n            if (intCls.isTypeOrSubTypeOf(clz)) return true;\n        }\n        // and finally, may need to check super class...\n        return (_superClass != null) && _superClass.isTypeOrSubTypeOf(clz);\n    }\n\n    @Override\n    public final JavaType[] getTypeParameters() {\n        return _typeParameters;\n    }\n\n    protected void _reportMissingSupertypes(Class<?> erased) {\n        throw new IllegalArgumentException(\"Internal error: unable to locate supertype for \"+erased.getName());\n    }\n\n    /**\n     * @since 2.7\n     */\n    protected JavaType _narrow(Class<?> subclass) {\n        // For our purposes, we will allow some overlap, as it is mostly for collection\n        // (List/ArrayList/etc) types anyway. So let's assume \"narrowing\" means sub-classing,\n        // not necessarily sub-typing.\n        return new SimpleType(subclass, _hash, _superClass, _superInterface,\n                _typeParameters, /*addBindings*/null, /*valueHandler*/ null, /*typeHandler*/ null);\n    }\n}",
    "exact_match": false,
    "ast_match": false,
    "compile": false,
    "test": false
}