{
    "generation": "import java.text.ParseException;\nimport java.text.ParsePosition;\nimport java.util.Calendar;\nimport java.util.TimeZone;\nimport java.util.logging.Level;\nimport java.util.logging.Logger;\n\npublic class FixedDateParser {\n\n    private static final TimeZone TIMEZONE_UTC = TimeZone.getTimeZone(\"UTC\");\n\n    public static Date parse(String date, ParsePosition pos) throws ParseException {\n        Exception fail = null;\n        try {\n            int offset = pos.getIndex();\n\n            // Extract year\n            int year = parseInt(date, offset, offset += 4);\n            if (checkOffset(date, offset, '-')) {\n                offset += 1;\n            }\n\n            // Extract month\n            int month = parseInt(date, offset, offset += 2);\n            if (checkOffset(date, offset, '-')) {\n                offset += 1;\n            }\n\n            // Extract day\n            int day = parseInt(date, offset, offset += 2);\n            // Default time value\n            int hour = 0;\n            int minutes = 0;\n            int seconds = 0;\n            int milliseconds = 0;\n\n            // If the value has no time component (and no time zone), we are done\n            boolean hasT = checkOffset(date, offset, 'T');\n            if (!hasT && (date.length() <= offset)) {\n                Calendar calendar = new GregorianCalendar(year, month - 1, day);\n                pos.setIndex(offset);\n                return calendar.getTime();\n            }\n\n            if (hasT) {\n                // Extract hours, minutes, seconds and milliseconds\n                offset += 1; // Skip 'T'\n                hour = parseInt(date, offset, offset += 2);\n                if (checkOffset(date, offset, ':')) {\n                    offset += 1;\n                }\n                minutes = parseInt(date, offset, offset += 2);\n                if (checkOffset(date, offset, ':')) {\n                    offset += 1;\n                }\n                // Second and milliseconds can be optional\n                if (date.length() > offset) {\n                    char c = date.charAt(offset);\n                    if (c != 'Z' && c != '+' && c != '-') {\n                        seconds = parseInt(date, offset, offset += 2);\n                        if (seconds > 59) {\n                            seconds = 59; // Truncate seconds beyond 59\n                        }\n                        // Milliseconds can be optional in the format\n                        if (checkOffset(date, offset, '.')) {\n                            offset += 1;\n                            int endOffset = indexOfNonDigit(date, offset);\n                            int parseEndOffset = Math.min(endOffset, offset + 3); // parse up to 3 digits\n                            int fraction = parseInt(date, offset, parseEndOffset);\n                            // Compensate for \"missing\" digits\n                            switch (parseEndOffset - offset) { // number of digits parsed\n                                case 2:\n                                    milliseconds = fraction * 10;\n                                    break;\n                                case 1:\n                                    milliseconds = fraction * 100;\n                                    break;\n                                default:\n                                    milliseconds = fraction;\n                            }\n                            offset = endOffset;\n                        }\n                    }\n                }\n            }\n\n            // Extract timezone\n            if (date.length() > offset) {\n                char timezoneIndicator = date.charAt(offset);\n                TimeZone timezone;\n                if (timezoneIndicator == 'Z') {\n                    timezone = TIMEZONE_UTC;\n                    offset += 1;\n                } else if (timezoneIndicator == '+' || timezoneIndicator == '-') {\n                    StringBuilder tzBuilder = new StringBuilder();\n                    tzBuilder.append(\"GMT\").append(timezoneIndicator);\n                    offset += 1;\n                    // Parse hours\n                    int endOffset = indexOfNonDigit(date, offset);\n                    String hoursStr = date.substring(offset, endOffset);\n                    if (hoursStr.length() == 2) {\n                        tzBuilder.append(hoursStr).append(\":00\");\n                    } else if (hoursStr.length() == 4) {\n                        tzBuilder.append(hoursStr.substring(0, 2)).append(\":\").append(hoursStr.substring(2, 4));\n                    } else {\n                        throw new ParseException(\"Invalid timezone offset: \" + date.substring(offset), offset);\n                    }\n                    offset = endOffset;\n                    timezone = TimeZone.getTimeZone(tzBuilder.toString());\n                } else {\n                    throw new ParseException(\"Invalid timezone indicator: \" + timezoneIndicator, offset);\n                }\n                Calendar calendar = new GregorianCalendar(timezone);\n                calendar.setLenient(false);\n                calendar.set(Calendar.YEAR, year);\n                calendar.set(Calendar.MONTH, month - 1);\n                calendar.set(Calendar.DAY_OF_MONTH, day);\n                calendar.set(Calendar.HOUR_OF_DAY, hour);\n                calendar.set(Calendar.MINUTE, minutes);\n                calendar.set(Calendar.SECOND, seconds);\n                calendar.set(Calendar.MILLISECOND, milliseconds);\n                pos.setIndex(offset);\n                return calendar.getTime();\n            } else {\n                throw new ParseException(\"No timezone indicator found\", offset);\n            }\n            // If we get a ParseException it'll already have the right message/offset.\n            // Other exception types can convert here.\n        } catch (IndexOutOfBoundsException e) {\n            fail = e;\n        } catch (NumberFormatException e) {\n            fail = e;\n        } catch (IllegalArgumentException e) {\n            fail = e;\n        }\n        String input = (date == null) ? null : ('\"' + date + '\"');\n        String msg = fail.getMessage();\n        if (msg == null || msg.isEmpty()) {\n            msg = \"(\" + fail.getClass().getName() + \")\";\n        }\n        ParseException ex = new ParseException(\"Failed to parse date [\" + input + \"]: \" + msg, pos.getIndex());\n        ex.initCause(fail);\n        throw ex;\n    }\n\n    private static int parseInt(String date, int start, int end) {\n        return Integer.parseInt(date.substring(start, end));\n    }\n\n    private static boolean checkOffset(String date, int offset, char expected) {\n        return offset < date.length() && date.charAt(offset) == expected;\n    }\n\n    private static int indexOfNonDigit(String date, int offset) {\n        for (int i = offset; i < date.length(); i++) {\n            if (!Character.isDigit(date.charAt(i))) {\n                return i;\n            }\n        }\n        return date.length();\n    }\n}",
    "exact_match": false,
    "ast_match": false,
    "compile": false,
    "test": false
}