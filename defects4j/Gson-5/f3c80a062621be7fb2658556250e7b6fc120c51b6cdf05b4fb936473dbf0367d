{
    "generation": "import java.text.ParsePosition;\nimport java.text.ParseException;\nimport java.util.Calendar;\nimport java.util.TimeZone;\n\npublic class DefaultDateTypeAdapter {\n    static final TimeZone TIMEZONE_UTC = TimeZone.getTimeZone(\"UTC\");\n\n    /**\n     * Parse a date from ISO-8601 formatted string. It expects a format\n     * [yyyy-MM-dd|yyyyMMdd][T(hh:mm[:ss[.sss]]|hhmm[ss[.sss]])]?[Z|[+-]hh[:mm]]]\n     *\n     * @param date ISO string to parse in the appropriate format.\n     * @param pos The position to start parsing from, updated to where parsing stopped.\n     * @return the parsed date\n     * @throws ParseException if the date is not in the appropriate format\n     */\n    public static Date parse(String date, ParsePosition pos) throws ParseException {\n        int offset = pos.getIndex();\n\n        // Extract year\n        int year = parseInt(date, offset, offset += 4);\n        if (checkOffset(date, offset, '-')) {\n            offset += 1;\n        } else {\n            throw new ParseException(\"Missing separator after year\", offset);\n        }\n\n        // Extract month\n        int month = parseInt(date, offset, offset += 2);\n        if (checkOffset(date, offset, '-')) {\n            offset += 1;\n        } else {\n            throw new ParseException(\"Missing separator after month\", offset);\n        }\n\n        // Extract day\n        int day = parseInt(date, offset, offset += 2);\n\n        // Check for time component\n        if (date.length() > offset) {\n            char c = date.charAt(offset);\n            if (c == 'T') {\n                offset += 1;\n            } else {\n                throw new ParseException(\"Expected 'T' before time component\", offset);\n            }\n\n            // Extract hours\n            int hour = parseInt(date, offset, offset += 2);\n            if (checkOffset(date, offset, ':')) {\n                offset += 1;\n            } else {\n                throw new ParseException(\"Missing separator after hours\", offset);\n            }\n\n            // Extract minutes\n            int minutes = parseInt(date, offset, offset += 2);\n\n            // Extract seconds and milliseconds if present\n            int seconds = 0;\n            int milliseconds = 0;\n            if (date.length() > offset && date.charAt(offset) == ':') {\n                offset += 1;\n                seconds = parseInt(date, offset, offset += 2);\n                if (date.length() > offset && date.charAt(offset) == '.') {\n                    offset += 1;\n                    int endOffset = indexOfNonDigit(date, offset + 1);\n                    int parseEndOffset = Math.min(endOffset, offset + 3);\n                    int fraction = parseInt(date, offset, parseEndOffset);\n                    switch (parseEndOffset - offset) {\n                        case 1:\n                            milliseconds = fraction * 100;\n                            break;\n                        case 2:\n                            milliseconds = fraction * 10;\n                            break;\n                        case 3:\n                            milliseconds = fraction;\n                            break;\n                        default:\n                            throw new ParseException(\"Invalid fraction digits\", offset);\n                    }\n                    offset = endOffset;\n                }\n            }\n\n            // Extract time zone\n            if (date.length() <= offset) {\n                throw new ParseException(\"No time zone indicator\", offset);\n            }\n\n            char timezoneIndicator = date.charAt(offset);\n            TimeZone timezone;\n            if (timezoneIndicator == 'Z') {\n                timezone = TIMEZONE_UTC;\n                offset += 1;\n            } else if (timezoneIndicator == '+' || timezoneIndicator == '-') {\n                int sign = (timezoneIndicator == '+') ? 1 : -1;\n                offset += 1;\n                int tzHour = parseInt(date, offset, offset += 2);\n                int tzMinute = 0;\n                if (date.length() > offset && date.charAt(offset) == ':') {\n                    offset += 1;\n                    tzMinute = parseInt(date, offset, offset += 2);\n                } else if (date.length() > offset) {\n                    tzMinute = parseInt(date, offset, offset += 2);\n                }\n                int tzOffset = (tzHour * 60 + tzMinute) * sign;\n                timezone = TimeZone.getTimeZone(\"GMT\" + String.format(\"%+03d\", tzOffset / 60) + \":\" + String.format(\"%02d\", Math.abs(tzOffset % 60)));\n            } else {\n                throw new ParseException(\"Invalid time zone indicator '\" + timezoneIndicator + \"'\", offset);\n            }\n\n            // Set up calendar\n            Calendar calendar = new GregorianCalendar(timezone);\n            calendar.setLenient(false);\n            calendar.set(Calendar.YEAR, year);\n            calendar.set(Calendar.MONTH, month - 1);\n            calendar.set(Calendar.DAY_OF_MONTH, day);\n            calendar.set(Calendar.HOUR_OF_DAY, hour);\n            calendar.set(Calendar.MINUTE, minutes);\n            calendar.set(Calendar.SECOND, seconds);\n            calendar.set(Calendar.MILLISECOND, milliseconds);\n\n            pos.setIndex(offset);\n            return calendar.getTime();\n        } else {\n            // No time component, assume start of day in UTC\n            Calendar calendar = new GregorianCalendar(TIMEZONE_UTC);\n            calendar.setLenient(false);\n            calendar.set(Calendar.YEAR, year);\n            calendar.set(Calendar.MONTH, month - 1);\n            calendar.set(Calendar.DAY_OF_MONTH, day);\n            calendar.set(Calendar.HOUR_OF_DAY, 0);\n            calendar.set(Calendar.MINUTE, 0);\n            calendar.set(Calendar.SECOND, 0);\n            calendar.set(Calendar.MILLISECOND, 0);\n\n            pos.setIndex(offset);\n            return calendar.getTime();\n        }\n    }\n\n    private static int parseInt(String date, int start, int end) throws ParseException {\n        try {\n            return Integer.parseInt(date.substring(start, end));\n        } catch (NumberFormatException e) {\n            throw new ParseException(\"Unable to parse integer\", start);\n        }\n    }\n\n    private static boolean checkOffset(String date, int offset, char expected) {\n        return offset < date.length() && date.charAt(offset) == expected;\n    }\n\n    private static int indexOfNonDigit(String date, int start) {\n        for (int i = start; i < date.length(); i++) {\n            if (!Character.isDigit(date.charAt(i))) {\n                return i;\n            }\n        }\n        return date.length();\n    }\n}",
    "exact_match": false,
    "ast_match": false,
    "compile": false,
    "test": false
}