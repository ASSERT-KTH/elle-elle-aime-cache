{
    "generation": "import java.text.ParsePosition;\nimport java.text.ParseException;\nimport java.util.Calendar;\nimport java.util.GregorianCalendar;\nimport java.util.TimeZone;\n\npublic class DefaultDateTypeAdapter {\n\n    private static final TimeZone TIMEZONE_UTC = TimeZone.getTimeZone(\"UTC\");\n\n    public static Date parse(String date, ParsePosition pos) throws ParseException {\n        Exception fail = null;\n        try {\n            int offset = pos.getIndex();\n\n            // extract year\n            int year = parseInt(date, offset, offset += 4);\n            if (checkOffset(date, offset, '-')) {\n                offset += 1;\n            }\n\n            // extract month\n            int month = parseInt(date, offset, offset += 2);\n            if (checkOffset(date, offset, '-')) {\n                offset += 1;\n            }\n\n            // extract day\n            int day = parseInt(date, offset, offset += 2);\n            // default time value\n            int hour = 0;\n            int minutes = 0;\n            int seconds = 0;\n            int milliseconds = 0; // always use 0 otherwise returned date will include millis of current time\n\n            // if the value has no time component (and no time zone), we are done\n            boolean hasT = checkOffset(date, offset, 'T');\n\n            if (!hasT && (date.length() <= offset)) {\n                Calendar calendar = new GregorianCalendar(year, month - 1, day);\n                pos.setIndex(offset);\n                return calendar.getTime();\n            }\n\n            if (hasT) {\n                // extract hours, minutes, seconds and milliseconds\n                offset += 1; // skip 'T'\n                hour = parseInt(date, offset, offset += 2);\n                if (checkOffset(date, offset, ':')) {\n                    offset += 1;\n                }\n\n                minutes = parseInt(date, offset, offset += 2);\n                if (checkOffset(date, offset, ':')) {\n                    offset += 1;\n                }\n\n                // seconds and milliseconds can be optional\n                if (date.length() > offset) {\n                    char c = date.charAt(offset);\n                    if (c != 'Z' && c != '+' && c != '-') {\n                        seconds = parseInt(date, offset, offset += 2);\n                        if (seconds > 59 && seconds < 63) seconds = 59; // truncate up to 3 leap seconds\n                        // milliseconds can be optional in the format\n                        if (checkOffset(date, offset, '.')) {\n                            offset += 1;\n                            int endOffset = indexOfNonDigit(date, offset + 1); // assume at least one digit\n                            int parseEndOffset = Math.min(endOffset, offset + 3); // parse up to 3 digits\n                            int fraction = parseInt(date, offset, parseEndOffset);\n                            // compensate for \"missing\" digits\n                            switch (parseEndOffset - offset) { // number of digits parsed\n                                case 2:\n                                    milliseconds = fraction * 10;\n                                    break;\n                                case 1:\n                                    milliseconds = fraction * 100;\n                                    break;\n                                default:\n                                    milliseconds = fraction;\n                            }\n                            offset = endOffset;\n                        }\n                    }\n                }\n            }\n\n            // extract timezone\n            if (date.length() > offset) {\n                char timezoneIndicator = date.charAt(offset);\n                TimeZone timezone;\n                if (timezoneIndicator == 'Z') {\n                    timezone = TIMEZONE_UTC;\n                    offset += 1;\n                } else if (timezoneIndicator == '+' || timezoneIndicator == '-') {\n                    int sign = (timezoneIndicator == '+') ? 1 : -1;\n                    offset += 1; // skip sign\n                    int tzHour = parseInt(date, offset, offset += 2);\n                    int tzMinute = 0;\n                    if (date.length() > offset && date.charAt(offset) == ':') {\n                        offset += 1;\n                        tzMinute = parseInt(date, offset, offset += 2);\n                    } else if (date.length() > offset) {\n                        tzMinute = parseInt(date, offset, offset += 2);\n                    }\n                    int tzOffset = (tzHour * 60) + tzMinute;\n                    tzOffset *= sign;\n                    timezone = TimeZone.getTimeZone(\"GMT\" + String.format(\"%+03d\", tzOffset / 60) + \":\" + String.format(\"%02d\", Math.abs(tzOffset % 60)));\n                } else {\n                    throw new ParseException(\"Invalid time zone indicator '\" + timezoneIndicator + \"'\", offset);\n                }\n\n                Calendar calendar = new GregorianCalendar(timezone);\n                calendar.setLenient(false);\n                calendar.set(Calendar.YEAR, year);\n                calendar.set(Calendar.MONTH, month - 1);\n                calendar.set(Calendar.DAY_OF_MONTH, day);\n                calendar.set(Calendar.HOUR_OF_DAY, hour);\n                calendar.set(Calendar.MINUTE, minutes);\n                calendar.set(Calendar.SECOND, seconds);\n                calendar.set(Calendar.MILLISECOND, milliseconds);\n                pos.setIndex(offset);\n                return calendar.getTime();\n            } else {\n                // No time zone specified, assume UTC\n                Calendar calendar = new GregorianCalendar(TIMEZONE_UTC);\n                calendar.setLenient(false);\n                calendar.set(Calendar.YEAR, year);\n                calendar.set(Calendar.MONTH, month - 1);\n                calendar.set(Calendar.DAY_OF_MONTH, day);\n                calendar.set(Calendar.HOUR_OF_DAY, hour);\n                calendar.set(Calendar.MINUTE, minutes);\n                calendar.set(Calendar.SECOND, seconds);\n                calendar.set(Calendar.MILLISECOND, milliseconds);\n                pos.setIndex(offset);\n                return calendar.getTime();\n            }\n\n        } catch (IndexOutOfBoundsException | NumberFormatException | IllegalArgumentException e) {\n            fail = e;\n        }\n\n        String input = (date == null) ? null : ('\"' + date + '\"');\n        String msg = (fail != null && fail.getMessage() != null && !fail.getMessage().isEmpty()) ? fail.getMessage() : \"(\" + fail.getClass().getName() + \")\";\n        ParseException ex = new ParseException(\"Failed to parse date [\" + input + \"]: \" + msg, pos.getIndex());\n        ex.initCause(fail);\n        throw ex;\n    }\n\n    private static int parseInt(String date, int start, int end) {\n        return Integer.parseInt(date.substring(start, end));\n    }\n\n    private static boolean checkOffset(String date, int offset, char expected) {\n        return offset < date.length() && date.charAt(offset) == expected;\n    }\n\n    private static int indexOfNonDigit(String date, int start) {\n        for (int i = start; i < date.length(); i++) {\n            if (!Character.isDigit(date.charAt(i))) {\n                return i;\n            }\n        }\n        return date.length();\n    }\n}",
    "exact_match": false,
    "ast_match": false,
    "compile": false,
    "test": false
}