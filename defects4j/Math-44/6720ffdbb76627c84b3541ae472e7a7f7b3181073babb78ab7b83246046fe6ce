{
    "generation": "    protected double acceptStep(final AbstractStepInterpolator interpolator,\n                                final double[] y, final double[] yDot, final double tEnd)\n        throws MathIllegalStateException {\n\n        double previousT = interpolator.getGlobalPreviousTime();\n        final double currentT = interpolator.getGlobalCurrentTime();\n        resetOccurred = false;\n\n        // Initialize the events states if not already done\n        if (!statesInitialized) {\n            for (EventState state : eventsStates) {\n                state.reinitializeBegin(interpolator);\n            }\n            statesInitialized = true;\n        }\n\n        // Search for events in the step\n        final int orderingSign = interpolator.isForward() ? +1 : -1;\n        PriorityQueue<EventState> occuringEvents = new PriorityQueue<>((es0, es1) -> \n            orderingSign * Double.compare(es0.getEventTime(), es1.getEventTime())\n        );\n\n        for (final EventState state : eventsStates) {\n            if (state.evaluateStep(interpolator)) {\n                occuringEvents.add(state);\n            }\n        }\n\n        // Process events\n        while (!occuringEvents.isEmpty()) {\n\n            // Get the first event\n            final EventState currentEvent = occuringEvents.poll();\n            final double eventT = currentEvent.getEventTime();\n\n            if (orderingSign * (eventT - previousT) < 0) {\n                throw new MathIllegalStateException(\"Event time is going backward!\");\n            }\n\n            // Restrict the interpolator to the current event\n            interpolator.setSoftPreviousTime(previousT);\n            interpolator.setSoftCurrentTime(eventT);\n\n            // Trigger the event\n            interpolator.setInterpolatedTime(eventT);\n            final double[] eventY = interpolator.getInterpolatedState();\n            currentEvent.stepAccepted(eventT, eventY);\n            isLastStep = currentEvent.stop();\n\n            // Handle the step up to the event\n            for (final StepHandler handler : stepHandlers) {\n                handler.handleStep(interpolator, isLastStep);\n            }\n\n            if (isLastStep) {\n                // Stop if the integration needs to end\n                System.arraycopy(eventY, 0, y, 0, y.length);\n                return eventT;\n            }\n\n            if (currentEvent.reset(eventT, eventY)) {\n                // If a reset occurs, recompute derivatives and stop the step\n                System.arraycopy(eventY, 0, y, 0, y.length);\n                computeDerivatives(eventT, y, yDot);\n                resetOccurred = true;\n\n                interpolator.setSoftPreviousTime(eventT);\n                interpolator.setSoftCurrentTime(currentT);\n                return eventT;\n            }\n\n            // Prepare for the next part of the step\n            previousT = eventT;\n            interpolator.setSoftPreviousTime(eventT);\n            interpolator.setSoftCurrentTime(currentT);\n\n            // Check if the same event occurs again\n            if (currentEvent.evaluateStep(interpolator)) {\n                occuringEvents.add(currentEvent);\n            }\n        }\n\n        // Handle the remaining step after events\n        interpolator.setInterpolatedTime(currentT);\n        final double[] currentY = interpolator.getInterpolatedState();\n        for (final EventState state : eventsStates) {\n            state.stepAccepted(currentT, currentY);\n            isLastStep = isLastStep || state.stop();\n        }\n        isLastStep = isLastStep || Precision.equals(currentT, tEnd, 1);\n\n        for (StepHandler handler : stepHandlers) {\n            handler.handleStep(interpolator, isLastStep);\n        }\n\n        return currentT;\n    }",
    "exact_match": false,
    "ast_match": false,
    "compile": false,
    "test": false
}