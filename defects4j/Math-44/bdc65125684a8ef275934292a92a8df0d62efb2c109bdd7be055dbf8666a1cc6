{
    "generation": "while (!occuringEvents.isEmpty()) {\n\n    // handle the chronologically first event\n    final Iterator<EventState> iterator = occuringEvents.iterator();\n    final EventState currentEvent = iterator.next();\n    iterator.remove();\n\n    // restrict the interpolator to the first part of the step, up to the event\n    final double eventT = currentEvent.getEventTime();\n    interpolator.setSoftPreviousTime(previousT);\n    interpolator.setSoftCurrentTime(eventT);\n\n    // trigger the event\n    interpolator.setInterpolatedTime(eventT);\n    final double[] eventY = interpolator.getInterpolatedState();\n    currentEvent.stepAccepted(eventT, eventY);\n    isLastStep = currentEvent.stop();\n\n    // handle the first part of the step, up to the event\n    for (final StepHandler handler : stepHandlers) {\n        handler.handleStep(interpolator, isLastStep);\n    }\n\n    if (isLastStep) {\n        // the event asked to stop integration\n        System.arraycopy(eventY, 0, y, 0, y.length);\n        return eventT;\n    }\n\n    if (currentEvent.reset(eventT, eventY)) {\n        // some event handler has triggered changes that\n        // invalidate the derivatives, we need to recompute them\n        System.arraycopy(eventY, 0, y, 0, y.length);\n        computeDerivatives(eventT, y, yDot);\n        resetOccurred = true;\n        return eventT;\n    }\n\n    // prepare handling of the remaining part of the step\n    previousT = eventT;\n    interpolator.setSoftPreviousTime(eventT);\n    interpolator.setSoftCurrentTime(currentT);\n\n    // check if the same event occurs again in the remaining part of the step\n    if (currentEvent.evaluateStep(interpolator)) {\n        // the event occurs during the current step\n        occuringEvents.add(currentEvent);\n    }\n\n}",
    "exact_match": false,
    "ast_match": false,
    "compile": false,
    "test": false
}