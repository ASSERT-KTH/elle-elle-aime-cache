{
    "generation": "public double solve(final UnivariateRealFunction f,\n                    final double min, final double max, final double initial)\n    throws MaxIterationsExceededException, FunctionEvaluationException {\n\n    clearResult();\n    verifySequence(min, initial, max);\n\n    // return the initial guess if it is good enough\n    double yInitial = f.value(initial);\n    if (Math.abs(yInitial) <= functionValueAccuracy) {\n        setResult(initial, 0);\n        return result;\n    }\n\n    // return the first endpoint if it is good enough\n    double yMin = f.value(min);\n    if (Math.abs(yMin) <= functionValueAccuracy) {\n        setResult(min, 0);\n        return result;\n    }\n\n    // return the second endpoint if it is good enough\n    double yMax = f.value(max);\n    if (Math.abs(yMax) <= functionValueAccuracy) {\n        setResult(max, 0);\n        return result;\n    }\n\n    // reduce interval if min and initial bracket the root\n    if (yInitial * yMin < 0) {\n        return solve(f, min, max, initial);\n    }\n\n    // reduce interval if initial and max bracket the root\n    if (yInitial * yMax < 0) {\n        return solve(f, initial, max, initial);\n    }\n\n    if (yMin * yMax > 0) {\n        throw MathRuntimeException.createIllegalArgumentException(\n              NON_BRACKETING_MESSAGE, min, max, yMin, yMax);\n    }\n\n    // full Brent algorithm starting with provided initial guess\n    return solve(f, min, max, initial);\n\n}\n\nprivate double solve(final UnivariateRealFunction f,\n                     final double min, final double max, final double initial)\n    throws MaxIterationsExceededException, FunctionEvaluationException {\n\n    double a = min;\n    double b = max;\n    double c = initial;\n    double fa = f.value(a);\n    double fb = f.value(b);\n    double fc = f.value(c);\n\n    for (int i = 0; i < maxIterationCount; i++) {\n        if (Math.abs(fc) < functionValueAccuracy) {\n            setResult(c, i);\n            return result;\n        }\n        if (fa * fc < 0) {\n            b = c;\n            fb = fc;\n        } else {\n            a = c;\n            fa = fc;\n        }\n\n        if (Math.abs(fa) < Math.abs(fb)) {\n            double temp = a;\n            a = b;\n            b = temp;\n            temp = fa;\n            fa = fb;\n            fb = temp;\n        }\n\n        double tol1 = 2 * epsilon * Math.abs(b) + 0.5 * functionValueAccuracy;\n        double m = 0.5 * (a - b);\n        if (Math.abs(m) <= tol1 || fb == 0) {\n            setResult(b, i);\n            return result;\n        }\n\n        double p, q, r;\n        if (Math.abs(e) < tol1 || Math.abs(fa) <= Math.abs(fb)) {\n            e = m;\n            d = e;\n        } else {\n            double s = fb / fa;\n            if (a == c) {\n                p = 2 * m * s;\n                q = 1 - s;\n            } else {\n                q = fa / fc;\n                r = fb / fc;\n                p = s * (2 * m * q * (q - r) - (b - c) * (r - 1));\n                q = (q - 1) * (r - 1) * (s - 1);\n            }\n            if (p > 0) {\n                q = -q;\n            } else {\n                p = -p;\n            }\n            r = e;\n            e = d;\n        }\n\n        if (2 * p < 3 * m * q - Math.abs(tol1 * q) && p < Math.abs(0.5 * r * q)) {\n            d = p / q;\n        } else {\n            d = m;\n            e = m;\n        }\n\n        c = b;\n        fc = fb;\n        if (Math.abs(d) > tol1) {\n            b += d;\n        } else {\n            b += (m > 0 ? tol1 : -tol1);\n        }\n        fb = f.value(b);\n    }\n\n    throw new MaxIterationsExceededException(maxIterationCount);\n}",
    "exact_match": false,
    "ast_match": false,
    "compile": false,
    "test": false
}