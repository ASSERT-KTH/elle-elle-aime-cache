{
    "generation": "public double solve(final UnivariateRealFunction f,\n                    final double min, final double max, final double initial)\n        throws MaxIterationsExceededException, FunctionEvaluationException {\n\n    clearResult();\n    verifySequence(min, initial, max);\n\n    // Evaluate function at the endpoints and initial point\n    double yMin = f.value(min);\n    double yMax = f.value(max);\n    double yInitial = f.value(initial);\n\n    // Check if any of the points is already a root\n    if (Math.abs(yMin) <= functionValueAccuracy) {\n        setResult(min, yMin, 0);\n        return min;\n    }\n    if (Math.abs(yMax) <= functionValueAccuracy) {\n        setResult(max, yMax, 0);\n        return max;\n    }\n    if (Math.abs(yInitial) <= functionValueAccuracy) {\n        setResult(initial, yInitial, 0);\n        return initial;\n    }\n\n    // Check if the function values at min and max have the same sign\n    if (yMin * yMax > 0) {\n        throw MathRuntimeException.createIllegalArgumentException(\n                NON_BRACKETING_MESSAGE, min, max, yMin, yMax);\n    }\n\n    // Determine the interval to use\n    double a = min;\n    double fa = yMin;\n    double b = max;\n    double fb = yMax;\n    double c;\n    double fc;\n\n    // Choose c as the initial point if it lies within [a, b]\n    if (initial >= a && initial <= b) {\n        c = initial;\n        fc = yInitial;\n    } else {\n        // If initial is outside [a, b], set c to the closer endpoint\n        if (Math.abs(initial - a) < Math.abs(initial - b)) {\n            c = a;\n            fc = fa;\n        } else {\n            c = b;\n            fc = fb;\n        }\n    }\n\n    // If c is not equal to a or b, and the function values at a, b, and c\n    // allow for a quadratic interpolation, proceed with Brent's method\n    if ((c != a && c != b) && (fa != fb && fb != fc && fc != fa)) {\n        return solve(f, a, fa, b, fb, c, fc);\n    } else {\n        // Otherwise, perform a bisection step\n        double d = 0.5 * (a + b);\n        double fd = f.value(d);\n        return solve(f, a, fa, b, fb, d, fd);\n    }\n}",
    "exact_match": false,
    "ast_match": false,
    "compile": true,
    "test": false
}