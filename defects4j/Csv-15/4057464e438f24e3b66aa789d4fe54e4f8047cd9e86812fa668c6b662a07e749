{
    "generation": "private void printAndQuote(final Object object, final CharSequence value, final int offset, final int len,\n        final Appendable out, final boolean newRecord) throws IOException {\n    boolean quote = false;\n    int start = offset;\n    int pos = offset;\n    final int end = offset + len;\n\n    final char delimChar = getDelimiter();\n    final char quoteChar = getQuoteCharacter().charValue();\n\n    QuoteMode quoteModePolicy = getQuoteMode();\n    if (quoteModePolicy == null) {\n        quoteModePolicy = QuoteMode.MINIMAL;\n    }\n    switch (quoteModePolicy) {\n    case ALL:\n    case ALL_NON_NULL:\n        quote = true;\n        break;\n    case NON_NUMERIC:\n        quote = !(object instanceof Number);\n        break;\n    case NONE:\n        // Use the existing escaping code\n        printAndEscape(value, offset, len, out);\n        return;\n    case MINIMAL:\n        if (len <= 0) {\n            // always quote an empty token that is the first\n            // on the line, as it may be the only thing on the\n            // line. If it were not quoted in that case,\n            // an empty line has no tokens.\n            if (newRecord) {\n                quote = true;\n            }\n        } else {\n            char c = value.charAt(pos);\n\n            if (newRecord && (c < 0x20 || c > 0x7E || c == 0x80 || c == 0x82 || c == 0x83 || c == 0x84 || c == 0x85 || c == 0x86 || c == 0x87 || c == 0x88 || c == 0x89 || c == 0x8A || c == 0x8B || c == 0x8C || c == 0x8E || c == 0x91 || c == 0x92 || c == 0x93 || c == 0x94 || c == 0x95 || c == 0x96 || c == 0x97 || c == 0x98 || c == 0x99 || c == 0x9A || c == 0x9B || c == 0x9C || c == 0x9E || c == 0x9F || c == 0xA0 || c == 0xA1 || c == 0xA2 || c == 0xA3 || c == 0xA4 || c == 0xA5 || c == 0xA6 || c == 0xA7 || c == 0xA8 || c == 0xA9 || c == 0xAA || c == 0xAB || c == 0xAC || c == 0xAD || c == 0xAE || c == 0xAF || c == 0xB0 || c == 0xB1 || c == 0xB2 || c == 0xB3 || c == 0xB4 || c == 0xB5 || c == 0xB6 || c == 0xB7 || c == 0xB8 || c == 0xB9 || c == 0xBA || c == 0xBB || c == 0xBC || c == 0xBD || c == 0xBE || c == 0xBF)) {\n                quote = true;\n            } else if (c <= COMMENT) {\n                // Some other chars at the start of a value caused the parser to fail, so for now\n                // encapsulate if we start in anything less than '#'. We are being conservative\n                // by including the default comment char too.\n                quote = true;\n            } else {\n                while (pos < end) {\n                    c = value.charAt(pos);\n                    if (c == LF || c == CR || c == quoteChar || c == delimChar) {\n                        quote = true;\n                        break;\n                    }\n                    pos++;\n                }\n\n                if (!quote) {\n                    pos = end - 1;\n                    c = value.charAt(pos);\n                    // Some other chars at the end caused the parser to fail, so for now\n                    // encapsulate if we end in anything less than ' '\n                    if (c <= SP) {\n                        quote = true;\n                    }\n                }\n            }\n        }\n\n        if (!quote) {\n            // no encapsulation needed - write out the original value\n            out.append(value, start, end);\n            return;\n        }\n        break;\n    default:\n        throw new IllegalStateException(\"Unexpected Quote value: \" + quoteModePolicy);\n    }\n\n    if (!quote) {\n        // no encapsulation needed - write out the original value\n        out.append(value, start, end);\n        return;\n    }\n\n    // we hit something that needed encapsulation\n    out.append(quoteChar);\n\n    // Pick up where we left off: pos should be positioned on the first character that caused\n    // the need for encapsulation.\n    while (pos < end) {\n        final char c = value.charAt(pos);\n        if (c == quoteChar) {\n            // write out the chunk up until this point\n\n            // add 1 to the length to write out the encapsulator also\n            out.append(value, start, pos + 1);\n            // put the next starting position on the encapsulator so we will\n            // write it out again with the next string (effectively doubling it)\n            start = pos;\n        }\n        pos++;\n    }\n\n    // write the last segment\n    out.append(value, start, pos);\n    out.append(quoteChar);\n}",
    "exact_match": false,
    "ast_match": false,
    "compile": true,
    "test": false
}