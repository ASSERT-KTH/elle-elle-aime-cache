{
    "generation": "\t@Override\n\tpublic JsonToken nextToken() throws IOException {\n\t\t// Check for _allowMultipleMatches - false and at least there is one token - which is _currToken\n\t\t// check for no buffered context _exposedContext - null\n\t\t// If all the conditions matches then check for scalar / non-scalar property\n\t\t\t// if not scalar and ended successfully, then return null\n\t\t\t// else if scalar, and scalar not present in obj/array and !includePath and INCLUDE_ALL matched once\n\t\t\t// then return null\n\t\tTokenFilterContext ctxt = _exposedContext;\n\n\t\tif (ctxt != null) {\n\t\t\twhile (true) {\n\t\t\t\tJsonToken t = ctxt.nextTokenToRead();\n\t\t\t\tif (t != null) {\n\t\t\t\t\t_currToken = t;\n\t\t\t\t\treturn t;\n\t\t\t\t}\n\t\t\t\t// all done with buffered stuff?\n\t\t\t\tif (ctxt == _headContext) {\n\t\t\t\t\t_exposedContext = null;\n\t\t\t\t\tif (ctxt.inArray()) {\n\t\t\t\t\t\tt = delegate.getCurrentToken();\n\t\t\t\t\t\t// Is this guaranteed to work without further checks?\n\t\t\t\t\t\t// if (t != JsonToken.START_ARRAY) {\n\t\t\t\t\t\t_currToken = t;\n\t\t\t\t\t\treturn t;\n\t\t\t\t\t}\n\n\t\t\t\t\t// Almost! Most likely still have the current token;\n\t\t\t\t\t// with the sole exception of\n\t\t\t\t\t/*\n\t\t\t\t\tt = delegate.getCurrentToken();\n\t\t\t\t\tif (t != JsonToken.FIELD_NAME) {\n\t\t\t\t\t\t_currToken = t;\n\t\t\t\t\t\treturn t;\n\t\t\t\t\t}\n\t\t\t\t\t*/\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\t// If not, traverse down the context chain\n\t\t\t\tctxt = _headContext.findChildOf(ctxt);\n\t\t\t\t_exposedContext = ctxt;\n\t\t\t\tif (ctxt == null) { // should never occur\n\t\t\t\t\tthrow _constructError(\"Unexpected problem: chain of filtered context broken\");\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t// If not, need to read more. If we got any:\n\t\tJsonToken t = delegate.nextToken();\n\t\tif (t == null) {\n\t\t\t// no strict need to close, since we have no state here\n\t\t\treturn (_currToken = t);\n\t\t}\n\n\t\t// otherwise... to include or not?\n\t\tTokenFilter f;\n\n\t\tswitch (t.id()) {\n\t\t\tcase ID_START_ARRAY:\n\t\t\t\tf = _itemFilter;\n\t\t\t\tif (f == TokenFilter.INCLUDE_ALL) {\n\t\t\t\t\t_headContext = _headContext.createChildArrayContext(f, true);\n\t\t\t\t\treturn (_currToken = t);\n\t\t\t\t}\n\t\t\t\tif (f == null) { // does this occur?\n\t\t\t\t\tdelegate.skipChildren();\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\t// Otherwise still iffy, need to check\n\t\t\t\tf = _headContext.checkValue(f);\n\t\t\t\tif (f == null) {\n\t\t\t\t\tdelegate.skipChildren();\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tif (f != TokenFilter.INCLUDE_ALL) {\n\t\t\t\t\tf = f.filterStartArray();\n\t\t\t\t}\n\t\t\t\t_itemFilter = f;\n\t\t\t\tif (f == TokenFilter.INCLUDE_ALL) {\n\t\t\t\t\t_headContext = _headContext.createChildArrayContext(f, true);\n\t\t\t\t\treturn (_currToken = t);\n\t\t\t\t}\n\t\t\t\t_headContext = _headContext.createChildArrayContext(f, false);\n\n\t\t\t\t// Also: only need buffering if parent path to be included\n\t\t\t\tif (_includePath) {\n\t\t\t\t\tt = _nextTokenWithBuffering(_headContext);\n\t\t\t\t\tif (t != null) {\n\t\t\t\t\t\t_currToken = t;\n\t\t\t\t\t\treturn t;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tbreak;\n\n\t\t\tcase ID_START_OBJECT:\n\t\t\t\tf = _itemFilter;\n\t\t\t\tif (f == TokenFilter.INCLUDE_ALL) {\n\t\t\t\t\t_headContext = _headContext.createChildObjectContext(f, true);\n\t\t\t\t\treturn (_currToken = t);\n\t\t\t\t}\n\t\t\t\tif (f == null) { // does this occur?\n\t\t\t\t\tdelegate.skipChildren();\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\t// Otherwise still iffy, need to check\n\t\t\t\tf = _headContext.checkValue(f);\n\t\t\t\tif (f == null) {\n\t\t\t\t\tdelegate.skipChildren();\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tif (f != TokenFilter.INCLUDE_ALL) {\n\t\t\t\t\tf = f.filterStartObject();\n\t\t\t\t}\n\t\t\t\t_itemFilter = f;\n\t\t\t\tif (f == TokenFilter.INCLUDE_ALL) {\n\t\t\t\t\t_headContext = _headContext.createChildObjectContext(f, true);\n\t\t\t\t\treturn (_currToken = t);\n\t\t\t\t}\n\t\t\t\t_headContext = _headContext.createChildObjectContext(f, false);\n\t\t\t\t// Also: only need buffering if parent path to be included\n\t\t\t\tif (_includePath) {\n\t\t\t\t\tt = _nextTokenWithBuffering(_headContext);\n\t\t\t\t\tif (t != null) {\n\t\t\t\t\t\t_currToken = t;\n\t\t\t\t\t\treturn t;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t// note: inclusion of surrounding Object handled separately via\n\t\t\t\t// FIELD_NAME\n\t\t\t\tbreak;\n\n\t\t\tcase ID_END_ARRAY:\n\t\t\tcase ID_END_OBJECT:\n\t\t\t\t{\n\t\t\t\t\tboolean returnEnd = _headContext.isStartHandled();\n\t\t\t\t\tf = _headContext.getFilter();\n\t\t\t\t\tif ((f != null) && (f != TokenFilter.INCLUDE_ALL)) {\n\t\t\t\t\t\tf.filterFinishArray();\n\t\t\t\t\t}\n\t\t\t\t\t_headContext = _headContext.getParent();\n\t\t\t\t\t_itemFilter = _headContext.getFilter();\n\t\t\t\t\tif (returnEnd) {\n\t\t\t\t\t\treturn (_currToken = t);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tbreak;\n\n\t\t\tcase ID_FIELD_NAME:\n\t\t\t\t{\n\t\t\t\t\tfinal String name = delegate.getCurrentName();\n\t\t\t\t\t// note: this will also set 'needToHandleName'\n\t\t\t\t\tf = _headContext.setFieldName(name);\n\t\t\t\t\tif (f == TokenFilter.INCLUDE_ALL) {\n\t\t\t\t\t\t_itemFilter = f;\n\t\t\t\t\t\tif (!_includePath) {\n\t\t\t\t\t\t\t// Minor twist here: if parent NOT included, may need to induce output of\n\t\t\t\t\t\t\t// surrounding START_OBJECT/END_OBJECT\n\t\t\t\t\t\t\tif (_includeImmediateParent && !_headContext.isStartHandled()) {\n\t\t\t\t\t\t\t\tt = _headContext.nextTokenToRead(); // returns START_OBJECT but also marks it handled\n\t\t\t\t\t\t\t\t_exposedContext = _headContext;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\treturn (_currToken = t);\n\t\t\t\t\t}\n\t\t\t\t\tif (f == null) {\n\t\t\t\t\t\tdelegate.nextToken();\n\t\t\t\t\t\tdelegate.skipChildren();\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\tf = f.includeProperty(name);\n\t\t\t\t\tif (f == null) {\n\t\t\t\t\t\tdelegate.nextToken();\n\t\t\t\t\t\tdelegate.skipChildren();\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\t_itemFilter = f;\n\t\t\t\t\tif (f == TokenFilter.INCLUDE_ALL) {\n                        if (!_allowMultipleMatches) {\n                            _headContext.markEnded();\n                        }\n\t\t\t\t\t\tif (_includePath) {\n\t\t\t\t\t\t\treturn (_currToken = t);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tif (_includePath) {\n\t\t\t\t\t\tt = _nextTokenWithBuffering(_headContext);\n\t\t\t\t\t\tif (t != null) {\n\t\t\t\t\t\t\t_currToken = t;\n\t\t\t\t\t\t\treturn t;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\n\t\t\tdefault: // scalar value\n\t\t\t\tf = _itemFilter;\n\t\t\t\tif (f == TokenFilter.INCLUDE_ALL) {\n\t\t\t\t\treturn (_currToken = t);\n\t\t\t\t}\n\t\t\t\tif (f != null) {\n\t\t\t\t\tf = _headContext.checkValue(f);\n\t\t\t\t\tif ((f == TokenFilter.INCLUDE_ALL)\n\t\t\t\t\t\t\t|| ((f != null) && f.includeValue(delegate))) {\n\t\t\t\t\t\treturn (_currToken = t);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t// Otherwise not included (leaves must be explicitly included)\n\t\t\t\tbreak;\n\t\t}\n\n\t\t// We get here if token was not yet found; offlined handling\n\t\treturn _nextToken2();\n\t}",
    "exact_match": false,
    "ast_match": false,
    "compile": false,
    "test": false
}