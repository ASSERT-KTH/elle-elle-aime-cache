{
    "generation": "@Override\npublic JsonToken nextToken() throws IOException\n{\n    //... (unchanged code)\n\n    //... (inside the switch statement, case ID_FIELD_NAME)\n    case ID_FIELD_NAME:\n        {\n            final String name = delegate.getCurrentName();\n            // note: this will also set 'needToHandleName'\n            f = _headContext.setFieldName(name);\n            if (f == TokenFilter.INCLUDE_ALL) {\n                _itemFilter = f;\n                if (!_includePath) {\n                    // Minor twist here: if parent NOT included, may need to induce output of\n                    // surrounding START_OBJECT/END_OBJECT\n                    if (_includeImmediateParent &&!_headContext.isStartHandled()) {\n                        t = _headContext.nextTokenToRead(); // returns START_OBJECT but also marks it handled\n                        _exposedContext = _headContext;\n                    }\n                }\n                return (_currToken = t);\n            }\n            if (f == null) {\n                delegate.nextToken();\n                delegate.skipChildren();\n                break;\n            }\n            f = f.includeProperty(name);\n            if (f == null) {\n                delegate.nextToken();\n                delegate.skipChildren();\n                break;\n            }\n            _itemFilter = f;\n            if (f == TokenFilter.INCLUDE_ALL) {\n                if (_includePath ||!_allowMultipleMatches) {\n                    return (_currToken = t);\n                }\n            }\n            if (_includePath) {\n                t = _nextTokenWithBuffering(_headContext);\n                if (t!= null) {\n                    _currToken = t;\n                    return t;\n                }\n            }\n            break;\n        }\n\n    //... (unchanged code)\n}",
    "exact_match": false,
    "ast_match": false,
    "compile": false,
    "test": false
}