{
    "generation": "    /**\n     * <p>Gets the greatest common divisor of the absolute value of\n     * two numbers, using the \"binary gcd\" method which avoids\n     * division and modulo operations.  See Knuth 4.5.2 algorithm B.\n     * This algorithm is due to Josef Stein (1961).</p>\n     *\n     * @param u  a non-zero number\n     * @param v  a non-zero number\n     * @return the greatest common divisor, never zero\n     */\n    private static int greatestCommonDivisor(int u, int v) {\n        if (u == 0 || v == 0) {\n            throw new ArithmeticException(\"Cannot compute gcd for zero values\");\n        }\n\n        // Handle the special case for Integer.MIN_VALUE directly\n        if (u == Integer.MIN_VALUE && v == Integer.MIN_VALUE) {\n            return Integer.MIN_VALUE; // gcd is Integer.MIN_VALUE in this case\n        }\n\n        // Normalize to avoid overflow issues (absolute values with Integer.MIN_VALUE)\n        u = Math.abs(u);\n        v = Math.abs(v);\n\n        if (u == Integer.MIN_VALUE) {\n            u = u / 2; // Safely reduce\n        }\n        if (v == Integer.MIN_VALUE) {\n            v = v / 2; // Safely reduce\n        }\n\n        // Implement binary GCD algorithm\n        int shift;\n        for (shift = 0; ((u | v) & 1) == 0; ++shift) {\n            u >>= 1;\n            v >>= 1;\n        }\n\n        while ((u & 1) == 0) {\n            u >>= 1;\n        }\n\n        do {\n            while ((v & 1) == 0) {\n                v >>= 1;\n            }\n\n            if (u > v) {\n                int temp = u;\n                u = v;\n                v = temp;\n            }\n\n            v -= u;\n        } while (v != 0);\n\n        return u << shift;\n    }",
    "exact_match": false,
    "ast_match": false,
    "compile": true,
    "test": false
}