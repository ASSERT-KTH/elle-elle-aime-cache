{
    "generation": "/** {@inheritDoc} */\npublic double solve(final UnivariateRealFunction f, double min, double max, double initial)\n    throws MaxIterationsExceededException, FunctionEvaluationException {\n    // Check that the initial value is within the interval [min, max]\n    if (initial < min || initial > max) {\n        throw new IllegalArgumentException(\"Initial value is not within the interval [min, max]\");\n    }\n\n    // Initialize the iteration counter\n    int numIterations = 0;\n\n    // Perform the bisection method\n    while (max - min > getAbsoluteAccuracy()) {\n        if (++numIterations > getMaxIterations()) {\n            throw new MaxIterationsExceededException(getMaxIterations(), min, max);\n        }\n\n        double mid = 0.5 * (min + max);\n\n        // Evaluate the function at the boundaries and midpoint\n        double fMin = f.value(min);\n        double fMid = f.value(mid);\n        double fMax = f.value(max);\n\n        // Check for a root at the midpoint\n        if (fMid == 0.0) {\n            return mid;\n        }\n\n        // Determine the subinterval that contains the root\n        if (fMin * fMid < 0) {\n            max = mid;\n        } else if (fMid * fMax < 0) {\n            min = mid;\n        } else {\n            // This should not happen if f is continuous and sign changes occur\n            throw new FunctionEvaluationException(mid, \"Function values at interval endpoints do not bracket a root\");\n        }\n    }\n\n    // Return the midpoint of the final interval\n    return 0.5 * (min + max);\n}",
    "exact_match": false,
    "ast_match": false,
    "compile": false,
    "test": false
}