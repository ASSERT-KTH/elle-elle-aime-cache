{
    "generation": "  /**\n   * This is the meat of the type checking. It is basically one big switch,\n   * with each case representing one type of parse tree node. The individual\n   * cases are usually pretty straightforward.\n   *\n   * @param t The node traversal object that supplies context, such as the\n   * scope chain to use in name lookups as well as error reporting.\n   * @param n The node being visited.\n   * @param parent The parent of the node n.\n   */\n  public void visit(NodeTraversal t, Node n, Node parent) {\n    JSType childType;\n    JSType leftType, rightType;\n    Node left, right;\n    // To be explicitly set to false if the node is not typeable.\n    boolean typeable = true;\n\n    switch (n.getType()) {\n      ...\n\n      case Token.OBJECTLIT:\n        if (parent.getType() == Token.VAR || parent.getType() == Token.LET || parent.getType() == Token.CONST) {\n          Node varNode = parent.getFirstChild();\n          if (varNode != null && (varNode.getJSType() instanceof EnumType)) {\n              ensureTyped(t, n, varNode.getJSType());\n          } else {\n            ensureTyped(t, n, OBJECT_TYPE);\n          }\n        } else {\n          ensureTyped(t, n, OBJECT_TYPE);\n        }\n        for (Node key : n.children()) {\n          visitObjLitKey(t, key, n);\n        }\n        break;\n\n      case Token.GETPROP:\n        if (getJSType(n.getFirstChild()).isEnumElementType()) {\n          ensureTyped(t, n, NUMBER_TYPE);\n        } else if (n.getFirstChild().isString()) {\n          String strValue = n.getFirstChild().getString();\n          if (\"TRUE\".equals(strValue) || \"FALSE\".equals(strValue)) {\n            ensureTyped(t, n, BOOLEAN_TYPE);\n          }\n        }\n      ...\n\n      default:\n        ...\n    }\n\n    ...\n  }",
    "exact_match": false,
    "ast_match": false,
    "compile": false,
    "test": false
}