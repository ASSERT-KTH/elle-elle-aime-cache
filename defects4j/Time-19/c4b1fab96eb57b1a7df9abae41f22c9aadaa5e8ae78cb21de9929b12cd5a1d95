{
    "generation": "/**\n * Gets the millisecond offset to subtract from local time to get UTC time.\n * This offset can be used to undo adding the offset obtained by getOffset.\n *\n * <pre>\n * millisLocal == millisUTC   + getOffset(millisUTC)\n * millisUTC   == millisLocal - getOffsetFromLocal(millisLocal)\n * </pre>\n *\n * NOTE: After calculating millisLocal, some error may be introduced. At\n * offset transitions (due to DST or other historical changes), ranges of\n * local times may map to different UTC times.\n * <p>\n * This method will return an offset suitable for calculating an instant\n * after any DST gap. For example, consider a zone with a cutover\n * from 01:00 to 01:59:<br />\n * Input: 00:00  Output: 00:00<br />\n * Input: 00:30  Output: 00:30<br />\n * Input: 01:00  Output: 02:00<br />\n * Input: 01:30  Output: 02:30<br />\n * Input: 02:00  Output: 02:00<br />\n * Input: 02:30  Output: 02:30<br />\n * <p>\n * During a DST overlap (where the local time is ambiguous) this method will return\n * the earlier instant. The combination of these two rules is to always favour\n * daylight (summer) time over standard (winter) time.\n * <p>\n * NOTE: Prior to v2.0, the DST overlap behaviour was not defined and varied by hemisphere.\n * Prior to v1.5, the DST gap behaviour was also not defined.\n *\n * @param instantLocal  the millisecond instant, relative to this time zone, to get the offset for\n * @return the millisecond offset to subtract from local time to get UTC time\n */\npublic int getOffsetFromLocal(long instantLocal) {\n    // Initial estimate of the offset at the local instant\n    final int offsetLocal = getOffset(instantLocal);\n    // Adjust the local instant using this offset estimate to get a UTC instant\n    final long instantAdjusted = instantLocal - offsetLocal;\n    // Recalculate the offset at the adjusted (UTC) instant\n    final int offsetAdjusted = getOffset(instantAdjusted);\n    \n    // If the offsets differ, we're near a DST boundary\n    if (offsetLocal != offsetAdjusted) {\n        // Determine the direction of the offset change\n        int offsetDifference = offsetLocal - offsetAdjusted;\n        \n        // If the local offset is less than the adjusted offset (negative difference),\n        // it indicates a DST transition where local time skips ahead.\n        if (offsetDifference < 0) {\n            // In this case, we need to ensure the time is after the DST gap.\n            // We check the next transition times to see if they differ.\n            long nextLocal = nextTransition(instantAdjusted);\n            long nextAdjusted = nextTransition(instantLocal - offsetAdjusted);\n            if (nextLocal != nextAdjusted) {\n                // If transitions differ, use the original offset\n                return offsetLocal;\n            }\n        } else {\n            // If the local offset is greater than the adjusted offset (positive difference),\n            // it indicates a DST transition where local time repeats.\n            // In this case, we should favor the earlier instant.\n            return offsetAdjusted;\n        }\n    } else if (offsetLocal > 0) {\n        // If offsets are the same and offset is positive, check for previous transitions\n        long prev = previousTransition(instantAdjusted);\n        if (prev < instantAdjusted) {\n            int offsetPrev = getOffset(prev);\n            int diff = offsetPrev - offsetLocal;\n            if (instantAdjusted - prev <= diff) {\n                // If the time is within the transition period, use the previous offset\n                return offsetPrev;\n            }\n        }\n    }\n    // Otherwise, return the adjusted offset\n    return offsetAdjusted;\n}",
    "exact_match": false,
    "ast_match": false,
    "compile": true,
    "test": false
}