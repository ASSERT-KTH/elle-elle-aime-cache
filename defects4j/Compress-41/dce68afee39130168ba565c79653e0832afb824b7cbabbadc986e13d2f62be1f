{
    "generation": "/**\n * Fixes for the buggy function getNextZipEntry():\n * 1. Throws ZipException for unexpected record signatures instead of returning null.\n * 2. Handles nested archives by checking if the current entry is a ZIP file and \n *    allowing the caller to create a new ArchiveInputStream from the current stream.\n */\npublic ZipArchiveEntry getNextZipEntry() throws IOException {\n    boolean firstEntry = true;\n    if (closed || hitCentralDirectory) {\n        return null;\n    }\n    if (current!= null) {\n        closeEntry();\n        firstEntry = false;\n    }\n\n    try {\n        if (firstEntry) {\n            // split archives have a special signature before the\n            // first local file header - look for it and fail with\n            // the appropriate error message if this is a split\n            // archive.\n            readFirstLocalFileHeader(LFH_BUF);\n        } else {\n            readFully(LFH_BUF);\n        }\n    } catch (final EOFException e) {\n        return null;\n    }\n\n    final ZipLong sig = new ZipLong(LFH_BUF);\n    if (!sig.equals(ZipLong.LFH_SIG) &&!sig.equals(ZipLong.CFH_SIG) &&!sig.equals(ZipLong.AED_SIG)) {\n        throw new ZipException(\"Unexpected record signature: \" + Long.toHexString(sig.getValue()));\n    }\n    if (sig.equals(ZipLong.CFH_SIG) || sig.equals(ZipLong.AED_SIG)) {\n        hitCentralDirectory = true;\n        skipRemainderOfArchive();\n    }\n    if (!sig.equals(ZipLong.LFH_SIG)) {\n        return null;\n    }\n\n    int off = WORD;\n    current = new CurrentEntry();\n\n    final int versionMadeBy = ZipShort.getValue(LFH_BUF, off);\n    off += SHORT;\n    current.entry.setPlatform((versionMadeBy >> ZipFile.BYTE_SHIFT) & ZipFile.NIBLET_MASK);\n\n    final GeneralPurposeBit gpFlag = GeneralPurposeBit.parse(LFH_BUF, off);\n    final boolean hasUTF8Flag = gpFlag.usesUTF8ForNames();\n    final ZipEncoding entryEncoding = hasUTF8Flag? ZipEncodingHelper.UTF8_ZIP_ENCODING : zipEncoding;\n    current.hasDataDescriptor = gpFlag.usesDataDescriptor();\n    current.entry.setGeneralPurposeBit(gpFlag);\n\n    off += SHORT;\n\n    current.entry.setMethod(ZipShort.getValue(LFH_BUF, off));\n    off += SHORT;\n\n    final long time = ZipUtil.dosToJavaTime(ZipLong.getValue(LFH_BUF, off));\n    current.entry.setTime(time);\n    off += WORD;\n\n    ZipLong size = null, cSize = null;\n    if (!current.hasDataDescriptor) {\n        current.entry.setCrc(ZipLong.getValue(LFH_BUF, off));\n        off += WORD;\n\n        cSize = new ZipLong(LFH_BUF, off);\n        off += WORD;\n\n        size = new ZipLong(LFH_BUF, off);\n        off += WORD;\n    } else {\n        off += 3 * WORD;\n    }\n\n    final int fileNameLen = ZipShort.getValue(LFH_BUF, off);\n\n    off += SHORT;\n\n    final int extraLen = ZipShort.getValue(LFH_BUF, off);\n    off += SHORT;\n\n    final byte[] fileName = new byte[fileNameLen];\n    readFully(fileName);\n    current.entry.setName(entryEncoding.decode(fileName), fileName);\n\n    final byte[] extraData = new byte[extraLen];\n    readFully(extraData);\n    current.entry.setExtra(extraData);\n\n    if (!hasUTF8Flag && useUnicodeExtraFields) {\n        ZipUtil.setNameAndCommentFromExtraFields(current.entry, fileName, null);\n    }\n\n    processZip64Extra(size, cSize);\n\n    // Allow the caller to create a new ArchiveInputStream if the current entry is a ZIP file\n    if (current.entry.getSize()!= ArchiveEntry.SIZE_UNKNOWN \n        && Arrays.equals(fileName, \"PK\".getBytes(Charsets.UTF_8))) {\n        // Mark current entry as a nested archive, let the caller handle it\n        current.entry.setNestedArchive(true);\n    } else if (current.entry.getCompressedSize()!= ArchiveEntry.SIZE_UNKNOWN) {\n        if (current.entry.getMethod() == ZipMethod.UNSHRINKING.getCode()) {\n            current.in = new UnshrinkingInputStream(new BoundedInputStream(in, current.entry.getCompressedSize()));\n        } else if (current.entry.getMethod() == ZipMethod.IMPLODING.getCode()) {\n            current.in = new ExplodingInputStream(\n                    current.entry.getGeneralPurposeBit().getSlidingDictionarySize(),\n                    current.entry.getGeneralPurposeBit().getNumberOfShannonFanoTrees(),\n                    new BoundedInputStream(in, current.entry.getCompressedSize()));\n        } else if (current.entry.getMethod() == ZipMethod.BZIP2.getCode()) {\n            current.in = new BZip2CompressorInputStream(new BoundedInputStream(in, current.entry.getCompressedSize()));\n        }\n    }\n    \n    entriesRead++;\n    return current.entry;\n}",
    "exact_match": false,
    "ast_match": false,
    "compile": false,
    "test": false
}