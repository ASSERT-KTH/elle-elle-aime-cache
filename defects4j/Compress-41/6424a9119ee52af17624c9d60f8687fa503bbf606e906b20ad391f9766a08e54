{
    "generation": "public ZipArchiveEntry getNextZipEntry() throws IOException {\n    if (closed || hitCentralDirectory) {\n        return null;\n    }\n\n    if (current != null) {\n        closeEntry();\n    }\n\n    try {\n        readFully(LFH_BUF);\n    } catch (EOFException e) {\n        return null;\n    }\n\n    ZipLong sig = new ZipLong(LFH_BUF);\n    if (sig.equals(ZipLong.CFH_SIG) || sig.equals(ZipLong.AED_SIG)) {\n        hitCentralDirectory = true;\n        skipRemainderOfArchive();\n        return null;\n    } else if (!sig.equals(ZipLong.LFH_SIG)) {\n        throw new ZipException(\"Unexpected record signature: \" + sig.getValue());\n    }\n\n    int off = WORD;\n    current = new CurrentEntry();\n\n    int versionMadeBy = ZipShort.getValue(LFH_BUF, off);\n    off += SHORT;\n    current.entry.setPlatform((versionMadeBy >> ZipFile.BYTE_SHIFT) & ZipFile.NIBLET_MASK);\n\n    GeneralPurposeBit gpFlag = GeneralPurposeBit.parse(LFH_BUF, off);\n    boolean hasUTF8Flag = gpFlag.usesUTF8ForNames();\n    ZipEncoding entryEncoding = hasUTF8Flag ? ZipEncodingHelper.UTF8_ZIP_ENCODING : zipEncoding;\n    current.hasDataDescriptor = gpFlag.usesDataDescriptor();\n    current.entry.setGeneralPurposeBit(gpFlag);\n\n    off += SHORT;\n\n    current.entry.setMethod(ZipShort.getValue(LFH_BUF, off));\n    off += SHORT;\n\n    long time = ZipUtil.dosToJavaTime(ZipLong.getValue(LFH_BUF, off));\n    current.entry.setTime(time);\n    off += WORD;\n\n    ZipLong size = null;\n    ZipLong cSize = null;\n    if (!current.hasDataDescriptor) {\n        current.entry.setCrc(ZipLong.getValue(LFH_BUF, off));\n        off += WORD;\n\n        cSize = new ZipLong(LFH_BUF, off);\n        off += WORD;\n\n        size = new ZipLong(LFH_BUF, off);\n        off += WORD;\n    } else {\n        off += 3 * WORD;\n    }\n\n    int fileNameLen = ZipShort.getValue(LFH_BUF, off);\n    off += SHORT;\n\n    int extraLen = ZipShort.getValue(LFH_BUF, off);\n    off += SHORT;\n\n    byte[] fileName = new byte[fileNameLen];\n    readFully(fileName);\n    current.entry.setName(entryEncoding.decode(fileName), fileName);\n\n    byte[] extraData = new byte[extraLen];\n    readFully(extraData);\n    current.entry.setExtra(extraData);\n\n    if (!hasUTF8Flag && useUnicodeExtraFields) {\n        ZipUtil.setNameAndCommentFromExtraFields(current.entry, fileName, null);\n    }\n\n    processZip64Extra(size, cSize);\n\n    if (current.entry.getCompressedSize() != ArchiveEntry.SIZE_UNKNOWN) {\n        switch (current.entry.getMethod()) {\n            case ZipMethod.UNSHRINKING.getCode():\n                current.in = new UnshrinkingInputStream(new BoundedInputStream(in, current.entry.getCompressedSize()));\n                break;\n            case ZipMethod.IMPLODING.getCode():\n                current.in = new ExplodingInputStream(\n                        current.entry.getGeneralPurposeBit().getSlidingDictionarySize(),\n                        current.entry.getGeneralPurposeBit().getNumberOfShannonFanoTrees(),\n                        new BoundedInputStream(in, current.entry.getCompressedSize()));\n                break;\n            case ZipMethod.BZIP2.getCode():\n                current.in = new BZip2CompressorInputStream(new BoundedInputStream(in, current.entry.getCompressedSize()));\n                break;\n            default:\n                current.in = new BoundedInputStream(in, current.entry.getCompressedSize());\n                break;\n        }\n    } else {\n        // Handle cases where compressed size is unknown\n        switch (current.entry.getMethod()) {\n            case ZipMethod.STORED.getCode():\n                current.in = new StoredInputStream(in);\n                break;\n            default:\n                // For other methods, we might need to read until end of entry\n                current.in = new UnknownSizeInputStream(in);\n                break;\n        }\n    }\n\n    entriesRead++;\n    return current.entry;\n}",
    "exact_match": false,
    "ast_match": false,
    "compile": false,
    "test": false
}