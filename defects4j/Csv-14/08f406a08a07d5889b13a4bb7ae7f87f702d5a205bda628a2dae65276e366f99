{
    "generation": "private void printAndQuote(final Object object, final CharSequence value, final int offset, final int len,\n                           final Appendable out, final boolean newRecord) throws IOException {\n    boolean quote = false;\n    int start = offset;\n    int pos = offset;\n    final int end = offset + len;\n\n    final char delimChar = getDelimiter();\n    final char quoteChar = getQuoteCharacter().charValue();\n    final Character escapeChar = getEscapeCharacter();\n\n    QuoteMode quoteModePolicy = getQuoteMode();\n    if (quoteModePolicy == null) {\n        quoteModePolicy = QuoteMode.MINIMAL;\n    }\n    switch (quoteModePolicy) {\n        case ALL:\n            quote = true;\n            break;\n        case NON_NUMERIC:\n            quote = !(object instanceof Number);\n            break;\n        case NONE:\n            // For NONE mode, we do not quote, but still need to handle escaping.\n            printAndEscape(value, offset, len, out, escapeChar);\n            return;\n        case MINIMAL:\n            if (len <= 0) {\n                // Quote empty tokens at the start of a new record.\n                if (newRecord) {\n                    quote = true;\n                }\n            } else {\n                char c = value.charAt(pos);\n\n                // Check if the first character requires quoting according to RFC4180.\n                if (newRecord && (c < '0' || (c > '9' && c < 'A') || (c > 'Z' && c < 'a') || c > 'z')) {\n                    quote = true;\n                } else if (c <= COMMENT) {\n                    quote = true;\n                } else {\n                    while (pos < end) {\n                        c = value.charAt(pos);\n                        if (c == CR || c == LF || c == quoteChar || c == delimChar) {\n                            quote = true;\n                            break;\n                        }\n                        pos++;\n                    }\n\n                    if (!quote) {\n                        pos = end - 1;\n                        c = value.charAt(pos);\n                        if (c <= SP) {\n                            quote = true;\n                        }\n                    }\n                }\n            }\n\n            if (!quote) {\n                // If no quote needed, directly append the value without escaping.\n                out.append(value, start, end);\n                return;\n            }\n            break;\n        default:\n            throw new IllegalStateException(\"Unexpected Quote value: \" + quoteModePolicy);\n    }\n\n    if (!quote) {\n        // No quote needed, directly append the value without escaping.\n        out.append(value, start, end);\n        return;\n    }\n\n    // Encapsulate the value if quoting is required.\n    out.append(quoteChar);\n\n    // Handle the encapsulated value, ensuring correct escaping inside quotes.\n    pos = offset; // Reset pos to start from the beginning again\n    while (pos < end) {\n        final char c = value.charAt(pos);\n        if (c == quoteChar) {\n            // Double the quote character within the quoted field.\n            out.append(value, start, pos);\n            out.append(quoteChar); // Add the first quote\n            start = pos; // Set start to pos for next slice\n        } else if (c == CR || c == LF || (escapeChar != null && c == escapeChar.charValue())) {\n            // Handle special characters that need escaping.\n            out.append(value, start, pos);\n            if (escapeChar != null) {\n                out.append(escapeChar.charValue());\n            }\n            start = pos; // Set start to pos for next slice\n        }\n        pos++;\n    }\n\n    // Append the last segment of the value.\n    out.append(value, start, pos);\n    out.append(quoteChar);\n}\n\n// Helper method to handle escaping without quoting\nprivate void printAndEscape(final CharSequence value, final int offset, final int len, \n                            final Appendable out, final Character escapeChar) throws IOException {\n    int start = offset;\n    int end = offset + len;\n    for (int pos = offset; pos < end; pos++) {\n        char c = value.charAt(pos);\n        if (c == CR || c == LF || (escapeChar != null && c == escapeChar.charValue())) {\n            out.append(value, start, pos);\n            if (escapeChar != null) {\n                out.append(escapeChar.charValue());\n            }\n            start = pos;\n        }\n    }\n    out.append(value, start, end);\n}",
    "exact_match": false,
    "ast_match": false,
    "compile": true,
    "test": false
}