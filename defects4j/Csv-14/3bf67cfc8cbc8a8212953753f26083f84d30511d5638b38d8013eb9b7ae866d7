{
    "generation": "private void printAndQuote(final Object object, final CharSequence value, final int offset, final int len,\n        final Appendable out, final boolean newRecord) throws IOException {\n    boolean quote = false;\n    int start = offset;\n    int pos = offset;\n    final int end = offset + len;\n\n    final char delimChar = getDelimiter();\n    final Character escapeChar = getEscapeCharacter();\n\n    QuoteMode quoteModePolicy = getQuoteMode();\n    if (quoteModePolicy == null) {\n        quoteModePolicy = QuoteMode.MINIMAL;\n    }\n    switch (quoteModePolicy) {\n    case ALL:\n        quote = true;\n        break;\n    case NON_NUMERIC:\n        quote = !(object instanceof Number);\n        break;\n    case NONE:\n        if(escapeChar!=null){\n            escapeAndPrint(value, offset, len, out, escapeChar);\n        }else{\n            out.append(value, start, end);\n        }\n        return;\n    case MINIMAL:\n        // Add the minimal quote checking logic here\n        break;\n    default:\n        throw new IllegalStateException(\"Unexpected Quote value: \" + quoteModePolicy);\n    }\n\n    if (escapeChar != null) {\n        escapeAndPrint(value, offset, len, out, escapeChar);\n    } else {\n        out.append(value, start, end);\n    }\n}\n\nprivate void escapeAndPrint(final CharSequence value, final int offset, final int len,\n        final Appendable out, final Character escapeChar) throws IOException {\n    int pos = offset;\n    final int end = offset + len;\n\n    while (pos < end) {\n        final char c = value.charAt(pos);\n        if (c == escapeChar) {\n            out.append(escapeChar);\n        }\n        out.append(c);\n        pos++;\n    }\n}",
    "exact_match": false,
    "ast_match": false,
    "compile": true,
    "test": false
}