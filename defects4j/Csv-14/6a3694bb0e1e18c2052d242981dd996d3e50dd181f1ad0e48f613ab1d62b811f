{
    "generation": "    // the fixed version of the buggy function\n    private void printAndQuote(final Object object, final CharSequence value, final int offset, final int len,\n            final Appendable out, final boolean newRecord) throws IOException {\n        boolean quote = false;\n        int start = offset;\n        int pos = offset;\n        final int end = offset + len;\n\n        final char delimChar = getDelimiter();\n        final char quoteChar = getQuoteCharacter().charValue();\n\n        QuoteMode quoteModePolicy = getQuoteMode();\n        if (quoteModePolicy == null) {\n            quoteModePolicy = QuoteMode.MINIMAL;\n        }\n        switch (quoteModePolicy) {\n        case ALL:\n            quote = true;\n            break;\n        case NON_NUMERIC:\n            quote = !(object instanceof Number);\n            break;\n        case NONE:\n            // Use the existing printing code without escaping\n            out.append(value, start, end);\n            return;\n        case MINIMAL:\n            if (len <= 0) {\n                // always quote an empty token that is the first on the line\n                if (newRecord) {\n                    quote = true;\n                }\n            } else {\n                char c = value.charAt(pos);\n                if (newRecord && (c < '0' || c > '9' && c < 'A' || c > 'Z' && c < 'a' || c > 'z')) {\n                    quote = true;\n                } else if (c <= COMMENT) {\n                    // Encapsulate if we start with anything less than '#'\n                    quote = true;\n                } else {\n                    while (pos < end) {\n                        c = value.charAt(pos);\n                        if (c == LF || c == CR || c == quoteChar || c == delimChar) {\n                            quote = true;\n                            break;\n                        }\n                        pos++;\n                    }\n                    if (!quote) {\n                        // Check the end of the value for any special characters\n                        pos = end - 1;\n                        c = value.charAt(pos);\n                        if (c <= SP) {\n                            quote = true;\n                        }\n                    }\n                }\n            }\n            break;\n        default:\n            throw new IllegalStateException(\"Unexpected Quote value: \" + quoteModePolicy);\n        }\n\n        // we hit something that needed encapsulation\n        if (quote) {\n            out.append(quoteChar);\n\n            pos = offset;\n            while (pos < end) {\n                final char c = value.charAt(pos);\n                if (c == quoteChar) {\n                    out.append(value, start, pos + 1);\n                    start = pos + 1;\n                }\n                pos++;\n            }\n\n            out.append(value, start, end);\n            out.append(quoteChar);\n        } else {\n            // no encapsulation needed - write out the original value\n            out.append(value, start, end);\n        }\n    }",
    "exact_match": false,
    "ast_match": false,
    "compile": true,
    "test": false
}