{
    "generation": "private void printAndQuote(final Object object, final CharSequence value, final int offset, final int len,\n        final Appendable out, final boolean newRecord) throws IOException {\n    boolean quote = false;\n    int start = offset;\n    int pos = offset;\n    final int end = offset + len;\n\n    final char delimChar = getDelimiter();\n    char quoteChar;\n    Character escapeChar = getEscapeCharacter();\n    if (escapeChar == null) {\n        // This is to retain backward compatibility when the escape char is not set.\n        quoteChar = getQuoteCharacter().charValue();\n    } else {\n        quoteChar = escapeChar.charValue();\n    }\n\n    QuoteMode quoteModePolicy = getQuoteMode();\n    if (quoteModePolicy == null) {\n        quoteModePolicy = QuoteMode.MINIMAL;\n    }\n    switch (quoteModePolicy) {\n    case ALL:\n        quote = true;\n        break;\n    case NON_NUMERIC:\n        quote = !(object instanceof Number);\n        break;\n    case NONE:\n        // Use a new print method that handles escaping directly\n        printAndEscape(value, offset, len, out, escapeChar);\n        return;\n    case MINIMAL:\n        if (len <= 0) {\n            // always quote an empty token that is the first on the line\n            if (newRecord) {\n                quote = true;\n            }\n        } else {\n            char c = value.charAt(pos);\n            // RFC4180 (https://tools.ietf.org/html/rfc4180) TEXTDATA =  %x20-21 / %x23-2B / %x2D-7E\n            if (newRecord && (c < '0' || c > '9' && c < 'A' || c > 'Z' && c < 'a' || c > 'z')) {\n                quote = true;\n            } else if (c <= COMMENT) {\n                // Some other chars at the start of a value caused the parser to fail, so for now\n                // encapsulate if we start in anything less than '#'. We are being conservative\n                // by including the default comment char too.\n                quote = true;\n            } else {\n                while (pos < end) {\n                    c = value.charAt(pos);\n                    if (c == LF || c == CR || c == quoteChar || c == delimChar) {\n                        quote = true;\n                        break;\n                    }\n                    pos++;\n                }\n\n                if (!quote) {\n                    pos = end - 1;\n                    c = value.charAt(pos);\n                    // Some other chars at the end caused the parser to fail, so for now\n                    // encapsulate if we end in anything less than ' '\n                    if (c <= SP) {\n                        quote = true;\n                    }\n                }\n            }\n        }\n\n        if (!quote) {\n            // no encapsulation needed - write out the original value handling escapes\n            out.append(escapeIfNeeded(value, start, end, quoteChar));\n            return;\n        }\n        break;\n    default:\n        throw new IllegalStateException(\"Unexpected Quote value: \" + quoteModePolicy);\n    }\n\n    if (!quote) {\n        // no encapsulation needed - write out the original value handling escapes\n        out.append(escapeIfNeeded(value, start, end, quoteChar));\n        return;\n    }\n\n    // we hit something that needed encapsulation\n    out.append(quoteChar);\n\n    while (pos < end) {\n        final char c = value.charAt(pos);\n        if (c == quoteChar) {\n            // write out the chunk up until this point\n            // add 1 to the length to write out the encapsulator also\n            out.append(escapeIfNeeded(value, start, pos + 1, quoteChar));\n            // put the next starting position on the encapsulator so we will\n            // write it out again with the next string (effectively doubling it)\n            start = pos;\n        }\n        pos++;\n    }\n\n    // write the last segment\n    out.append(escapeIfNeeded(value, start, pos, quoteChar));\n    out.append(quoteChar);\n}\n\nprivate CharSequence escapeIfNeeded(final CharSequence value, int start, int end, char quoteChar) {\n    StringBuilder result = null;\n    for (int i = start; i < end; i++) {\n        if (value.charAt(i) == quoteChar) {\n            if (result == null) {\n                result = new StringBuilder(end - start);\n                result.append(value, start, i);\n            }\n            result.append(quoteChar);\n        } else if (result != null) {\n            result.append(value.charAt(i));\n        }\n    }\n    return result != null ? result : value.subSequence(start, end);\n}",
    "exact_match": false,
    "ast_match": false,
    "compile": false,
    "test": false
}