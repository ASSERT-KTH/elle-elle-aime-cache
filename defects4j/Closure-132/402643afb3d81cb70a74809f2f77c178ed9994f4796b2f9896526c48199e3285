{
    "generation": "/**\n * Try turning IF nodes into smaller HOOKs\n *\n * Returns the replacement for n or the original if no replacement was\n * necessary.\n */\nprivate Node tryMinimizeIf(Node n) {\n\n  Node parent = n.getParent();\n\n  Node cond = n.getFirstChild();\n\n  /* If the condition is a literal, we'll let other\n   * optimizations try to remove useless code.\n   */\n  if (NodeUtil.isLiteralValue(cond, true)) {\n    return n;\n  }\n\n  Node thenBranch = cond.getNext();\n  Node elseBranch = thenBranch.getNext();\n\n  if (elseBranch == null) {\n    // ... rest of the original function ...\n  }\n  else {\n    /* TODO(dcc) This modifies the siblings of n, which is undesirable for a\n     * peephole optimization. This should probably get moved to another pass.\n     */\n    tryRemoveRepeatedStatements(n);\n\n    // if(!x)foo();else bar(); -> x ? bar() : foo();\n    Node newThenBranch;\n    if (!consumesDanglingElse(thenBranch)) {\n      newThenBranch = NodeUtil.newExpr(thenBranch).srcref(thenBranch);\n    } else {\n      newThenBranch = thenBranch;\n    }\n\n    Node newElseBranch;\n    if (!consumesDanglingElse(elseBranch)) {\n      newElseBranch = NodeUtil.newExpr(elseBranch).srcref(elseBranch);\n    } else {\n      newElseBranch = elseBranch;\n    }\n\n    Node hookNode = IR.hook(cond, newThenBranch, newElseBranch).srcref(n);\n    Node exprNode = IR.exprResult(hookNode);\n    parent.replaceChild(n, exprNode);\n    reportCodeChange();\n    return exprNode;\n  }\n\n  return n;\n}",
    "exact_match": false,
    "ast_match": false,
    "compile": true,
    "test": false
}