{
    "generation": "private Node tryMinimizeIf(Node n) {\n  Node parent = n.getParent();\n  Node cond = n.getFirstChild();\n\n  if (NodeUtil.isLiteralValue(cond, true)) {\n    return n;\n  }\n\n  Node thenBranch = cond.getNext();\n  Node elseBranch = thenBranch.getNext();\n\n  if (elseBranch == null) {\n    // ... (keep the existing code for the if-without-else case)\n  }\n\n  tryRemoveRepeatedStatements(n);\n\n  if (cond.isNot() && !consumesDanglingElse(elseBranch)) {\n    n.replaceChild(cond, cond.removeFirstChild());\n    n.removeChild(thenBranch);\n    n.addChildToBack(thenBranch);\n    reportCodeChange();\n    return n;\n  }\n\n  if (isReturnExpressBlock(thenBranch) && isReturnExpressBlock(elseBranch)) {\n    // ... (keep the existing code for return statements)\n  }\n\n  boolean thenBranchIsExpressionBlock = isFoldableExpressBlock(thenBranch);\n  boolean elseBranchIsExpressionBlock = isFoldableExpressBlock(elseBranch);\n\n  if (thenBranchIsExpressionBlock && elseBranchIsExpressionBlock) {\n    Node thenOp = getBlockExpression(thenBranch).getFirstChild();\n    Node elseOp = getBlockExpression(elseBranch).getFirstChild();\n    if (thenOp.getType() == elseOp.getType()) {\n      if (NodeUtil.isAssignmentOp(thenOp)) {\n        Node lhs = thenOp.getFirstChild();\n        if (areNodesEqualForInlining(lhs, elseOp.getFirstChild()) &&\n            !mayEffectMutableState(lhs)) {\n          Node assignName = thenOp.removeFirstChild();\n          Node thenExpr = thenOp.removeFirstChild();\n          Node elseExpr = elseOp.getLastChild();\n          elseOp.removeChild(elseExpr);\n\n          Node hookNode = IR.hook(cond.detachFromParent(), thenExpr, elseExpr).srcref(n);\n          Node assign = new Node(thenOp.getType(), assignName, hookNode).srcref(thenOp);\n          Node expr = NodeUtil.newExpr(assign);\n          parent.replaceChild(n, expr);\n          reportCodeChange();\n          return expr;\n        }\n      }\n    }\n    // if(x)foo();else bar(); -> x?foo():bar()\n    Node expr = IR.exprResult(\n        IR.hook(cond.detachFromParent(), thenOp.detachFromParent(), elseOp.detachFromParent()).srcref(n));\n    parent.replaceChild(n, expr);\n    reportCodeChange();\n    return expr;\n  }\n\n  // ... (keep the rest of the existing code)\n\n  return n;\n}",
    "exact_match": false,
    "ast_match": false,
    "compile": true,
    "test": false
}