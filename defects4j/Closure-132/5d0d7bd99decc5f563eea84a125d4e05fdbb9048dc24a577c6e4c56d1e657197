{
    "generation": "  private Node tryMinimizeIf(Node n) {\n    Node parent = n.getParent();\n    Node cond = n.getFirstChild();\n\n    if (NodeUtil.isLiteralValue(cond, true)) {\n      return n;\n    }\n\n    Node thenBranch = cond.getNext();\n    Node elseBranch = thenBranch.getNext();\n    Node thenOp, elseOp;\n\n    cond.detachFromParent();\n\n    if (elseBranch == null) {\n      // if(x)foo(); -> x && foo();\n      if (isFoldableExpressBlock(thenBranch) && !cond.isNot()) {\n        thenOp = getBlockExpression(thenBranch).removeFirstChild();\n        Node and = IR.and(cond, thenOp).srcref(n);\n        Node newExpr = NodeUtil.newExpr(and);\n        parent.replaceChild(n, newExpr);\n        reportCodeChange();\n        return newExpr;\n      }\n    } else {\n      /* TODO(dcc) This modifies the siblings of n, which is undesirable for a\n       * peephole optimization. This should probably get moved to another pass.\n       */\n      tryRemoveRepeatedStatements(n);\n\n      // if(!x)foo();else bar(); -> if(x)bar();else foo();\n      if (cond.isNot() && !consumesDanglingElse(elseBranch)) {\n        n.replaceChild(cond, cond.removeFirstChild());\n        n.removeChild(thenBranch);\n        n.addChildToBack(thenBranch);\n        reportCodeChange();\n        return n;\n      }\n\n      // if(x)return 1;else return 2; -> return x ? 1 : 2;\n      if (isReturnExpressBlock(thenBranch) && isReturnExpressBlock(elseBranch)) {\n        thenOp = getBlockReturnExpression(thenBranch);\n        elseOp = getBlockReturnExpression(elseBranch);\n        Node hookNode = IR.hook(cond, thenOp, elseOp).srcref(n);\n        Node returnNode = IR.returnNode(hookNode);\n        parent.replaceChild(n, returnNode);\n        reportCodeChange();\n        return returnNode;\n      }\n\n      // if(x)foo();else bar(); -> x ? foo() : bar()\n      if (isFoldableExpressBlock(thenBranch) && isFoldableExpressBlock(elseBranch)) {\n        thenOp = getBlockExpression(thenBranch).removeFirstChild();\n        elseOp = getBlockExpression(elseBranch).removeFirstChild();\n        Node hookNode = IR.hook(cond, thenOp, elseOp).srcref(n);\n        Node expr = NodeUtil.newExpr(hookNode);\n        parent.replaceChild(n, expr);\n        reportCodeChange();\n        return expr;\n      }\n    }\n    cond.insertBefore(n);  // Put the condition back for later checks.\n    return n;\n  }",
    "exact_match": false,
    "ast_match": false,
    "compile": false,
    "test": false
}