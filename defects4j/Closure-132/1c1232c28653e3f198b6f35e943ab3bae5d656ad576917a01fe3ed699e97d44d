{
    "generation": "private Node tryMinimizeIf(Node n) {\n    Node parent = n.getParent();\n    Node cond = n.getFirstChild();\n\n    if (NodeUtil.isLiteralValue(cond, true)) {\n        return n;\n    }\n\n    Node thenBranch = cond.getNext();\n    Node elseBranch = thenBranch.getNext();\n\n    if (elseBranch == null) {\n        if (isFoldableExpressBlock(thenBranch)) {\n            Node expr = getBlockExpression(thenBranch);\n            if (!late && isPropertyAssignmentInExpression(expr)) {\n                return n;\n            }\n\n            if (cond.isNot()) {\n                if (isLowerPrecedenceInExpression(cond, OR_PRECEDENCE) &&\n                    isLowerPrecedenceInExpression(expr.getFirstChild(), OR_PRECEDENCE)) {\n                    return n;\n                }\n\n                Node or = IR.or(cond.removeFirstChild(), expr.removeFirstChild()).srcref(n);\n                Node newExpr = NodeUtil.newExpr(or);\n                parent.replaceChild(n, newExpr);\n                reportCodeChange();\n\n                return newExpr;\n            }\n\n            if (isLowerPrecedenceInExpression(cond, AND_PRECEDENCE) &&\n                isLowerPrecedenceInExpression(expr.getFirstChild(), AND_PRECEDENCE)) {\n                return n;\n            }\n\n            n.removeChild(cond);\n            Node and = IR.and(cond, expr.removeFirstChild()).srcref(n);\n            Node newExpr = NodeUtil.newExpr(and);\n            parent.replaceChild(n, newExpr);\n            reportCodeChange();\n\n            return newExpr;\n        } else {\n            if (NodeUtil.isStatementBlock(thenBranch) && thenBranch.hasOneChild()) {\n                Node innerIf = thenBranch.getFirstChild();\n\n                if (innerIf.isIf()) {\n                    Node innerCond = innerIf.getFirstChild();\n                    Node innerThenBranch = innerCond.getNext();\n                    Node innerElseBranch = innerThenBranch.getNext();\n\n                    if (innerElseBranch == null &&\n                        !(isLowerPrecedenceInExpression(cond, AND_PRECEDENCE) &&\n                          isLowerPrecedenceInExpression(innerCond, AND_PRECEDENCE))) {\n                        n.detachChildren();\n                        n.addChildToBack(IR.and(cond, innerCond.detachFromParent()).srcref(cond));\n                        n.addChildrenToBack(innerThenBranch.detachFromParent());\n                        reportCodeChange();\n                        return n;\n                    }\n                }\n            }\n        }\n\n        return n;\n    }\n\n    tryRemoveRepeatedStatements(n);\n\n    if (cond.isNot() && !consumesDanglingElse(elseBranch)) {\n        n.replaceChild(cond, cond.removeFirstChild());\n        n.removeChild(thenBranch);\n        n.addChildToBack(thenBranch);\n        reportCodeChange();\n        return n;\n    }\n\n    if (isReturnExpressBlock(thenBranch) && isReturnExpressBlock(elseBranch)) {\n        Node thenExpr = getBlockReturnExpression(thenBranch);\n        Node elseExpr = getBlockReturnExpression(elseBranch);\n        n.removeChild(cond);\n        thenExpr.detachFromParent();\n        elseExpr.detachFromParent();\n\n        Node returnNode = IR.returnNode(IR.hook(cond, thenExpr, elseExpr).srcref(n));\n        parent.replaceChild(n, returnNode);\n        reportCodeChange();\n        return returnNode;\n    }\n\n    boolean thenBranchIsExpressionBlock = isFoldableExpressBlock(thenBranch);\n    boolean elseBranchIsExpressionBlock = isFoldableExpressBlock(elseBranch);\n\n    if (thenBranchIsExpressionBlock && elseBranchIsExpressionBlock) {\n        Node thenOp = getBlockExpression(thenBranch).getFirstChild();\n        Node elseOp = getBlockExpression(elseBranch).getFirstChild();\n\n        if (thenOp.getType() == elseOp.getType()) {\n            if (NodeUtil.isAssignmentOp(thenOp)) {\n                Node lhs = thenOp.getFirstChild();\n                if (areNodesEqualForInlining(lhs, elseOp.getFirstChild()) && !mayEffectMutableState(lhs)) {\n                    n.removeChild(cond);\n                    Node assignName = thenOp.removeFirstChild();\n                    Node thenExpr = thenOp.removeFirstChild();\n                    Node elseExpr = elseOp.getLastChild();\n                    elseOp.removeChild(elseExpr);\n\n                    Node hookNode = IR.hook(cond, thenExpr, elseExpr).srcref(n);\n                    Node assign = new Node(thenOp.getType(), assignName, hookNode).srcref(thenOp);\n                    Node expr = NodeUtil.newExpr(assign);\n                    parent.replaceChild(n, expr);\n                    reportCodeChange();\n\n                    return expr;\n                }\n            }\n        }\n\n        // Handle assignment and operation cases\n        if (NodeUtil.isAssignmentOp(thenOp) && NodeUtil.isAssignmentOp(elseOp)) {\n            Node lhs1 = thenOp.getFirstChild();\n            Node lhs2 = elseOp.getFirstChild();\n\n            if (areNodesEqualForInlining(lhs1, lhs2) && !mayEffectMutableState(lhs1)) {\n                Node thenExpr = thenOp.getLastChild();\n                Node elseExpr = elseOp.getLastChild();\n\n                n.removeChild(cond);\n                thenExpr.detachFromParent();\n                elseExpr.detachFromParent();\n\n                Node hookNode = IR.hook(cond, thenExpr, elseExpr).srcref(n);\n                Node assign = new Node(thenOp.getType(), lhs1.cloneTree(), hookNode).srcref(thenOp);\n                Node expr = NodeUtil.newExpr(assign);\n                parent.replaceChild(n, expr);\n                reportCodeChange();\n\n                return expr;\n            }\n        } else if (NodeUtil.isExpressionNode(thenOp) && NodeUtil.isExpressionNode(elseOp)) {\n            Node thenExpr = thenOp.getFirstChild();\n            Node elseExpr = elseOp.getFirstChild();\n\n            n.removeChild(cond);\n            thenExpr.detachFromParent();\n            elseExpr.detachFromParent();\n\n            Node hookNode = IR.hook(cond, thenExpr, elseExpr).srcref(n);\n            Node expr = IR.exprResult(hookNode);\n            parent.replaceChild(n, expr);\n            reportCodeChange();\n\n            return expr;\n        }\n    }\n\n    boolean thenBranchIsVar = isVarBlock(thenBranch);\n    boolean elseBranchIsVar = isVarBlock(elseBranch);\n\n    if (thenBranchIsVar && elseBranchIsExpressionBlock && getBlockExpression(elseBranch).getFirstChild().isAssign()) {\n        Node var = getBlockVar(thenBranch);\n        Node elseAssign = getBlockExpression(elseBranch).getFirstChild();\n\n        Node name1 = var.getFirstChild();\n        Node maybeName2 = elseAssign.getFirstChild();\n\n        if (name1.hasChildren() && maybeName2.isName() && name1.getString().equals(maybeName2.getString())) {\n            Node thenExpr = name1.removeChildren();\n            Node elseExpr = elseAssign.getLastChild().detachFromParent();\n            cond.detachFromParent();\n            Node hookNode = IR.hook(cond, thenExpr, elseExpr).srcref(n);\n            var.detachFromParent();\n            name1.addChildrenToBack(hookNode);\n            parent.replaceChild(n, var);\n            reportCodeChange();\n            return var;\n        }\n    } else if (elseBranchIsVar && thenBranchIsExpressionBlock && getBlockExpression(thenBranch).getFirstChild().isAssign()) {\n        Node var = getBlockVar(elseBranch);\n        Node thenAssign = getBlockExpression(thenBranch).getFirstChild();\n\n        Node maybeName1 = thenAssign.getFirstChild();\n        Node name2 = var.getFirstChild();\n\n        if (name2.hasChildren() && maybeName1.isName() && maybeName1.getString().equals(name2.getString())) {\n            Node thenExpr = thenAssign.getLastChild().detachFromParent();\n            Node elseExpr = name2.removeChildren();\n            cond.detachFromParent();\n            Node hookNode = IR.hook(cond, thenExpr, elseExpr).srcref(n);\n            var.detachFromParent();\n            name2.addChildrenToBack(hookNode);\n            parent.replaceChild(n, var);\n            reportCodeChange();\n            return var;\n        }\n    }\n\n    return n;\n}",
    "exact_match": false,
    "ast_match": false,
    "compile": false,
    "test": false
}