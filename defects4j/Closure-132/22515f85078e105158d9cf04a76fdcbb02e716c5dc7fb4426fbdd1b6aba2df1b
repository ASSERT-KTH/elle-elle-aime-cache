{
    "generation": "private Node tryMinimizeIf(Node n) {\n    Node parent = n.getParent();\n    Node cond = n.getFirstChild();\n\n    // If the condition is a literal, we'll let other optimizations try to remove useless code.\n    if (NodeUtil.isLiteralValue(cond, true)) {\n        return n;\n    }\n\n    Node thenBranch = cond.getNext();\n    Node elseBranch = thenBranch.getNext();\n\n    if (elseBranch == null) {\n        if (isFoldableExpressBlock(thenBranch)) {\n            Node expr = getBlockExpression(thenBranch);\n            if (!late && isPropertyAssignmentInExpression(expr)) {\n                // Keep opportunities for CollapseProperties such as\n                // a.longIdentifier || a.longIdentifier = ... -> var a = ...;\n                // until CollapseProperties has been run.\n                return n;\n            }\n\n            if (cond.isNot()) {\n                // if(!x)bar(); -> x||bar();\n                if (isLowerPrecedenceInExpression(cond, OR_PRECEDENCE) &&\n                    isLowerPrecedenceInExpression(expr.getFirstChild(), OR_PRECEDENCE)) {\n                    // It's not okay to add two sets of parentheses.\n                    return n;\n                }\n\n                Node or = IR.or(\n                    cond.removeFirstChild(),\n                    expr.removeFirstChild()).srcref(n);\n                Node newExpr = NodeUtil.newExpr(or);\n                parent.replaceChild(n, newExpr);\n                reportCodeChange();\n\n                return newExpr;\n            }\n\n            // if(x)foo(); -> x&&foo();\n            if (isLowerPrecedenceInExpression(cond, AND_PRECEDENCE) &&\n                isLowerPrecedenceInExpression(expr.getFirstChild(), AND_PRECEDENCE)) {\n                // One additional set of parentheses is worth the change even if\n                // there is no immediate code size win. However, two extra pair of\n                // {}, we would have to think twice. (unless we know for sure the\n                // we can further optimize its parent.\n                return n;\n            }\n\n            n.removeChild(cond);\n            Node and = IR.and(cond, expr.removeFirstChild()).srcref(n);\n            Node newExpr = NodeUtil.newExpr(and);\n            parent.replaceChild(n, newExpr);\n            reportCodeChange();\n\n            return newExpr;\n        } else {\n            // Try to combine two IF-ELSE\n            if (NodeUtil.isStatementBlock(thenBranch) && thenBranch.hasOneChild()) {\n                Node innerIf = thenBranch.getFirstChild();\n\n                if (innerIf.isIf()) {\n                    Node innerCond = innerIf.getFirstChild();\n                    Node innerThenBranch = innerCond.getNext();\n                    Node innerElseBranch = innerThenBranch.getNext();\n\n                    if (innerElseBranch == null &&\n                        !(isLowerPrecedenceInExpression(cond, AND_PRECEDENCE) &&\n                          isLowerPrecedenceInExpression(innerCond, AND_PRECEDENCE))) {\n                        n.detachChildren();\n                        n.addChildToBack(\n                            IR.and(\n                                cond,\n                                innerCond.detachFromParent())\n                                .srcref(cond));\n                        n.addChildrenToBack(innerThenBranch.detachFromParent());\n                        reportCodeChange();\n                        // Not worth trying to fold the current IF-ELSE into && because\n                        // the inner IF-ELSE wasn't able to be folded into && anyways.\n                        return n;\n                    }\n                }\n            }\n        }\n\n        return n;\n    }\n\n    /* TODO(dcc) This modifies the siblings of n, which is undesirable for a\n     * peephole optimization. This should probably get moved to another pass.\n     */\n    tryRemoveRepeatedStatements(n);\n\n    // if(!x)foo();else bar(); -> if(x)bar();else foo();\n    // An additional set of curly braces isn't worth it.\n    if (cond.isNot() && !consumesDanglingElse(elseBranch)) {\n        n.replaceChild(cond, cond.removeFirstChild());\n        n.removeChild(thenBranch);\n        n.addChildToBack(thenBranch);\n        reportCodeChange();\n        return n;\n    }\n\n    // if(x)return 1;else return 2; -> return x?1:2;\n    if (isReturnExpressBlock(thenBranch) && isReturnExpressBlock(elseBranch)) {\n        Node thenExpr = getBlockReturnExpression(thenBranch);\n        Node elseExpr = getBlockReturnExpression(elseBranch);\n        n.removeChild(cond);\n        thenExpr.detachFromParent();\n        elseExpr.detachFromParent();\n\n        // note - we ignore any cases with \"return;\", technically this\n        // can be converted to \"return undefined;\" or some variant, but\n        // that does not help code size.\n        Node returnNode = IR.returnNode(\n            IR.hook(cond, thenExpr, elseExpr)\n                .srcref(n));\n        parent.replaceChild(n, returnNode);\n        reportCodeChange();\n        return returnNode;\n    }\n\n    boolean thenBranchIsExpressionBlock = isFoldableExpressBlock(thenBranch);\n    boolean elseBranchIsExpressionBlock = isFoldableExpressBlock(elseBranch);\n\n    if (thenBranchIsExpressionBlock && elseBranchIsExpressionBlock) {\n        Node thenExpr = getBlockExpression(thenBranch).getFirstChild();\n        Node elseExpr = getBlockExpression(elseBranch).getFirstChild();\n\n        if (thenExpr.getType() == elseExpr.getType()) {\n            // if(x)a=1;else a=2; -> a=x?1:2;\n            if (NodeUtil.isAssignmentOp(thenExpr)) {\n                Node lhs = thenExpr.getFirstChild();\n                if (areNodesEqualForInlining(lhs, elseExpr.getFirstChild()) &&\n                    // if LHS has side effects, don't proceed [since the optimization\n                    // evaluates LHS before cond]\n                    // NOTE - there are some circumstances where we can\n                    // proceed even if there are side effects...\n                    !mayEffectMutableState(lhs)) {\n\n                    n.removeChild(cond);\n                    Node assignName = thenExpr.removeFirstChild();\n                    Node thenRhs = thenExpr.removeFirstChild();\n                    Node elseRhs = elseExpr.getLastChild();\n                    elseExpr.removeChild(elseRhs);\n\n                    Node hookNode = IR.hook(cond, thenRhs, elseRhs).srcref(n);\n                    Node assign = new Node(thenExpr.getType(), assignName, hookNode)\n                        .srcref(thenExpr);\n                    Node newExpr = NodeUtil.newExpr(assign);\n                    parent.replaceChild(n, newExpr);\n                    reportCodeChange();\n\n                    return newExpr;\n                }\n            }\n        }\n\n        // if(x)foo();else bar(); -> x?foo():bar()\n        n.removeChild(cond);\n        thenExpr.detachFromParent();\n        elseExpr.detachFromParent();\n        Node hookNode = IR.hook(cond, thenExpr, elseExpr).srcref(n);\n        Node newExpr = NodeUtil.newExpr(hookNode);\n        parent.replaceChild(n, newExpr);\n        reportCodeChange();\n\n        return newExpr;\n    }\n\n    // New case to handle assignment to the same variable or property access\n    if (isSimpleAssignmentBlock(thenBranch) && isSimpleAssignmentBlock(elseBranch)) {\n        Node thenAssign = getBlockExpression(thenBranch).getFirstChild();\n        Node elseAssign = getBlockExpression(elseBranch).getFirstChild();\n\n        if (areNodesEqualForInlining(thenAssign.getFirstChild(), elseAssign.getFirstChild())) {\n            Node lhs = thenAssign.getFirstChild().cloneTree();\n            Node thenRhs = thenAssign.getLastChild();\n            Node elseRhs = elseAssign.getLastChild();\n\n            n.removeChild(cond);\n            thenRhs.detachFromParent();\n            elseRhs.detachFromParent();\n\n            Node hookNode = IR.hook(cond, thenRhs, elseRhs).srcref(n);\n            Node assign = new Node(thenAssign.getType(), lhs, hookNode).srcref(thenAssign);\n            Node newExpr = NodeUtil.newExpr(assign);\n            parent.replaceChild(n, newExpr);\n            reportCodeChange();\n\n            return newExpr;\n        }\n    }\n\n    return n;\n}",
    "exact_match": false,
    "ast_match": false,
    "compile": false,
    "test": false
}