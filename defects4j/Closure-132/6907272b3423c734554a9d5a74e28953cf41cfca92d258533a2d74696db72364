{
    "generation": "if (thenBranchIsExpressionBlock && elseBranchIsExpressionBlock) {\n  Node thenOp = getBlockExpression(thenBranch).getFirstChild();\n  Node elseOp = getBlockExpression(elseBranch).getFirstChild();\n  if (thenOp.getType() == elseOp.getType()) {\n    // if(x)a=1;else a=2; -> a=x?1:2;\n    if (NodeUtil.isAssignmentOp(thenOp)) {\n      Node lhs = thenOp.getFirstChild();\n      if (areNodesEqualForInlining(lhs, elseOp.getFirstChild()) &&\n          // if LHS has side effects, don't proceed [since the optimization\n          // evaluates LHS before cond]\n          // NOTE - there are some circumstances where we can\n          // proceed even if there are side effects...\n          !mayEffectMutableState(lhs)) {\n\n        n.removeChild(cond);\n        Node assignName = thenOp.removeFirstChild();\n        Node thenExpr = thenOp.removeFirstChild();\n        Node elseExpr = elseOp.getLastChild();\n        elseOp.removeChild(elseExpr);\n\n        Node hookNode = IR.hook(cond, thenExpr, elseExpr).srcref(n);\n        Node assign = new Node(thenOp.getType(), assignName, hookNode)\n                          .srcref(thenOp);\n        Node expr = NodeUtil.newExpr(assign);\n        parent.replaceChild(n, expr);\n        reportCodeChange();\n\n        return expr;\n      }\n    }\n  }\n  // if(x)foo();else bar(); -> x?foo():bar()\n  n.removeChild(cond);\n  thenOp.detachFromParent();\n  elseOp.detachFromParent();\n  Node expr = IR.exprResult(\n      IR.hook(cond, thenOp, elseExpr).srcref(n));\n  parent.replaceChild(n, expr);\n  reportCodeChange();\n  return expr;\n}",
    "exact_match": false,
    "ast_match": false,
    "compile": false,
    "test": false
}