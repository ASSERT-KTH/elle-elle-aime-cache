{
    "generation": "private Node tryMinimizeIf(Node n) {\n\n    Node parent = n.getParent();\n\n    Node cond = n.getFirstChild();\n\n    /* If the condition is a literal, we'll let other\n     * optimizations try to remove useless code.\n     */\n    if (NodeUtil.isLiteralValue(cond, true)) {\n      return n;\n    }\n\n    Node thenBranch = cond.getNext();\n    Node elseBranch = thenBranch.getNext();\n\n    if (elseBranch == null) {\n      if (isSingleExpressionBlock(thenBranch)) {\n        Node expr = thenBranch.getFirstChild();\n        if (isSimpleAssignment(expr) && areNodesEqualForInlining(expr.getFirstChild(), cond)) {\n          // Transform if(x) y = 0; into y = x ? 0 : y;\n          Node lhs = expr.getFirstChild();\n          Node rhs = expr.getLastChild();\n          Node hookNode = IR.hook(cond, rhs, lhs.cloneTree());\n          Node assign = new Node(Token.ASSIGN, lhs.cloneTree(), hookNode).srcref(expr);\n          Node newExpr = NodeUtil.newExpr(assign).srcref(expr);\n          parent.replaceChild(n, newExpr);\n          reportCodeChange();\n          return newExpr;\n        } else if (isSingleReturn(expr)) {\n          // Transform if(x) return y; into return x ? y : z; where z is the current function return.\n          Node returnNode = IR.returnNode(\n                  IR.hook(cond, expr.getFirstChild(), findReturnVal(parent)).srcref(n));\n          parent.replaceChild(n, returnNode);\n          reportCodeChange();\n          return returnNode;\n        }\n      }\n      return n;\n    }\n\n    boolean thenBranchIsExpressionBlock = isSingleExpressionBlock(thenBranch);\n    boolean elseBranchIsExpressionBlock = isSingleExpressionBlock(elseBranch);\n\n    if (thenBranchIsExpressionBlock && elseBranchIsExpressionBlock) {\n      Node thenOp = thenBranch.getFirstChild();\n      Node elseOp = elseBranch.getFirstChild();\n      if (areSimpleAssignmentsWithEqualLhs(thenOp, elseOp)) {\n        // Transform if(x) y = a; else y = b; into y = x ? a : b;\n        Node hookNode = IR.hook(cond, thenOp.getLastChild(), elseOp.getLastChild()).srcref(n);\n        Node assign = new Node(Token.ASSIGN, thenOp.getFirstChild().cloneTree(), hookNode).srcref(thenOp);\n        Node newExpr = NodeUtil.newExpr(assign);\n        parent.replaceChild(n, newExpr);\n        reportCodeChange();\n        return newExpr;\n      }\n      // Transform if(x) a; else b; into x ? a : b;\n      Node hookNode = IR.hook(cond, thenOp, elseOp).srcref(n);\n      Node newExpr = NodeUtil.newExpr(hookNode);\n      parent.replaceChild(n, newExpr);\n      reportCodeChange();\n      return newExpr;\n    }\n\n    // Other transformations...\n\n    return n;\n}",
    "exact_match": false,
    "ast_match": false,
    "compile": false,
    "test": false
}