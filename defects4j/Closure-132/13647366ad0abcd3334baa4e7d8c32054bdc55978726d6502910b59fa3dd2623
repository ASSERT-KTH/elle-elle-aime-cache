{
    "generation": "private Node tryMinimizeIf(Node n) {\n  Node parent = n.getParent();\n  Node cond = n.getFirstChild();\n\n  if (NodeUtil.isLiteralValue(cond, true)) {\n    return n;\n  }\n\n  Node thenBranch = cond.getNext();\n  Node elseBranch = thenBranch.getNext();\n\n  if (elseBranch == null) {\n    // ... (keep the existing code for the if (elseBranch == null) case)\n    return n;\n  }\n\n  tryRemoveRepeatedStatements(n);\n\n  if (cond.isNot() && !consumesDanglingElse(elseBranch)) {\n    n.replaceChild(cond, cond.removeFirstChild());\n    n.removeChild(thenBranch);\n    n.addChildToBack(thenBranch);\n    reportCodeChange();\n    return n;\n  }\n\n  if (isReturnExpressBlock(thenBranch) && isReturnExpressBlock(elseBranch)) {\n    // ... (keep the existing code for the return expression case)\n    return returnNode;\n  }\n\n  boolean thenBranchIsExpressionBlock = isFoldableExpressBlock(thenBranch);\n  boolean elseBranchIsExpressionBlock = isFoldableExpressBlock(elseBranch);\n\n  if (thenBranchIsExpressionBlock && elseBranchIsExpressionBlock) {\n    Node thenOp = getBlockExpression(thenBranch).getFirstChild();\n    Node elseOp = getBlockExpression(elseBranch).getFirstChild();\n    if (thenOp.getType() == elseOp.getType()) {\n      if (NodeUtil.isAssignmentOp(thenOp)) {\n        Node lhs = thenOp.getFirstChild();\n        if (areNodesEqualForInlining(lhs, elseOp.getFirstChild()) &&\n            !mayEffectMutableState(lhs)) {\n          n.removeChild(cond);\n          Node assignName = thenOp.removeFirstChild();\n          Node thenExpr = thenOp.removeFirstChild();\n          Node elseExpr = elseOp.getLastChild();\n          elseOp.removeChild(elseExpr);\n\n          Node hookNode = IR.hook(cond, thenExpr, elseExpr).srcref(n);\n          Node assign = new Node(thenOp.getType(), assignName, hookNode).srcref(thenOp);\n          Node expr = NodeUtil.newExpr(assign);\n          parent.replaceChild(n, expr);\n          reportCodeChange();\n          return expr;\n        }\n      }\n    }\n    n.removeChild(cond);\n    thenOp.detachFromParent();\n    elseOp.detachFromParent();\n    Node expr = IR.exprResult(IR.hook(cond, thenOp, elseOp).srcref(n));\n    parent.replaceChild(n, expr);\n    reportCodeChange();\n    return expr;\n  }\n\n  boolean thenBranchIsVar = isVarBlock(thenBranch);\n  boolean elseBranchIsVar = isVarBlock(elseBranch);\n\n  if (thenBranchIsVar && elseBranchIsExpressionBlock &&\n      getBlockExpression(elseBranch).getFirstChild().isAssign()) {\n    // ... (keep the existing code for the var/assign case)\n  } else if (elseBranchIsVar && thenBranchIsExpressionBlock &&\n             getBlockExpression(thenBranch).getFirstChild().isAssign()) {\n    // ... (keep the existing code for the assign/var case)\n  }\n\n  return n;\n}",
    "exact_match": false,
    "ast_match": false,
    "compile": false,
    "test": false
}