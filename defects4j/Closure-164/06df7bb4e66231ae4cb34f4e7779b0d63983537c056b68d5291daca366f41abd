{
    "generation": "@Override\npublic boolean isSubtype(JSType other) {\n    if (!(other instanceof ArrowType)) {\n        return false;\n    }\n\n    ArrowType that = (ArrowType) other;\n\n    // this.returnType <: that.returnType (covariant)\n    if (!this.returnType.isSubtype(that.returnType)) {\n        return false;\n    }\n\n    // that.paramType[i] <: this.paramType[i] (contravariant)\n    //\n    // If this.paramType[i] is required,\n    // then that.paramType[i] is required.\n    //\n    // In theory, the \"required-ness\" should work in the other direction as\n    // well. In other words, if we have\n    //\n    // function f(number, number) {}\n    // function g(number) {}\n    //\n    // Then f *should* not be a subtype of g, and g *should* not be\n    // a subtype of f. But in practice, we do not implement it this way.\n    // We want to support the use case where you can pass g where f is\n    // expected, and pretend that g ignores the second argument.\n    // That way, you can have a single \"no-op\" function, and you don't have\n    // to create a new no-op function for every possible type signature.\n    //\n    // So, in this case, g < f, but f !< g\n    Node thisParam = parameters.getFirstChild();\n    Node thatParam = that.parameters.getFirstChild();\n    Node thisParamPrev = null;\n    Node thatParamPrev = null;\n\n    while (thisParam != null || thatParam != null) {\n        if (thisParam == null) {\n            // \"this\" has fewer parameters than \"that\", and \"this\" is not varargs.\n            // \"this\" can't be a supertype, because \"that\" requires more arguments.\n            return false;\n        }\n        if (thatParam == null) {\n            // \"that\" has fewer parameters than \"this\".\n            // Check if \"this\" is varargs or if remaining \"this\" parameters are optional.\n            if (!thisParam.isVarArgs() && !thisParam.isOptionalArg()) {\n                return false;\n            }\n        } else {\n            JSType thisParamType = thisParam.getJSType();\n            JSType thatParamType = thatParam.getJSType();\n\n            if (thatParamType != null) {\n                if (thisParamType == null || !thisParamType.isSubtype(thatParamType)) {\n                    return false;\n                }\n            }\n\n            boolean thisIsVarArgs = thisParam.isVarArgs();\n            boolean thatIsVarArgs = thatParam.isVarArgs();\n\n            if (thisIsVarArgs && thatIsVarArgs) {\n                // Both are varargs, we need to check the type of the vararg parameter\n                if (thatParamType != null && thisParamType != null && !thisParamType.isSubtype(thatParamType)) {\n                    return false;\n                }\n                thisParam = thisParam.getNext();\n                thatParam = thatParam.getNext();\n                break; // varargs matches the rest\n            }\n\n            if (!thatIsVarArgs) {\n                thatParamPrev = thatParam;\n                thatParam = thatParam.getNext();\n            }\n            if (!thisIsVarArgs) {\n                thisParamPrev = thisParam;\n                thisParam = thisParam.getNext();\n            }\n        }\n    }\n\n    return true;\n}",
    "exact_match": false,
    "ast_match": false,
    "compile": true,
    "test": false
}