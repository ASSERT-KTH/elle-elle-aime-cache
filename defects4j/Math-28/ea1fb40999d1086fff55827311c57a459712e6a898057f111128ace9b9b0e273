{
    "generation": "if (minRatioPositions.size() > 1) {\n    // there's a degeneracy as indicated by a tie in the minimum ratio test\n\n    // 1. check if there's an artificial variable that can be forced out of the basis\n    for (Integer row : minRatioPositions) {\n        for (int i = 0; i < tableau.getNumArtificialVariables(); i++) {\n            int column = i + tableau.getArtificialVariableOffset();\n            final double entry = tableau.getEntry(row, column);\n            if (Precision.equals(entry, 1d, maxUlps) && row.equals(tableau.getBasicRow(column))) {\n                return row;\n            }\n        }\n    }\n\n    // 2. apply Bland's rule to prevent cycling:\n    //    take the row for which the corresponding basic variable has the smallest index\n    //\n    // see http://www.stanford.edu/class/msande310/blandrule.pdf\n    // see http://en.wikipedia.org/wiki/Bland%27s_rule (not equivalent to the above paper)\n    //\n    // Additional heuristic: if we did not get a solution after half of maxIterations\n    //                       revert to the simple case of just returning the top-most row\n    // This heuristic is based on empirical data gathered while investigating MATH-828.\n    Integer minRow = null;\n    int minIndex = tableau.getWidth();\n    for (Integer row : minRatioPositions) {\n        int i = tableau.getNumObjectiveFunctions();\n        for (; i < tableau.getWidth() - 1 && minRow != row; i++) {\n            if (row == tableau.getBasicRow(i)) {\n                if (i < minIndex) {\n                    minIndex = i;\n                    minRow = row;\n                }\n            }\n        }\n    }\n    return minRow;\n}",
    "exact_match": false,
    "ast_match": false,
    "compile": false,
    "test": false
}