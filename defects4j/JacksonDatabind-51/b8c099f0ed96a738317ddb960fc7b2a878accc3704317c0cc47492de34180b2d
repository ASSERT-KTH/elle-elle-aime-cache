{
    "generation": "protected final JsonDeserializer<Object> _findDeserializer(DeserializationContext ctxt,\n            String typeId) throws IOException\n{\n    JsonDeserializer<Object> deser = _deserializers.get(typeId);\n    if (deser == null) {\n        JavaType type = _idResolver.typeFromId(ctxt, typeId);\n        if (type == null) {\n            deser = _findDefaultImplDeserializer(ctxt);\n            if (deser == null) {\n                JavaType actual = _handleUnknownTypeId(ctxt, typeId, _idResolver, _baseType);\n                if (actual == null) {\n                    // Instead of returning null, throw an exception to indicate failure\n                    throw JsonMappingException.from(ctxt, \"Cannot resolve type id '\" + typeId + \"' into a subtype of \" + _baseType);\n                }\n                deser = ctxt.findContextualValueDeserializer(actual, _property);\n            }\n        } else {\n            if ((_baseType!= null) && _baseType.getClass() == type.getClass()) {\n                // Additionally, check if the type has type parameters and retain them if possible\n                if (type.hasTypeParameters()) {\n                    type = ctxt.getTypeFactory().constructSpecializedType(_baseType, type.getRawClass(), type.getTypeParameters());\n                } else {\n                    type = ctxt.getTypeFactory().constructSpecializedType(_baseType, type.getRawClass());\n                }\n            }\n            // Before assigning the deserializer, check if the type matches the expected type\n            if (_property.hasValueTypeDeserializer()) {\n                JavaType valueType = _property.getValueType();\n                if (!valueType.isTypeOrSuperType(type)) {\n                    // If not, try to find a deserializer for the actual type\n                    JsonDeserializer<?> valueDeser = ctxt.findContextualValueDeserializer(type, _property);\n                    // If found, create a delegating deserializer to handle the type mismatch\n                    deser = new DelegatingDeserializer(valueDeser, type);\n                } else {\n                    deser = ctxt.findContextualValueDeserializer(type, _property);\n                }\n            } else {\n                deser = ctxt.findContextualValueDeserializer(type, _property);\n            }\n        }\n        _deserializers.put(typeId, deser);\n    }\n    return deser;\n}\n\n// Helper class for delegating deserialization to a different type\nprivate static class DelegatingDeserializer extends JsonDeserializer<Object> {\n    private final JsonDeserializer<?> _delegate;\n    private final JavaType _actualType;\n\n    public DelegatingDeserializer(JsonDeserializer<?> delegate, JavaType actualType) {\n        _delegate = delegate;\n        _actualType = actualType;\n    }\n\n    @Override\n    public Object deserialize(JsonParser p, DeserializationContext ctxt) throws IOException {\n        return _delegate.deserialize(p, ctxt);\n    }\n\n    @Override\n    public Object deserialize(JsonParser p, DeserializationContext ctxt, Object intoValue) throws IOException {\n        return _delegate.deserialize(p, ctxt, intoValue);\n    }\n\n    @Override\n    public AccessPattern getEmptyAccessPattern() {\n        return _delegate.getEmptyAccessPattern();\n    }\n\n    @Override\n    public Object getEmptyValue(DeserializationContext ctxt) throws JsonMappingException {\n        return _delegate.getEmptyValue(ctxt);\n    }\n\n    @Override\n    public Object getNullValue(DeserializationContext ctxt) throws JsonMappingException {\n        return _delegate.getNullValue(ctxt);\n    }\n\n    @Override\n    public Object getNullAccessPattern() {\n        return _delegate.getNullAccessPattern();\n    }\n\n    @Override\n    public AccessPattern getAccessPattern() {\n        return _delegate.getAccessPattern();\n    }\n}",
    "exact_match": false,
    "ast_match": false,
    "compile": false,
    "test": false
}