{
    "generation": "private ExtractionInfo extractMultilineTextualBlock(JsDocToken token,\n                                                    WhitespaceOption option) {\n\n  if (token == JsDocToken.EOC || token == JsDocToken.EOL ||\n      token == JsDocToken.EOF) {\n    return new ExtractionInfo(\"\", token);\n  }\n\n  stream.update();\n  int startLineno = stream.getLineno();\n  int startCharno = stream.getCharno() + 1;\n\n  StringBuilder builder = new StringBuilder();\n  boolean firstLine = true;\n\n  do {\n    if (!firstLine && builder.length() > 0) {\n      builder.append('\\n');\n    }\n\n    String line = stream.getRemainingJSDocLine();\n    if (option != WhitespaceOption.PRESERVE) {\n      line = line.trim();\n    }\n    builder.append(line);\n\n    token = next();\n    firstLine = false;\n\n    if (token == JsDocToken.EOC ||\n        token == JsDocToken.EOF ||\n        (token == JsDocToken.ANNOTATION &&\n         option != WhitespaceOption.PRESERVE)) {\n      String multilineText = builder.toString();\n\n      if (option != WhitespaceOption.PRESERVE) {\n        multilineText = multilineText.trim();\n      }\n\n      int endLineno = stream.getLineno();\n      int endCharno = stream.getCharno();\n\n      if (multilineText.length() > 0) {\n        jsdocBuilder.markText(multilineText, startLineno, startCharno,\n            endLineno, endCharno);\n      }\n\n      return new ExtractionInfo(multilineText, token);\n    }\n  } while (true);\n}",
    "exact_match": false,
    "ast_match": false,
    "compile": true,
    "test": false
}