{
    "generation": "  /**\n   * Computes the subset of {@code this} and {@code that} types if inequality\n   * is observed. If a value {@code v1} of type {@code number} is not equal to a\n   * value {@code v2} of type {@code (undefined,number)}, we can infer that the\n   * type of {@code v1} is {@code number} and the type of {@code v2} is\n   * {@code number} as well.\n   *\n   * @return a pair containing the restricted type of {@code this} as the first\n   *         component and the restricted type of {@code that} as the second\n   *         element. The returned pair is never {@code null} even though its\n   *         components may be {@code null}\n   */\n  public TypePair getTypesUnderInequality(JSType that) {\n    // unions types\n    if (that instanceof UnionType || this instanceof UnionType) {\n      if (this.hasType(VOID_TYPE) || that.hasType(VOID_TYPE)) {\n        return new TypePair(this.isUnionType() ? this.restrictByNotType(VOID_TYPE) : this,\n                            that.isUnionType() ? that.restrictByNotType(VOID_TYPE) : that);\n      } else {\n        TypePair p = that.getTypesUnderInequality(this);\n        return new TypePair(p.typeB, p.typeA);\n      }\n    }\n\n    // specific types excluding void\n    if (!(this instanceof VoidType) && !(that instanceof VoidType)) {\n      switch (this.testForEquality(that)) {\n        case TRUE:\n          return new TypePair(null, null);\n\n        case FALSE:\n        case UNKNOWN:\n          return new TypePair(this, that);\n      }\n    }\n\n    // void type\n    return new TypePair(this instanceof VoidType ? NO_TYPE : this,\n                        that instanceof VoidType ? NO_TYPE : that);\n  }",
    "exact_match": false,
    "ast_match": false,
    "compile": false,
    "test": false
}