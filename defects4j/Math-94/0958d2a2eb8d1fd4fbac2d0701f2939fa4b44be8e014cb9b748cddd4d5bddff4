{
    "generation": "    /**\n     * <p>\n     * Gets the greatest common divisor of the absolute value of two numbers,\n     * using the \"binary gcd\" method which avoids division and modulo\n     * operations. See Knuth 4.5.2 algorithm B. This algorithm is due to Josef\n     * Stein (1961).\n     * </p>\n     * \n     * @param u a non-zero number\n     * @param v a non-zero number\n     * @return the greatest common divisor, never zero\n     * @since 1.1\n     */\n    public static int gcd(int u, int v) {\n        // Handle the case where one or both numbers are zero\n        if (u == 0) {\n            return Math.abs(v);\n        }\n        if (v == 0) {\n            return Math.abs(u);\n        }\n        // make u and v positive\n        u = Math.abs(u);\n        v = Math.abs(v);\n        // B1. [Find power of 2]\n        int k = 0;\n        while ((u & 1) == 0 && (v & 1) == 0 && k < 31) { // while u and v are\n                                                            // both even...\n            u >>= 1;\n            v >>= 1;\n            k++; // cast out twos.\n        }\n        if (k == 31) {\n            throw new ArithmeticException(\"overflow: gcd is 2^31\");\n        }\n        // B2. Initialize: u and v have been divided by 2^k and at least\n        // one is odd.\n        while ((u & 1) == 0) { // while u is even...\n            u >>= 1;\n        }\n        do {\n            // B3. [Make v odd] if (v is even) {\n            while ((v & 1) == 0) { // while v is even..\n                v >>= 1;\n            }\n            // B4. [Test u,v] Set t = |u \u2212 v|/2. Both u and v are odd. t is even.\n            if (u > v) {\n                u -= v; // replaced usubv\n            } else {\n                v -= u; // replaced vsubu\n            }\n            // B5. [Halve t] Set u = t.\n        } while (u != 0);\n        // B6. Shift/return. gcd is (2**k) * v.\n        return v << k;\n    }",
    "exact_match": false,
    "ast_match": false,
    "compile": true,
    "test": false
}