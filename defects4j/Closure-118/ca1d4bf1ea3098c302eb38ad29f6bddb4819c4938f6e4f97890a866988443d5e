{
    "generation": "/**\n * Processes a OBJECTLIT node.\n */\nprivate void handleObjectLit(NodeTraversal t, Node n) {\n    for (Node child = n.getFirstChild();\n         child != null;\n         child = child.getNext()) {\n        // Maybe STRING, GET, SET, GETELEM, SETELEM\n\n        String name = null;\n        Node keyNode = child.getFirstChild();\n        if (keyNode.isString()) {\n            name = keyNode.getString();\n        } else if (keyNode.isName()) {\n            name = keyNode.getString();\n        } else if (keyNode.isGetElem()) {\n            Node key = keyNode.getFirstChild();\n            if (key.isStringLit()) {\n                name = key.getString();\n            } else {\n                // Handle dynamic property names\n                continue;\n            }\n        } else {\n            // Handle other cases (e.g., computed property names)\n            continue;\n        }\n\n        T type = typeSystem.getType(getScope(), n, name);\n\n        Property prop = getProperty(name);\n        if (!prop.scheduleRenaming(child,\n                                   processProperty(t, prop, type, null))) {\n            // TODO(user): It doesn't look like the user can do much in this\n            // case right now.\n            if (propertiesToErrorFor.containsKey(name)) {\n                compiler.report(JSError.make(\n                    t.getSourceName(), child, propertiesToErrorFor.get(name),\n                    Warnings.INVALIDATION, name,\n                    (type == null ? \"null\" : type.toString()), n.toString(), \"\"));\n            }\n        }\n    }\n}",
    "exact_match": false,
    "ast_match": false,
    "compile": false,
    "test": false
}