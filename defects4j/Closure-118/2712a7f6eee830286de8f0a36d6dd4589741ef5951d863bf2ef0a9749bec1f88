{
    "generation": "/**\n * Processes a OBJECTLIT node.\n */\nprivate void handleObjectLit(NodeTraversal t, Node n) {\n  for (Node child = n.getFirstChild();\n      child!= null;\n      child = child.getNext()) {\n    // Maybe STRING, GET, SET\n\n    // Fix: Check if child is a STRING node before calling getString()\n    if (child.isString()) {\n      String name = child.getString();\n      T type = typeSystem.getType(getScope(), n, name);\n\n      Property prop = getProperty(name);\n      if (!prop.scheduleRenaming(child,\n                                 processProperty(t, prop, type, null))) {\n        // TODO(user): It doesn't look like the user can do much in this\n        // case right now.\n        if (propertiesToErrorFor.containsKey(name)) {\n          compiler.report(JSError.make(\n              t.getSourceName(), child, propertiesToErrorFor.get(name),\n              Warnings.INVALIDATION, name,\n              (type == null? \"null\" : type.toString()), n.toString(), \"\"));\n        }\n      }\n    } else if (child.isGetProp() || child.isSetProp()) {\n      // Handle GET and SET nodes separately to avoid null pointer exceptions\n      String name = child.getChildAtIndex(0).getString();\n      T type = typeSystem.getType(getScope(), n, name);\n\n      Property prop = getProperty(name);\n      if (!prop.scheduleRenaming(child,\n                                 processProperty(t, prop, type, null))) {\n        // TODO(user): It doesn't look like the user can do much in this\n        // case right now.\n        if (propertiesToErrorFor.containsKey(name)) {\n          compiler.report(JSError.make(\n              t.getSourceName(), child, propertiesToErrorFor.get(name),\n              Warnings.INVALIDATION, name,\n              (type == null? \"null\" : type.toString()), n.toString(), \"\"));\n        }\n      }\n    }\n  }\n}",
    "exact_match": false,
    "ast_match": false,
    "compile": false,
    "test": false
}