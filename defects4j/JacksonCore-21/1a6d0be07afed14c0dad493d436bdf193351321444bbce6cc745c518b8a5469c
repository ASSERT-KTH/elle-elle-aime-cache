{
    "generation": "@Override\npublic JsonToken nextToken() throws IOException\n{\n    // Perform the necessary checks...\n    if (!_allowMultipleMatches && (_currToken != null) && (_exposedContext == null)) {\n        // if not scalar...\n        if (_currToken.isStructEnd()) {\n           if (_headContext.isStartHandled()) {\n               // Return the ending structure token if we have started, then reset _currToken\n               JsonToken endToken = _currToken;\n               _currToken = null;\n               return endToken;\n           }\n        } else if (_currToken.isScalarValue()) {\n            if (!_headContext.isStartHandled() && (_itemFilter == TokenFilter.INCLUDE_ALL)) {\n                // Return the scalar value if it's included, then reset _currToken\n                JsonToken scalarToken = _currToken;\n                _currToken = null;\n                return scalarToken;\n            }\n        }\n    }\n\n    // More code...\n\n    // Scheduling the END_OBJECT and END_ARRAY tokens...\n    JsonToken t = delegate.nextToken();\n    if (t != null) {\n        switch (t.id()) {\n            case ID_END_ARRAY:\n            case ID_END_OBJECT:\n                // Return the END_OBJECT or END_ARRAY token if it's needed\n                if (_headContext.isStartHandled()) {\n                    JsonToken endToken = t;\n                    if ((f = _headContext.getFilter()) != null && f != TokenFilter.INCLUDE_ALL) {\n                        f.filterFinishArray();\n                    }\n                    _headContext = _headContext.getParent();\n                    _itemFilter = _headContext.getFilter();\n                    return (endToken = t);\n                }\n                break;\n            // More code...\n        }\n    }\n\n    // We get here if token was not yet found; offlined handling\n    return _nextToken2();\n}",
    "exact_match": false,
    "ast_match": false,
    "compile": false,
    "test": false
}