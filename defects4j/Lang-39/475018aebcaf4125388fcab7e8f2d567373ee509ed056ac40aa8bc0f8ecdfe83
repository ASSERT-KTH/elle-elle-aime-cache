{
    "generation": "/**\n * Replaces all occurrences of Strings within another String.\n * \n * @param text\n *            text to search and replace in, no-op if null\n * @param searchList\n *            the Strings to search for, no-op if null\n * @param replacementList\n *            the Strings to replace them with, no-op if null\n * @param repeat if true, then replace repeatedly \n *       until there are no more possible replacements or timeToLive < 0\n * @param timeToLive\n *            if less than 0 then there is a circular reference and endless\n *            loop\n * @return the text with any replacements processed, <code>null</code> if\n *         null String input\n * @throws IllegalArgumentException\n *             if the search is repeating and there is an endless loop due\n *             to outputs of one being inputs to another\n * @throws IndexOutOfBoundsException\n *             if the lengths of the arrays are not the same (null is ok,\n *             and/or size 0)\n * @since 2.4\n */\nprivate static String replaceEach(String text, String[] searchList, String[] replacementList, \n                                   boolean repeat, int timeToLive) \n{\n\n    //... (rest of the function remains the same until the marked section)\n\n    while (textIndex!= -1) {\n\n        for (int i = start; i < textIndex; i++) {\n            buf.append(text.charAt(i));\n        }\n        // FIX: Null safety check for replacementList[replaceIndex]\n        buf.append(replacementList[replaceIndex] == null? \"\" : replacementList[replaceIndex]);\n\n        start = textIndex + searchList[replaceIndex].length();\n\n        textIndex = -1;\n        replaceIndex = -1;\n        tempIndex = -1;\n        // find the next earliest match\n        //... (rest of the function remains the same)",
    "exact_match": false,
    "ast_match": false,
    "compile": false,
    "test": false
}