{
    "generation": "/**\n * Replaces all occurrences of Strings within another String.\n * \n * <p>\n * A <code>null</code> reference passed to this method is a no-op, or if\n * any \"search string\" or \"string to replace\" is null, that replace will be\n * ignored. \n * </p>\n * \n * <pre>\n *  StringUtils.replaceEach(null, *, *, *) = null\n *  StringUtils.replaceEach(\"\", *, *, *) = \"\"\n *  StringUtils.replaceEach(\"aba\", null, null, *) = \"aba\"\n *  StringUtils.replaceEach(\"aba\", new String[0], null, *) = \"aba\"\n *  StringUtils.replaceEach(\"aba\", null, new String[0], *) = \"aba\"\n *  StringUtils.replaceEach(\"aba\", new String[]{\"a\"}, null, *) = \"aba\"\n *  StringUtils.replaceEach(\"aba\", new String[]{\"a\"}, new String[]{\"\"}, *) = \"b\"\n *  StringUtils.replaceEach(\"aba\", new String[]{null}, new String[]{\"a\"}, *) = \"aba\"\n *  StringUtils.replaceEach(\"abcde\", new String[]{\"ab\", \"d\"}, new String[]{\"w\", \"t\"}, *) = \"wcte\"\n *  (example of how it repeats)\n *  StringUtils.replaceEach(\"abcde\", new String[]{\"ab\", \"d\"}, new String[]{\"d\", \"t\"}, false) = \"dcte\"\n *  StringUtils.replaceEach(\"abcde\", new String[]{\"ab\", \"d\"}, new String[]{\"d\", \"t\"}, true) = \"tcte\"\n *  StringUtils.replaceEach(\"abcde\", new String[]{\"ab\", \"d\"}, new String[]{\"d\", \"ab\"}, *) = IllegalArgumentException\n * </pre>\n * \n * @param text\n *            text to search and replace in, no-op if null\n * @param searchList\n *            the Strings to search for, no-op if null\n * @param replacementList\n *            the Strings to replace them with, no-op if null\n * @param repeat if true, then replace repeatedly \n *       until there are no more possible replacements or timeToLive < 0\n * @param timeToLive\n *            if less than 0 then there is a circular reference and endless\n *            loop\n * @return the text with any replacements processed, <code>null</code> if\n *         null String input\n * @throws IllegalArgumentException\n *             if the search is repeating and there is an endless loop due\n *             to outputs of one being inputs to another\n * @throws IndexOutOfBoundsException\n *             if the lengths of the arrays are not the same (null is ok,\n *             and/or size 0)\n * @since 2.4\n */\nprivate static String replaceEach(String text, String[] searchList, String[] replacementList, \n                                  boolean repeat, int timeToLive) \n{\n\n    // Fix for NullPointerException: handle null values within arrays\n    for (int i = 0; i < searchList.length; i++) {\n        if (searchList[i] == null && replacementList[i]!= null) {\n            searchList[i] = \"\"; // or some other default value\n        }\n        if (replacementList[i] == null && searchList[i]!= null) {\n            replacementList[i] = \"\"; // or some other default value\n        }\n    }\n\n    if (text == null || text.length() == 0 || searchList == null || \n        searchList.length == 0 || replacementList == null || replacementList.length == 0) \n    {\n        return text;\n    }\n\n    if (timeToLive < 0) {\n        throw new IllegalStateException(\"TimeToLive of \" + timeToLive + \" is less than 0: \" + text);\n    }\n\n    int searchLength = searchList.length;\n    int replacementLength = replacementList.length;\n\n    if (searchLength!= replacementLength) {\n        throw new IllegalArgumentException(\"Search and Replace array lengths don't match: \"\n            + searchLength\n            + \" vs \"\n            + replacementLength);\n    }\n\n    boolean[] noMoreMatchesForReplIndex = new boolean[searchLength];\n\n    int textIndex = -1;\n    int replaceIndex = -1;\n    int tempIndex = -1;\n\n    for (int i = 0; i < searchLength; i++) {\n        if (noMoreMatchesForReplIndex[i] || searchList[i].length() == 0) {\n            continue;\n        }\n        tempIndex = text.indexOf(searchList[i]);\n\n        if (tempIndex == -1) {\n            noMoreMatchesForReplIndex[i] = true;\n        } else {\n            if (textIndex == -1 || tempIndex < textIndex) {\n                textIndex = tempIndex;\n                replaceIndex = i;\n            }\n        }\n    }\n\n    if (textIndex == -1) {\n        return text;\n    }\n\n    int start = 0;\n    int increase = 0;\n\n    for (int i = 0; i < searchList.length; i++) {\n        int greater = replacementList[i].length() - searchList[i].length();\n        if (greater > 0) {\n            increase += 3 * greater; \n        }\n    }\n    increase = Math.min(increase, text.length() / 5);\n\n    StringBuilder buf = new StringBuilder(text.length() + increase);\n\n    while (textIndex!= -1) {\n\n        for (int i = start; i < textIndex; i++) {\n            buf.append(text.charAt(i));\n        }\n        buf.append(replacementList[replaceIndex]);\n\n        start = textIndex + searchList[replaceIndex].length();\n\n        textIndex = -1;\n        replaceIndex = -1;\n        tempIndex = -1;\n        \n        for (int i = 0; i < searchLength; i++) {\n            if (noMoreMatchesForReplIndex[i] || searchList[i].length() == 0) {\n                continue;\n            }\n            tempIndex = text.indexOf(searchList[i], start);\n\n            if (tempIndex == -1) {\n                noMoreMatchesForReplIndex[i] = true;\n            } else {\n                if (textIndex == -1 || tempIndex < textIndex) {\n                    textIndex = tempIndex;\n                    replaceIndex = i;\n                }\n            }\n        }\n    }\n    int textLength = text.length();\n    for (int i = start; i < textLength; i++) {\n        buf.append(text.charAt(i));\n    }\n    String result = buf.toString();\n    if (!repeat) {\n        return result;\n    }\n\n    return replaceEach(result, searchList, replacementList, repeat, timeToLive - 1);\n}",
    "exact_match": false,
    "ast_match": false,
    "compile": true,
    "test": false
}