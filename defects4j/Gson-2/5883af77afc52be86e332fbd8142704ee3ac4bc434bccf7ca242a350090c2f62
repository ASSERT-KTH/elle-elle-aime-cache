{
    "generation": "  /**\n   * Returns a factory for all subtypes of {@code typeAdapter}. We do a runtime check to confirm\n   * that the deserialized type matches the type requested.\n   */\n  public static <T1> TypeAdapterFactory newTypeHierarchyFactory(\n      final Class<T1> clazz, final TypeAdapter<T1> typeAdapter) {\n    return new TypeAdapterFactory() {\n      @SuppressWarnings(\"unchecked\")\n      public <T2> TypeAdapter<T2> create(Gson gson, TypeToken<T2> typeToken) {\n        final Class<? super T2> requestedType = typeToken.getRawType();\n        if (!clazz.isAssignableFrom(requestedType)) {\n          return null;\n        }\n        if (requestedType == JsonElement.class) {\n          return (TypeAdapter<T2>) new TypeAdapter<JsonElement>() {\n            @Override\n            public JsonElement read(JsonReader in) throws IOException {\n              JsonDeserializationContext deserializationContext = gson.newJsonDeserializationContext(gson.deserializationContext);\n              return gson.getDefaultAdapter(JsonElement.class).deserialize(in, null, deserializationContext);\n            }\n            @Override\n            public void write(JsonWriter out, JsonElement value) throws IOException {\n              gson.getDefaultAdapter(JsonElement.class).write(out, value);\n            }\n          };\n        }\n        return (TypeAdapter<T2>) typeAdapter;\n      }\n      @Override public String toString() {\n        return \"Factory[typeHierarchy=\" + clazz.getName() + \",adapter=\" + typeAdapter + \"]\";\n      }\n    };\n  }",
    "exact_match": false,
    "ast_match": false,
    "compile": false,
    "test": false
}