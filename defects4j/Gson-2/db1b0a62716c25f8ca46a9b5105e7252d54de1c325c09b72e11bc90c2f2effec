{
    "generation": "/**\n * Returns a factory for all subtypes of {@code typeAdapter}. We do a runtime check to confirm\n * that the deserialized type matches the type requested.\n */\npublic static <T1> TypeAdapterFactory newTypeHierarchyFactory(\n    final Class<T1> clazz, final TypeAdapter<T1> typeAdapter) {\n  return new TypeAdapterFactory() {\n    public <T2> TypeAdapter<T2> create(Gson gson, TypeToken<T2> typeToken) {\n      final Class<? super T2> requestedType = typeToken.getRawType();\n      if (!JsonElement.class.isAssignableFrom(requestedType) || !clazz.isAssignableFrom(requestedType)) {\n        return null;\n      }\n      // The original code attempted to cast `typeAdapter` to `TypeAdapter<T2>`, which was incorrect\n      // because the generic type of `typeAdapter` was `T1`. Instead, we create a new type adapter\n      // that uses `typeAdapter` for deserialization and `gson.getAdapter(JsonElement.class)` for\n      // serialization.\n      return new TypeAdapter<T2>() {\n        @Override\n        public void write(JsonWriter out, T2 value) throws IOException {\n          JsonElement tree = typeAdapter.toJsonTree(clazz.cast(value));\n          gson.getAdapter(JsonElement.class).write(out, tree);\n        }\n\n        @Override\n        public T2 read(JsonReader in) throws IOException {\n          JsonElement tree = gson.getAdapter(JsonElement.class).read(in);\n          return clazz.cast(typeAdapter.fromJsonTree(tree));\n        }\n      };\n    }\n    @Override public String toString() {\n      return \"Factory[typeHierarchy=\" + clazz.getName() + \",adapter=\" + typeAdapter + \"]\";\n    }\n  };\n}",
    "exact_match": false,
    "ast_match": false,
    "compile": false,
    "test": false
}