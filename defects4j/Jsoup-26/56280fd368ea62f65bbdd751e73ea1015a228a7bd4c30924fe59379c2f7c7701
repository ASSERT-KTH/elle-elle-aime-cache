{
    "generation": "/**\n * Creates a new, clean document, from the original dirty document, containing only elements allowed by the whitelist.\n * The original document is not modified. Only elements from the dirt document's <code>body</code> are used.\n * @param dirtyDocument Untrusted base document to clean.\n * @return cleaned document.\n */\npublic Document clean(Document dirtyDocument) {\n    Validate.notNull(dirtyDocument);\n\n    Document clean = Document.createShell(dirtyDocument.baseUri());\n    // Instead of directly copying, we should use the whitelist to filter allowed elements\n    Whitelist whitelist = this.whitelist; // Assuming 'whitelist' is an instance variable of the Cleaner class\n    copySafeNodes(dirtyDocument.body(), clean.body(), whitelist);\n\n    return clean;\n}\n\n/**\n * Recursively copies nodes from the source to the destination if they are allowed by the whitelist.\n * @param source Node source to copy from.\n * @param dest Node destination to copy to.\n * @param whitelist The whitelist to determine which elements and attributes are allowed.\n */\nprivate void copySafeNodes(Node source, Node dest, Whitelist whitelist) {\n    for (Node srcChild : source.childNodes()) {\n        if (srcChild instanceof Element) {\n            Element srcElement = (Element) srcChild;\n            if (whitelist.isSafeTag(srcElement.tagName())) {\n                Element destChild = dest.appendChild(new Element(Tag.valueOf(srcElement.tagName()), srcElement.baseUri()));\n                destChild.attributes().addAll(whitelist.getAttributes(srcElement.tagName()).filter(srcElement.attributes()));\n                copySafeNodes(srcElement, destChild, whitelist);\n            }\n        } else {\n            dest.appendChild(srcChild.clone());\n        }\n    }\n}",
    "exact_match": false,
    "ast_match": false,
    "compile": false,
    "test": false
}