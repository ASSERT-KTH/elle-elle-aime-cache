{
    "generation": "  @Override\n  public void visit(NodeTraversal t, Node n, Node parent) {\n    // Skipping prior code that doesn't need changes for this fix\n\n    // Fixed section for COMMA and EXPR_RESULT cases\n    if (parent.getType() == Token.COMMA) {\n      Node gramps = parent.getParent();\n      if (gramps.isCall() && parent == gramps.getFirstChild()) {\n        if (n == parent.getFirstChild() && parent.getChildCount() == 2 && n.getNext().isName() && \"eval\".equals(n.getNext().getString())) {\n          return;\n        }\n        if (!NodeUtil.isExpressionResultUsed(n)) {\n          String msg = \"The result of a function call has no side-effects and is not being used.\";\n          t.getCompiler().report(t.makeError(n, level, USELESS_CODE_ERROR, msg));\n          problemNodes.add(n);\n        }\n      }\n    } else if (parent.getType() != Token.EXPR_RESULT && parent.getType() != Token.BLOCK) {\n      if (parent.getType() == Token.FOR && parent.getChildCount() >= 3 &&\n          n.closesScope(parent.getScope())) {\n        Node forInitializer = parent.getFirstChild().getNext();\n        if (n == forInitializer && forInitializer.isComma()) {\n          for (Node c = forInitializer.getFirstChild(); c != null; c = c.getNext()) {\n            if (!NodeUtil.isExpressionResultUsed(c) && !NodeUtil.mayHaveSideEffects(c, t.getCompiler())) {\n              t.getCompiler().report(t.makeError(c, level, USELESS_CODE_ERROR, \"This code lacks side-effects. Is there a bug?\"));\n              problemNodes.add(c);\n            }\n          }\n        }\n      } else if (!NodeUtil.isExpressionResultUsed(n) && !NodeUtil.mayHaveSideEffects(n, t.getCompiler())) {\n        t.getCompiler().report(t.makeError(n, level, USELESS_CODE_ERROR, \"This code lacks side-effects. Is there a bug?\"));\n        problemNodes.add(n);\n      }\n    }\n\n    // Skipping remaining code that doesn't need changes for this fix\n  }",
    "exact_match": false,
    "ast_match": false,
    "compile": false,
    "test": false
}