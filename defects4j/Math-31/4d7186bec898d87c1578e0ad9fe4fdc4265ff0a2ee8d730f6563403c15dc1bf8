{
    "generation": "public double evaluate(double x, double epsilon, int maxIterations) {\n    final double small = 1e-50;\n    double hPrev = getA(0, x);\n\n    // use the value of small as epsilon criteria for zero checks\n    if (Precision.equals(hPrev, 0.0, small)) {\n        hPrev = small;\n    }\n\n    int n = 1;\n    double cPrev = hPrev;\n\n    // initialize the values for the previous row\n    double p0 = 1.0 / hPrev;\n    double p1 = 1;\n\n    while (n <= maxIterations) {\n        final double a = getA(n, x);\n        final double b = getB(n, x);\n\n        // compute A_n\n        double alphaN = a * cPrev;\n        double an = alphaN + 1 / p1;\n        double bn = -alphaN * an;\n        double cn = hPrev * an;\n\n        // check for convergence. The recurrence relation can explode if the\n        // initial values are too off.\n        if (isConverged(cn, hPrev, epsilon)) {\n            return cn;\n        } else {\n            // do the recurrence relation for bn and cn\n            cn = cn / bn * an;\n            p0 = p1;\n            // check for overflow in cases where the recurrence relation results\n            // in ever growing values.\n            p1 = isOverflow(b / cn)? cn = small : b / cn;\n            hPrev = cn;\n            cPrev = an;\n            n = n + 1;\n        }\n    }\n\n    throw new MaxCountExceededException(LocalizedFormats.NON_CONVERGENT_CONTINUED_FRACTION,\n                                        maxIterations, x);\n}",
    "exact_match": false,
    "ast_match": false,
    "compile": false,
    "test": false
}