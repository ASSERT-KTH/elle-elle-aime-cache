{
    "generation": "/**\n * Multiply two values throwing an exception if overflow occurs.\n * \n * @param val1  the first value\n * @param val2  the second value\n * @return the new total\n * @throws ArithmeticException if the value is too big or too small\n * @since 1.2\n */\npublic static long safeMultiply(long val1, int val2) {\n    if (val2 == 0) {\n        return 0L;\n    }\n    \n    long val2Long = (long) val2;\n    if (val2Long == val2) {\n        long total = val1 * val2Long;\n        if (total / val2Long!= val1) {\n          throw new ArithmeticException(\"Multiplication overflows a long: \" + val1 + \" * \" + val2);\n        }\n        return total;\n    }\n    // Special case when Integer.MIN_VALUE is passed (since its absolute value can't be represented in an int)\n    else if (val2 == Integer.MIN_VALUE) {\n        // Since we only care about the case of Long.MIN_VALUE here (if val1 is Long.MAX_VALUE the multiplication can still be done)\n        // We use a single explicit check to cover that value.\n        if (val1 == Long.MIN_VALUE) {\n            throw new ArithmeticException(\"Multiplication overflows a long: \" + val1 + \" * \" + val2);\n        }\n        long absTotal = val1 * -((long) Integer.MIN_VALUE);\n        // Here the only problematic input value was Long.MAX_VALUE but it will cause a negation so the condition isn't violated\n        // Therefore it is possible for val1 to be between -Long.MAX_VALUE & Long.MAX_VALUE for (Long.MIN_VALUE > the actual limit of safe_negation).\n        // We therefore take a chance here. Either way val1 < Integer.MAX_VALUE (i. e., Long.MAX_VALUE is valid) as there isn't an actual larger positive input\n        long result = -absTotal;\n        return result;\n    }\n    // A final possibility for this could occur for inputs which multiply to give 2 times negative the upper bound. They're always overflow so one may do an overflow validation on negating inputs, also we should validate\n    // input in advance but for val1 the number was either Integer.MAX_VALUE (Long.MIN_VALUE > input can never actually reach an exact Long.MIN_VALUE to provide for negation and remain a negative).\n    throw new ArithmeticException(\"Unknown internal case: should probably have reached one of your conditions in order to end up with valid state given this implementation. See relevant comments on implementation specifics; in safeMultiply. Sorry\");\n}",
    "exact_match": false,
    "ast_match": false,
    "compile": true,
    "test": false
}