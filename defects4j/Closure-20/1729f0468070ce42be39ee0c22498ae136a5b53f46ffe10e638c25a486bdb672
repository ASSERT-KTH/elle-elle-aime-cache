{
    "generation": "/**\n * Attempts to fold a simple `String(a)` function call into `''.concat(a)`.\n * This optimization is only valid for immutable literals.\n * \n * @param n the node to attempt folding on\n * @return the folded node, or the original node if folding was not possible\n */\nprivate Node tryFoldSimpleFunctionCall(Node n) {\n    Preconditions.checkState(n.isCall());\n    Node callTarget = n.getFirstChild();\n    if (callTarget!= null && callTarget.isName() &&\n          callTarget.getString().equals(\"String\")) {\n      Node value = callTarget.getNext();\n      if (value!= null && value.isImmutableLiteral()) {\n        // Use concat to preserve semantics for nullable/undefined values\n        Node emptyString = IR.string(\"\").srcref(callTarget);\n        Node concatMethod = IR.getProp(emptyString, \"concat\").srcref(callTarget);\n        Node callConcat = IR.call(concatMethod, value.detachFromParent()).srcref(n);\n        n.getParent().replaceChild(n, callConcat);\n        reportCodeChange();\n        return callConcat;\n      }\n    }\n    return n;\n}\n\n/**\n * Helper method to determine if a node is an immutable literal.\n * \n * @param node the node to check\n * @return true if the node is an immutable literal, false otherwise\n */\nprivate boolean isImmutableLiteral(Node node) {\n    // Immutable literals: null, undefined, numbers, booleans, and string literals\n    return node.isNullLiteral() || node.isUndefined() ||\n           node.isNumber() || node.isBoolean() || node.isString();\n}",
    "exact_match": false,
    "ast_match": false,
    "compile": false,
    "test": false
}