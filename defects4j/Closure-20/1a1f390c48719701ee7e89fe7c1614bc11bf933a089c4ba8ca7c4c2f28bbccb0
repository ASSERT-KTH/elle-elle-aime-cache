{
    "generation": "private Node tryFoldSimpleFunctionCall(Node n) {\n    Preconditions.checkState(n.isCall());\n    Node callTarget = n.getFirstChild();\n    if (callTarget != null && callTarget.isName() &&\n            callTarget.getString().equals(\"String\")) {\n        // Fold String(a) to '' + (a) on immutable literals,\n        // which allows further optimizations\n        //\n        // We can't do this in the general case, because String(a) has\n        // slightly different semantics than '' + (a). See\n        // http://code.google.com/p/closure-compiler/issues/detail?id=759\n        Node value = callTarget.getNext();\n        if (value != null && value.getNext() == null) { // Check for exactly one argument\n            // Check if the argument is not an object with a valueOf method\n            if (!value.isObjectLit() && !mayHaveValueOfMethod(value)) {\n                Node addition = IR.add(\n                    IR.string(\"\").srcref(callTarget),\n                    value.detachFromParent());\n                n.getParent().replaceChild(n, addition);\n                reportCodeChange();\n                return addition;\n            }\n        }\n    }\n    return n;\n}\n\n// Helper method to check if a node may have a valueOf method\nprivate boolean mayHaveValueOfMethod(Node node) {\n    if (node.isObjectLit()) {\n        for (Node key = node.getFirstChild(); key != null; key = key.getNext()) {\n            if (key.isStringKey() && key.getString().equals(\"valueOf\")) {\n                return true;\n            }\n        }\n    }\n    return false;\n}",
    "exact_match": false,
    "ast_match": false,
    "compile": true,
    "test": true
}