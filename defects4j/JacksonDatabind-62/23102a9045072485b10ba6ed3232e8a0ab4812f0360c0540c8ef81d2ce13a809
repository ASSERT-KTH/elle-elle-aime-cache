{
    "generation": "    /**\n     * Method called to finalize setup of this deserializer,\n     * when it is known for which property deserializer is needed\n     * for.\n     */\n    @Override\n    public CollectionDeserializer createContextual(DeserializationContext ctxt,\n            BeanProperty property) throws JsonMappingException\n    {\n        // May need to resolve types for delegate-based creators:\n        JsonDeserializer<Object> delegateDeser = null;\n        if (_valueInstantiator != null && _valueInstantiator.canCreateUsingDelegate()) {\n            JavaType delegateType = _valueInstantiator.getDelegateType(ctxt.getConfig());\n            if (delegateType == null) {\n                throw new IllegalArgumentException(\"Invalid delegate-creator definition for \"+_collectionType\n                        +\": value instantiator (\"+_valueInstantiator.getClass().getName()\n                        +\") returned true for 'canCreateUsingDelegate()', but null for 'getDelegateType()'\");\n            }\n            delegateDeser = findDeserializer(ctxt, delegateType, property);\n        } else if (_valueInstantiator == null && !_collectionType.isJavaLangObject()) {\n            // If there's no custom valueInstantiator and the collection type is not Object,\n            // try to find a default constructor.\n            // This is to handle cases like unmodifiable collections that don't have a no-args constructor.\n            try {\n                _valueInstantiator = ctxt.getConfig().getClassInstantiator().createValueInstantiator(_collectionType);\n            } catch (JsonMappingException e) {\n                // Ignore the exception and leave _valueInstantiator as null.\n                // The error will be handled later when we try to create an instance of the collection.\n            }\n        }\n\n        // ... rest of the function ...\n    }",
    "exact_match": false,
    "ast_match": false,
    "compile": false,
    "test": false
}