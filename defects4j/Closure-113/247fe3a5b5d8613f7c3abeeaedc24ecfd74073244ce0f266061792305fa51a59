{
    "generation": "/**\n * Handles a goog.require call.\n */\nprivate void processRequireCall(NodeTraversal t, Node n, Node parent) {\n  Node left = n.getFirstChild();\n  Node arg = left.getNext();\n  if (verifyLastArgumentIsString(t, left, arg)) {\n    String ns = arg.getString();\n    ProvidedName provided = providedNames.get(ns);\n    if (provided == null) {\n      // If the provided name is not found, add it to unrecognizedRequires\n      unrecognizedRequires.add(new UnrecognizedRequire(n, ns, t.getSourceName()));\n    } else {\n      if (!provided.isExplicitlyProvided()) {\n        // If the provided name exists but is not explicitly provided, still consider it unrecognized\n        unrecognizedRequires.add(new UnrecognizedRequire(n, ns, t.getSourceName()));\n      } else {\n        JSModule providedModule = provided.explicitModule;\n        // This must be non-null, because there was an explicit provide.\n        Preconditions.checkNotNull(providedModule);\n\n        JSModule module = t.getModule();\n        if (moduleGraph != null && module != providedModule && !moduleGraph.dependsOn(module, providedModule)) {\n          compiler.report(t.makeError(n, XMODULE_REQUIRE_ERROR, ns, providedModule.getName(), module.getName()));\n        }\n      }\n\n      // Always attempt to add to symbol table, regardless of provided status\n      maybeAddToSymbolTable(left);\n      maybeAddStringNodeToSymbolTable(arg);\n    }\n\n    // Remove the require node only if it's recognized (i.e., provided != null and explicitly provided)\n    if (provided != null && provided.isExplicitlyProvided()) {\n      parent.detachFromParent();\n      compiler.reportCodeChange();\n    }\n  }\n}",
    "exact_match": false,
    "ast_match": false,
    "compile": true,
    "test": false
}