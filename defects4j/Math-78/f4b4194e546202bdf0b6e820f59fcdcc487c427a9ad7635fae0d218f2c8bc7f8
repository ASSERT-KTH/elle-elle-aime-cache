{
    "generation": "public boolean evaluateStep(final StepInterpolator interpolator)\n    throws DerivativeException, EventException, ConvergenceException {\n\n    try {\n        forward = interpolator.isForward();\n        final double t1 = interpolator.getCurrentTime();\n        final int n = Math.max(1, (int) Math.ceil(Math.abs(t1 - t0) / maxCheckInterval));\n        final double h = (t1 - t0) / n;\n\n        double ta = t0;\n        double ga = g0;\n        interpolator.setInterpolatedTime(ta);\n        for (int i = 0; i < n; ++i) {\n            double tb = ta + h;\n            if (tb > t1) {\n                tb = t1;\n            }\n            interpolator.setInterpolatedTime(tb);\n            double gb = handler.g(tb, interpolator.getInterpolatedState());\n\n            // Check for sign change within the substep\n            if (ga * gb <= 0) {\n                // Sign change detected; attempt to find the root\n                findAndHandleEvent(ta, tb, ga, gb, interpolator);\n            }\n\n            ta = tb;\n            ga = gb;\n        }\n\n        // No event detected in the entire step\n        pendingEvent = false;\n        pendingEventTime = Double.NaN;\n        return false;\n\n    } catch (FunctionEvaluationException e) {\n        final Throwable cause = e.getCause();\n        if ((cause != null) && (cause instanceof DerivativeException)) {\n            throw (DerivativeException) cause;\n        } else if ((cause != null) && (cause instanceof EventException)) {\n            throw (EventException) cause;\n        }\n        throw new EventException(e);\n    }\n}\n\nprivate void findAndHandleEvent(double ta, double tb, double ga, double gb,\n                                StepInterpolator interpolator)\n    throws DerivativeException, EventException, ConvergenceException {\n\n    UnivariateRealFunction f = new UnivariateRealFunction() {\n        public double value(double t) throws FunctionEvaluationException {\n            try {\n                interpolator.setInterpolatedTime(t);\n                return handler.g(t, interpolator.getInterpolatedState());\n            } catch (DerivativeException e) {\n                throw new FunctionEvaluationException(e, t);\n            } catch (EventException e) {\n                throw new FunctionEvaluationException(e, t);\n            }\n        }\n    };\n\n    // Ensure that the function values at ta and tb have opposite signs\n    if (ga * gb > 0) {\n        // If not, try to adjust tb to find a point with opposite sign\n        double tmid = (ta + tb) / 2;\n        interpolator.setInterpolatedTime(tmid);\n        double gmid = handler.g(tmid, interpolator.getInterpolatedState());\n        if (ga * gmid < 0) {\n            tb = tmid;\n            gb = gmid;\n        } else if (gmid * gb < 0) {\n            ta = tmid;\n            ga = gmid;\n        } else {\n            // No sign change found; skip this substep\n            return;\n        }\n    }\n\n    BrentSolver solver = new BrentSolver();\n    solver.setAbsoluteAccuracy(convergence);\n    solver.setMaximalIterationCount(maxIterationCount);\n    double root = (ta <= tb) ? solver.solve(f, ta, tb) : solver.solve(f, tb, ta);\n\n    if (Math.abs(root - ta) <= convergence && Math.abs(root - previousEventTime) <= convergence) {\n        // Event is too close to the previous one; ignore it\n        return;\n    }\n\n    if (Double.isNaN(previousEventTime) || Math.abs(previousEventTime - root) > convergence) {\n        pendingEventTime = root;\n        if (pendingEvent && Math.abs(t1 - pendingEventTime) <= convergence) {\n            // Step ends exactly at the event time; accept the step\n            pendingEvent = false;\n            pendingEventTime = Double.NaN;\n            return;\n        }\n        // Set pending event\n        pendingEvent = true;\n    }\n}",
    "exact_match": false,
    "ast_match": false,
    "compile": false,
    "test": false
}