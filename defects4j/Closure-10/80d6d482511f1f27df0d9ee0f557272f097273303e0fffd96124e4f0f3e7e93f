{
    "generation": "static boolean mayBeString(Node n, boolean recurse) {\n    if (recurse) {\n        return allResultsMatch(n, MAY_BE_STRING_PREDICATE);\n    } else {\n        switch (n.getToken()) {\n            case NAME:\n            case GETPROP:\n            case GETELEM:\n            case CALL:\n            case NEW:\n            case ARRAYLIT:\n            case OBJECTLIT:\n            case REGEXP:\n            case TRUE:\n            case FALSE:\n            case NULL:\n            case THIS:\n            case VOID:\n                return false;\n            case STRING:\n                return true;\n            case NUMBER:\n            case BIGINT:\n                return false;\n            case BANG:\n            case NOT:\n            case BITNOT:\n                return false;\n            case POS:\n            case NEG:\n                return false;\n            case ADD:\n                // If any operand is a string, the result is a string.\n                return NodeUtil.mayBeString(n.getFirstChild(), true) || NodeUtil.mayBeString(n.getLastChild(), true);\n            case COMMA:\n                // The result is the type of the last expression.\n                return NodeUtil.mayBeString(n.getLastChild(), true);\n            case OR:\n            case AND:\n                // If either operand is a string, the result could be a string.\n                return NodeUtil.mayBeString(n.getFirstChild(), true) || NodeUtil.mayBeString(n.getLastChild(), true);\n            case HOOK:\n                // The result is a string if either the true or false branch is a string.\n                return NodeUtil.mayBeString(n.getSecondChild(), true) || NodeUtil.mayBeString(n.getLastChild(), true);\n            default:\n                return mayBeStringHelper(n);\n        }\n    }\n}",
    "exact_match": false,
    "ast_match": false,
    "compile": false,
    "test": false
}