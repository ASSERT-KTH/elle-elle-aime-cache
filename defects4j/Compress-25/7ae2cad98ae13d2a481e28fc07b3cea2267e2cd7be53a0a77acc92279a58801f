{
    "generation": "/**\n * @param encoding the encoding to use for file names, use null\n * for the platform's default encoding\n * @param useUnicodeExtraFields whether to use InfoZIP Unicode\n * Extra Fields (if present) to set the file names.\n * @param allowStoredEntriesWithDataDescriptor whether the stream\n * will try to read STORED entries that use a data descriptor\n * @since 1.1\n */\npublic ZipArchiveInputStream(InputStream inputStream,\n                             String encoding,\n                             boolean useUnicodeExtraFields,\n                             boolean allowStoredEntriesWithDataDescriptor) {\n    zipEncoding = ZipEncodingHelper.getZipEncoding(encoding);\n    this.useUnicodeExtraFields = useUnicodeExtraFields;\n    in = new PushbackInputStream(inputStream, buf.capacity());\n    this.allowStoredEntriesWithDataDescriptor =\n        allowStoredEntriesWithDataDescriptor;\n\n    // Try to determine entry size at the creation of ZipArchiveInputStream\n    try {\n        // Read the local file header\n        byte[] header = new byte[30];\n        int bytesRead = in.read(header);\n        if (bytesRead != 30) {\n            throw new IOException(\"Failed to read the local file header.\");\n        }\n\n        // Determine entry size from the header\n        ByteBuffer buffer = ByteBuffer.wrap(header, 26, 4); // Size field is at offset 26\n        entrySize = buffer.getInt();\n    } catch (IOException e) {\n        // Handle exception appropriately\n        e.printStackTrace();\n        entrySize = -1; // Or set it to a default/error value\n    }\n}",
    "exact_match": false,
    "ast_match": false,
    "compile": false,
    "test": false
}