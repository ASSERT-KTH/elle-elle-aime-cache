{
    "generation": "/**\n * <p>This flatten method does so using the following rules:\n * <ol>\n *  <li>If an {@link Option} exists for the first character of\n *  the <code>arguments</code> entry <b>AND</b> an {@link Option}\n *  does not exist for the whole <code>argument</code>, then always add the first character as an option\n *  to the processed tokens list and add the rest of the entry to the list. e.g. \"-Dproperty=value\".</li>\n *  <li>If an {@link Option} exists for the whole <code>argument</code>, then just add the whole argument to the\n *  processed tokens list. e.g. \"--foo=bar\".</li>\n *  <li>If an {@link Option} does not exist for both the first character and the whole <code>argument</code>, then\n *  keep processing arguments further, unless stop processing is enabled by a \"--\" or non-option argument.</li>\n * </ol>\n * </p>\n *\n * @param options The Options to parse the arguments by.\n * @param arguments The arguments that have to be flattened.\n * @param stopAtNonOption specifies whether to stop flattening when a non option has been encountered\n * @return a String array of the flattened arguments\n */\nprotected String[] flatten(Options options, String[] arguments, boolean stopAtNonOption)\n{\n    List<String> tokens = new ArrayList<>();\n\n    boolean eatTheRest = false;\n\n    for (int i = 0; i < arguments.length; i++)\n    {\n        String arg = arguments[i];\n\n        if (\"--\".equals(arg))\n        {\n            eatTheRest = true;\n            tokens.add(\"--\");\n        }\n        else if (\"-\".equals(arg))\n        {\n            tokens.add(\"-\");\n        }\n        else if (arg.startsWith(\"--=\"))\n        {\n            // special case where a single dash follows - with no option name\n            tokens.add(arg.substring(0, 2));\n            tokens.add(arg.substring(2));\n        }\n        else if (arg.startsWith(\"--\"))\n        {\n            int sepIndex = arg.indexOf('=');\n\n            if(sepIndex != -1) // --foo=bar\n            {\n                if(options.hasLongOption(arg.substring(2, sepIndex)))\n                {\n                    tokens.add(arg);\n                }\n                else\n                {\n                    eatTheRest = stopAtNonOption;\n                    tokens.add(arg);\n                }\n            }\n            else // --foo\n            {\n                if(options.hasLongOption(arg.substring(2)))\n                {\n                    tokens.add(arg);\n                }\n                else\n                {\n                    eatTheRest = stopAtNonOption;\n                    tokens.add(arg);\n                }\n            }\n        }\n        else if (arg.startsWith(\"-\"))\n        {\n            String opt = Util.stripLeadingHyphens(arg);\n            int sepIndex = opt.indexOf('=');\n\n            if(sepIndex != -1) // -Dproperty=value\n            {\n                if(!options.hasOption(opt.substring(0, sepIndex)))\n                {\n                    tokens.add(arg.substring(0, sepIndex+1));\n                    tokens.add(arg.substring(sepIndex+1));\n                }\n                else\n                {\n                    tokens.add(arg);\n                }\n            }\n            else\n            {\n                if(options.hasOption(arg.substring(0, 2)))\n                {\n                    tokens.add(arg);\n                }\n                else\n                {\n                    eatTheRest = stopAtNonOption;\n                    tokens.add(arg);\n                }\n            }\n        }\n        else\n        {\n            tokens.add(arg);\n        }\n\n        if (eatTheRest)\n        {\n            for (i++; i < arguments.length; i++)\n            {\n                tokens.add(arguments[i]);\n            }\n            break;\n        }\n    }\n\n    return tokens.toArray(new String[0]);\n}",
    "exact_match": false,
    "ast_match": false,
    "compile": false,
    "test": false
}