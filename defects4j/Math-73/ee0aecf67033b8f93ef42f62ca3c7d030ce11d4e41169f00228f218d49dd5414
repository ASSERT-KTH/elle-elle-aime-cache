{
    "generation": "    public double solve(final UnivariateRealFunction f,\n                        final double min, final double max, final double initial)\n        throws MaxIterationsExceededException, FunctionEvaluationException {\n\n        clearResult();\n        if (initial < min || initial > max) {\n            throw new IllegalArgumentException(\"Initial value is not between min and max\");\n        }\n        verifySequence(min, max);\n\n        // return the initial guess if it is good enough\n        double yInitial = f.value(initial);\n        if (Math.abs(yInitial) <= functionValueAccuracy) {\n            setResult(initial, 0);\n            return result;\n        }\n\n        // return the first endpoint if it is good enough\n        double yMin = f.value(min);\n        if (Math.abs(yMin) <= functionValueAccuracy) {\n            setResult(min, 0);\n            return result;\n        }\n\n        // return the second endpoint if it is good enough\n        double yMax = f.value(max);\n        if (Math.abs(yMax) <= functionValueAccuracy) {\n            setResult(max, 0);\n            return result;\n        }\n\n        // check if the initial guess brackets the root with either endpoint\n        if (yInitial * yMin < 0) {\n            return solve(f, min, initial, yMin, yInitial);\n        } else if (yInitial * yMax < 0) {\n            return solve(f, initial, max, yInitial, yMax);\n        }\n\n        // if no bracketing is found, throw an IllegalArgumentException\n        throw new IllegalArgumentException(\"Function values at endpoints do not bracket the root\");\n\n    }\n\n    // Helper method to perform the Brent algorithm\n    private double solve(final UnivariateRealFunction f, final double lo, final double hi, final double yLo, final double yHi)\n        throws MaxIterationsExceededException, FunctionEvaluationException {\n\n        double a = lo;\n        double fa = yLo;\n        double b = hi;\n        double fb = yHi;\n        double c = a;\n        double fc = fa;\n        boolean mflag = true;\n        double s = 0;\n        double fs = 0;\n        double d = 0;\n\n        for (int i = 0; i < maximalIterationCount; i++) {\n            if (Math.abs(fb) < Math.abs(fc)) {\n                a = b;\n                b = c;\n                c = a;\n                fa = fb;\n                fb = fc;\n                fc = fa;\n            }\n\n            double tol = relativeAccuracy * Math.abs(b) + absoluteAccuracy;\n            double m = 0.5 * (c - b);\n\n            if (Math.abs(m) <= tol || fb == 0) {\n                setResult(b, i);\n                return result;\n            }\n\n            if (Math.abs(e) > tol && Math.abs(fa) != Math.abs(fb)) {\n                s = fb / fa;\n                double p, q;\n                if (a == c) {\n                    p = 2 * m * s;\n                    q = 1 - s;\n                } else {\n                    q = fa / fc;\n                    double r = fb / fc;\n                    p = s * (2 * m * q * (q - r) - (b - a) * (r - 1));\n                    q = (q - 1) * (r - 1) * (s - 1);\n                }\n                if (p > 0) {\n                    q = -q;\n                }\n                p = Math.abs(p);\n                double min1 = 3 * m * q - Math.abs(tol * q);\n                double min2 = Math.abs(e * q);\n                if (2 * p < Math.min(min1, min2)) {\n                    e = d;\n                    d = p / q;\n                } else {\n                    e = m;\n                    d = m;\n                }\n            } else {\n                e = m;\n                d = m;\n            }\n\n            if (Math.abs(d) > tol) {\n                s = d;\n            } else {\n                s = Math.copySign(tol, m);\n            }\n\n            a = b;\n            fa = fb;\n\n            if (Math.abs(s) > tol) {\n                b = b + s;\n            } else {\n                b = b + Math.copySign(tol, c - b);\n            }\n\n            fb = f.value(b);\n            if ((fb > 0 && fc > 0) || (fb < 0 && fc < 0)) {\n                c = a;\n                fc = fa;\n                d = b - a;\n                e = d;\n            }\n\n            mflag = (Math.abs(fb) < Math.abs(fc));\n        }\n\n        throw new MaxIterationsExceededException(maximalIterationCount);\n    }",
    "exact_match": false,
    "ast_match": false,
    "compile": false,
    "test": false
}