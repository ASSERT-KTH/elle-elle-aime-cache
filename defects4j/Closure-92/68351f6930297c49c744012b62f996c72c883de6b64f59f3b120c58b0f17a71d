{
    "generation": "void replace() {\n  if (firstNode == null) {\n    // Don't touch the base case ('goog').\n    replacementNode = candidateDefinition;\n    return;\n  }\n\n  // Handle the case where there is a duplicate definition for an explicitly\n  // provided symbol or there is no definition at all.\n  if ((candidateDefinition != null && explicitNode != null) || candidateDefinition == null) {\n    if (explicitNode != null) {\n      explicitNode.detachFromParent();\n    }\n    compiler.reportCodeChange();\n\n    replacementNode = candidateDefinition;\n  } else {\n    // Handle the case where there's not a duplicate definition.\n    replacementNode = createDeclarationNode();\n    if (firstModule == minimumModule) {\n      firstNode.getParent().addChildBefore(replacementNode, firstNode);\n    } else {\n      // In this case, the name was implicitly provided by two independent\n      // modules. We need to move this code up to a common module.\n      int indexOfDot = namespace.indexOf('.');\n      Node insertionPoint = null;\n      if (indexOfDot == -1) {\n        // Any old place is fine.\n        insertionPoint = compiler.getNodeForCodeInsertion(minimumModule);\n      } else {\n        // Add it after the parent namespace.\n        ProvidedName parentName = providedNames.get(namespace.substring(0, indexOfDot));\n        Preconditions.checkNotNull(parentName);\n        Preconditions.checkNotNull(parentName.replacementNode);\n        insertionPoint = parentName.replacementNode.getParent();\n      }\n      insertionPoint.addChildAfter(replacementNode, insertionPoint.getLastChild());\n    }\n    if (explicitNode != null) {\n      explicitNode.detachFromParent();\n    }\n    compiler.reportCodeChange();\n  }\n}",
    "exact_match": false,
    "ast_match": false,
    "compile": true,
    "test": false
}