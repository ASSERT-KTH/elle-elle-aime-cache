{
    "generation": "void replace() {\n  if (firstNode == null) {\n    // Don't touch the base case ('goog').\n    replacementNode = candidateDefinition;\n    return;\n  }\n\n  // Handle the case where there is a duplicate definition for an explicitly\n  // provided symbol.\n  if (candidateDefinition != null && explicitNode != null) {\n    explicitNode.detachFromParent();\n    compiler.reportCodeChange();\n\n    // Does this need a VAR keyword?\n    replacementNode = candidateDefinition;\n    if (NodeUtil.isExpressionNode(candidateDefinition)) {\n      candidateDefinition.putBooleanProp(Node.IS_NAMESPACE, true);\n      Node assignNode = candidateDefinition.getFirstChild();\n      Node nameNode = assignNode.getFirstChild();\n      if (nameNode.getType() == Token.NAME) {\n        // Need to convert this assign to a var declaration.\n        Node valueNode = nameNode.getNext();\n        assignNode.removeChild(nameNode);\n        assignNode.removeChild(valueNode);\n        nameNode.addChildToFront(valueNode);\n        Node varNode = new Node(Token.VAR, nameNode);\n        varNode.copyInformationFrom(candidateDefinition);\n        candidateDefinition.getParent().replaceChild(\n            candidateDefinition, varNode);\n        nameNode.setJSDocInfo(assignNode.getJSDocInfo());\n        compiler.reportCodeChange();\n        replacementNode = varNode;\n      }\n    }\n  } else {\n    // Handle the case where there's not a duplicate definition.\n    // Ensure that parent namespaces are created if necessary.\n    String[] parts = namespace.split(\"\\\\.\");\n    StringBuilder parentNamespace = new StringBuilder();\n    for (int i = 0; i < parts.length - 1; i++) {\n      if (i > 0) {\n        parentNamespace.append(\".\");\n      }\n      parentNamespace.append(parts[i]);\n      ProvidedName parentName = providedNames.get(parentNamespace.toString());\n      if (parentName == null || parentName.replacementNode == null) {\n        // Need to create the parent namespace.\n        ProvidedName newParent = new ProvidedName();\n        newParent.namespace = parentNamespace.toString();\n        // Assuming minimumModule is the appropriate module for this parent.\n        newParent.minimumModule = minimumModule;\n        // Create a declaration node for the parent namespace.\n        newParent.replacementNode = createNamespaceDeclarationNode(newParent.namespace);\n        // Add it to the providedNames map.\n        providedNames.put(newParent.namespace, newParent);\n        // Insert the new declaration node into the appropriate place.\n        if (firstModule == minimumModule) {\n          firstNode.getParent().addChildBefore(newParent.replacementNode, firstNode);\n        } else {\n          // Add it to a common module.\n          int indexOfDot = parentNamespace.indexOf(\".\");\n          if (indexOfDot != -1) {\n            ProvidedName grandParentName = providedNames.get(parentNamespace.substring(0, indexOfDot));\n            Preconditions.checkNotNull(grandParentName);\n            Preconditions.checkNotNull(grandParentName.replacementNode);\n            grandParentName.replacementNode.getParent().addChildAfter(\n                newParent.replacementNode, grandParentName.replacementNode);\n          } else {\n            compiler.getNodeForCodeInsertion(minimumModule)\n                .addChildToBack(newParent.replacementNode);\n          }\n        }\n        compiler.reportCodeChange();\n      }\n    }\n\n    replacementNode = createDeclarationNode();\n    if (firstModule == minimumModule) {\n      firstNode.getParent().addChildBefore(replacementNode, firstNode);\n    } else {\n      // In this case, the name was implicitly provided by two independent\n      // modules. We need to move this code up to a common module.\n      int indexOfDot = namespace.indexOf('.');\n      if (indexOfDot == -1) {\n        // Any old place is fine.\n        compiler.getNodeForCodeInsertion(minimumModule)\n            .addChildToBack(replacementNode);\n      } else {\n        // Add it after the parent namespace.\n        ProvidedName parentName =\n            providedNames.get(namespace.substring(0, indexOfDot));\n        Preconditions.checkNotNull(parentName);\n        Preconditions.checkNotNull(parentName.replacementNode);\n        parentName.replacementNode.getParent().addChildAfter(\n            replacementNode, parentName.replacementNode);\n      }\n    }\n    if (explicitNode != null) {\n      explicitNode.detachFromParent();\n    }\n    compiler.reportCodeChange();\n  }\n}\n\nprivate Node createNamespaceDeclarationNode(String namespace) {\n  String[] parts = namespace.split(\"\\\\.\");\n  Node currentNode = new Node(Token.VAR);\n  Node previousNode = null;\n  for (String part : parts) {\n    Node objectLit = new Node(Token.OBJECTLIT);\n    Node nameNode = new Node(Token.NAME, part);\n    if (previousNode != null) {\n      previousNode.addChildToBack(objectLit);\n    } else {\n      currentNode.addChildToBack(nameNode);\n      currentNode.addChildToBack(objectLit);\n    }\n    previousNode = objectLit;\n  }\n  return currentNode;\n}",
    "exact_match": false,
    "ast_match": false,
    "compile": false,
    "test": false
}