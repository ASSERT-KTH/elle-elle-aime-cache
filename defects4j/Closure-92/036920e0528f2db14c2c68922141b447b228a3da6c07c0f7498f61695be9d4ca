{
    "generation": "void replace() {\n  if (firstNode == null) {\n    replacementNode = candidateDefinition;\n    return;\n  }\n\n  if (candidateDefinition != null && explicitNode != null) {\n    // Handle the duplicate definition case.\n    // ...\n  } else {\n    // Handle the case where there's not a duplicate definition.\n    replacementNode = createDeclarationNode();\n    if (firstModule == minimumModule) {\n      firstNode.getParent().addChildBefore(replacementNode, firstNode);\n    } else {\n      // Handle the case where the name was implicitly provided by two independent modules.\n      int indexOfDot = namespace.lastIndexOf('.');\n      if (indexOfDot == -1) {\n        // If there's no parent namespace, add it to the start of the module.\n        compiler.getNodeForCodeInsertion(minimumModule).addChildToBack(replacementNode);\n      } else {\n        // If there's a parent namespace, add it after the parent namespace node.\n        String parentNamespace = namespace.substring(0, indexOfDot);\n        ProvidedName parentName = providedNames.get(parentNamespace);\n        if (parentName != null && parentName.replacementNode != null) {\n          parentName.replacementNode.getParent().addChildAfter(replacementNode, parentName.replacementNode);\n        } else {\n          // If the parent namespace node hasn't been created yet, create it and add the node.\n          Node parentNamespaceNode = createDeclarationNode(parentNamespace);\n          compiler.getNodeForCodeInsertion(minimumModule).addChildToBack(parentNamespaceNode);\n          parentNamespaceNode.addChildToBack(replacementNode);\n        }\n      }\n    }\n    if (explicitNode != null) {\n      explicitNode.detachFromParent();\n    }\n    compiler.reportCodeChange();\n  }\n}",
    "exact_match": false,
    "ast_match": false,
    "compile": false,
    "test": false
}