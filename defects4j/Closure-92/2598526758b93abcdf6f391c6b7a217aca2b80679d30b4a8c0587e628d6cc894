{
    "generation": "void replace() {\n  if (firstNode == null) {\n    // Don't touch the base case ('goog').\n    replacementNode = candidateDefinition;\n    return;\n  }\n\n  // Handle the case where there is a duplicate definition for an explicitly\n  // provided symbol.\n  if (candidateDefinition!= null && explicitNode!= null) {\n    explicitNode.detachFromParent();\n    compiler.reportCodeChange();\n\n    // Does this need a VAR keyword?\n    replacementNode = candidateDefinition;\n    if (NodeUtil.isExpressionNode(candidateDefinition)) {\n      candidateDefinition.putBooleanProp(Node.IS_NAMESPACE, true);\n      Node assignNode = candidateDefinition.getFirstChild();\n      Node nameNode = assignNode.getFirstChild();\n      if (nameNode.getType() == Token.NAME) {\n        // Need to convert this assign to a var declaration.\n        Node valueNode = nameNode.getNext();\n        assignNode.removeChild(nameNode);\n        assignNode.removeChild(valueNode);\n        nameNode.addChildToFront(valueNode);\n        Node varNode = new Node(Token.VAR, nameNode);\n        varNode.copyInformationFrom(candidateDefinition);\n        candidateDefinition.getParent().replaceChild(\n            candidateDefinition, varNode);\n        nameNode.setJSDocInfo(assignNode.getJSDocInfo());\n        compiler.reportCodeChange();\n        replacementNode = varNode;\n      }\n    }\n  } else {\n    // Handle the case where there's not a duplicate definition.\n    replacementNode = createDeclarationNode();\n\n    // Before adding replacementNode, verify if minimumModule is common parent \n    // or ancestor. If not get the appropriate parent or common ancestor\n\n    Node temp = findCommonParent(compiler.getModule(minimumModule),\n        compiler.getNodeForCodeInsertion(compiler.getRootModule()));\n\n    if (firstModule == minimumModule) {\n      firstNode.getParent().addChildBefore(replacementNode, firstNode);\n    } else if (temp instanceof ModuleEntry) {\n        // this is a sub module's root node hence addChildToBack on its Node\n        ModuleEntry moduleParent = (ModuleEntry) temp;\n        moduleParent.getNode().getChildAtIndex(\n            moduleParent.getNode().getChildCount()-1\n        ).getParent().addChildToBack(replacementNode);\n    } else {\n        // In other cases parent is the immediate parent entry\n        parentEntryOf(replacementNode).getChildAtIndex(\n           parentEntryOf(replacementNode)\n          .getNode().getChildCount()-1\n       ).getParent()\n      .addChildToBack(replacementNode);\n       }\n \n    if (explicitNode!= null) {\n      explicitNode.detachFromParent();\n    }\n    compiler.reportCodeChange();\n  }\n}",
    "exact_match": false,
    "ast_match": false,
    "compile": false,
    "test": false
}