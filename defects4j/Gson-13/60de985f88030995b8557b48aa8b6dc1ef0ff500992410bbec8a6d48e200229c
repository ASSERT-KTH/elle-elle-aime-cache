{
    "generation": "private int peekNumber() throws IOException {\n    // Like nextNonWhitespace, this uses locals 'p' and 'l' to save inner-loop field access.\n    char[] buffer = this.buffer;\n    int p = pos;\n    int l = limit;\n\n    long value = 0; // Negative to accommodate Long.MIN_VALUE more easily.\n    boolean negative = false;\n    boolean fitsInLong = true;\n    int last = NUMBER_CHAR_NONE;\n\n    int i = 0;\n    boolean isNegativeZero = false; // Added to track if we are processing a '-0' case.\n\n    charactersOfNumber:\n    for (; true; i++) {\n        if (p + i == l) {\n            if (i == buffer.length) {\n                return PEEKED_NONE;\n            }\n            if (!fillBuffer(i + 1)) {\n                break;\n            }\n            p = pos;\n            l = limit;\n        }\n\n        char c = buffer[p + i];\n        switch (c) {\n        case '-':\n            if (last == NUMBER_CHAR_NONE) {\n                negative = true;\n                last = NUMBER_CHAR_SIGN;\n                continue;\n            } else if (last == NUMBER_CHAR_EXP_E) {\n                last = NUMBER_CHAR_EXP_SIGN;\n                continue;\n            }\n            return PEEKED_NONE;\n\n        case '+':\n            if (last == NUMBER_CHAR_EXP_E) {\n                last = NUMBER_CHAR_EXP_SIGN;\n                continue;\n            }\n            return PEEKED_NONE;\n\n        case 'e':\n        case 'E':\n            if (last == NUMBER_CHAR_DIGIT || last == NUMBER_CHAR_FRACTION_DIGIT) {\n                last = NUMBER_CHAR_EXP_E;\n                continue;\n            }\n            return PEEKED_NONE;\n\n        case '.':\n            if (last == NUMBER_CHAR_DIGIT) {\n                last = NUMBER_CHAR_DECIMAL;\n                continue;\n            }\n            return PEEKED_NONE;\n\n        default:\n            if (c < '0' || c > '9') {\n                if (!isLiteral(c)) {\n                    break charactersOfNumber;\n                }\n                return PEEKED_NONE;\n            }\n            if (last == NUMBER_CHAR_SIGN || last == NUMBER_CHAR_NONE) {\n                // Check for negative zero scenario\n                if (c == '0' && negative) {\n                    isNegativeZero = true; \n                }\n                value = -(c - '0');\n                last = NUMBER_CHAR_DIGIT;\n            } else if (last == NUMBER_CHAR_DIGIT) {\n                if (value == 0 && c == '0') { \n                    if (isNegativeZero) {\n                        return PEEKED_NONE; // Prevent octal confusion, but accept '-0'\n                    } else {\n                        return PEEKED_NONE; // Leading '0' prefix is not allowed otherwise\n                    }\n                }\n                long newValue = value * 10 - (c - '0');\n                fitsInLong &= value > MIN_INCOMPLETE_INTEGER\n                        || (value == MIN_INCOMPLETE_INTEGER && newValue < value);\n                value = newValue;\n            } else if (last == NUMBER_CHAR_DECIMAL) {\n                last = NUMBER_CHAR_FRACTION_DIGIT;\n            } else if (last == NUMBER_CHAR_EXP_E || last == NUMBER_CHAR_EXP_SIGN) {\n                last = NUMBER_CHAR_EXP_DIGIT;\n            }\n        }\n    }\n\n    if (last == NUMBER_CHAR_DIGIT && fitsInLong && (value != Long.MIN_VALUE || negative)) {\n        peekedLong = negative ? value : -value;\n        pos += i;\n        return peeked = PEEKED_LONG;\n    } else if (last == NUMBER_CHAR_DIGIT || last == NUMBER_CHAR_FRACTION_DIGIT || last == NUMBER_CHAR_EXP_DIGIT) {\n        peekedNumberLength = i;\n        return peeked = PEEKED_NUMBER;\n    } else {\n        return PEEKED_NONE;\n    }\n}",
    "exact_match": false,
    "ast_match": false,
    "compile": true,
    "test": false
}