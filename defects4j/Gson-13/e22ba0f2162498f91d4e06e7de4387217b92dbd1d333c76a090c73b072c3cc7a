{
    "generation": "private int peekNumber() throws IOException {\n    // Like nextNonWhitespace, this uses locals 'p' and 'l' to save inner-loop field access.\n    char[] buffer = this.buffer;\n    int p = pos;\n    int l = limit;\n\n    // Track if the number is negative\n    boolean isNegative = false;\n    // Used to determine if the number is decimal or not\n    boolean isFractionDigit = false;\n    // Used to check if the number is in exponential format\n    boolean isExponential = false;\n\n    int i = 0;\n    charactersOfNumber:\n    for (; true; i++) {\n        if (p + i == l) {\n            if (i == buffer.length) {\n                // Though this looks like a well-formed number, it's too long to continue reading. Give up\n                // and let the application handle this as an unquoted literal.\n                return PEEKED_NONE;\n            }\n            if (!fillBuffer(i + 1)) {\n                break;\n            }\n            p = pos;\n            l = limit;\n        }\n\n        char c = buffer[p + i];\n        switch (c) {\n            case '-':\n                // The first character could be '-' sign\n                if (i == 0) {\n                    isNegative = true;\n                    continue;\n                }\n                // But not after 'e' or 'E' in a decimal number\n                else if (isExponential) {\n                    continue;\n                }\n                return PEEKED_NONE;\n\n            case '+':\n                // The '+' sign can only occur after 'e' or 'E' in a decimal number\n                if (isExponential) {\n                    continue;\n                }\n                return PEEKED_NONE;\n\n            case 'e':\n            case 'E':\n                // 'e' or 'E' can only occur once in a decimal number\n                if (isExponential) {\n                    return PEEKED_NONE;\n                }\n                isExponential = true;\n                continue;\n\n            case '.':\n                // A decimal number can only contain one '.'\n                if (isFractionDigit || isExponential) {\n                    return PEEKED_NONE;\n                }\n                isFractionDigit = true;\n                continue;\n\n            default:\n                if (c < '0' || c > '9') {\n                    if (!isLiteral(c)) {\n                        break charactersOfNumber;\n                    }\n                    return PEEKED_NONE;\n                }\n        }\n    }\n\n    // At this point, a well-formed number has been read. Process it accordingly.\n    peekedNumberLength = i;\n    return peeked = isNegative || isFractionDigit || isExponential ? PEEKED_NUMBER : PEEKED_LONG;\n}",
    "exact_match": false,
    "ast_match": false,
    "compile": true,
    "test": false
}