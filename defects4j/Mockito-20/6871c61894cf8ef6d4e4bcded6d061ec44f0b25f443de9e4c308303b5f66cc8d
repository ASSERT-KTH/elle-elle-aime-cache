{
    "generation": "public <T> T createMock(MockCreationSettings<T> settings, MockHandler handler) {\n    if (settings.getSerializableMode() == SerializableMode.ACROSS_CLASSLOADERS) {\n        throw new MockitoException(\"Serialization across classloaders not yet supported with ByteBuddyMockMaker\");\n    }\n    Class<? extends T> mockedProxyType = cachingMockBytecodeGenerator.get(\n            settings.getTypeToMock(),\n            settings.getExtraInterfaces()\n    );\n    T mockInstance = null;\n    try {\n        if (settings.useConstructor()) {\n            // Try to instantiate using a constructor\n            mockInstance = tryInstantiateWithConstructor(settings, mockedProxyType);\n        } else {\n            // Fallback to default instantiation strategy\n            mockInstance = classInstantiator.instantiate(mockedProxyType);\n        }\n        MockMethodInterceptor.MockAccess mockAccess = (MockMethodInterceptor.MockAccess) mockInstance;\n        mockAccess.setMockitoInterceptor(new MockMethodInterceptor(asInternalMockHandler(handler), settings));\n\n        return ensureMockIsAssignableToMockedType(settings, mockInstance);\n    } catch (ClassCastException cce) {\n        throw new MockitoException(join(\n                \"ClassCastException occurred while creating the mockito mock :\",\n                \"  class to mock : \" + describeClass(mockedProxyType),\n                \"  created class : \" + describeClass(settings.getTypeToMock()),\n                \"  proxy instance class : \" + describeClass(mockInstance),\n                \"  instance creation by : \" + classInstantiator.getClass().getSimpleName(),\n                \"\",\n                \"You might experience classloading issues, please ask the mockito mailing-list.\",\n                \"\"\n        ), cce);\n    } catch (InstantiationException | IllegalAccessException | InvocationTargetException e) {\n        if (settings.useConstructor()) {\n            handleConstructorException(settings, e);\n        } else {\n            throw new MockitoException(\"Unable to create mock instance of type '\" + mockedProxyType.getSuperclass().getSimpleName() + \"'\", e);\n        }\n    }\n}\n\n// Helper method to try instantiating with a constructor\nprivate <T> T tryInstantiateWithConstructor(MockCreationSettings<T> settings, Class<? extends T> mockedProxyType) throws InstantiationException, IllegalAccessException, InvocationTargetException {\n    Constructor<?> constructor = getSuitableConstructor(settings, mockedProxyType);\n    if (constructor!= null) {\n        Object[] args = getConstructorArgs(settings, constructor);\n        return mockedProxyType.cast(constructor.newInstance(args));\n    } else {\n        throw new InstantiationException(\"No suitable constructor found for \" + mockedProxyType.getName());\n    }\n}\n\n// Helper method to get a suitable constructor\nprivate Constructor<?> getSuitableConstructor(MockCreationSettings<?> settings, Class<?> mockedProxyType) {\n    if (settings.useConstructor() && mockedProxyType.isMemberClass() &&!mockedProxyType.isStatic()) {\n        // Inner class, try to find a constructor with the outer instance as the first parameter\n        return Arrays.stream(mockedProxyType.getConstructors())\n               .filter(constructor -> constructor.getParameterCount() > 0 && constructor.getParameterTypes()[0].equals(settings.getOuterClass()))\n               .findFirst().orElse(null);\n    } else {\n        // Look for a no-arg constructor\n        return Arrays.stream(mockedProxyType.getConstructors())\n               .filter(constructor -> constructor.getParameterCount() == 0)\n               .findFirst().orElse(null);\n    }\n}\n\n// Helper method to get constructor arguments\nprivate Object[] getConstructorArgs(MockCreationSettings<?> settings, Constructor<?> constructor) {\n    Class<?>[] parameterTypes = constructor.getParameterTypes();\n    Object[] args = new Object[parameterTypes.length];\n    if (settings.useConstructor() && settings.getOuterClass()!= null && parameterTypes[0].equals(settings.getOuterClass())) {\n        // Inner class, set the outer instance as the first argument\n        args[0] = settings.getOuterInstance();\n        // Try to find matching arguments for the remaining parameters\n        for (int i = 1; i < parameterTypes.length; i++) {\n            // TODO: currently only supports simple types and Mockito mocks\n            // (you might want to enhance this to support more types or use a more sophisticated dependency injection mechanism)\n            if (parameterTypes[i].isPrimitive() || parameterTypes[i].equals(String.class)) {\n                args[i] = getDefaultPrimitiveValue(parameterTypes[i]);\n            } else if (settings.getMocks().stream().anyMatch(mock -> parameterTypes[i].isAssignableFrom(mock.getClass()))) {\n                args[i] = settings.getMocks().stream()\n                       .filter(mock -> parameterTypes[i].isAssignableFrom(mock.getClass()))\n                       .findFirst().orElseThrow(() -> new MockitoException(\" Unable to find mock for constructor parameter \" + parameterTypes[i].getName()));\n            } else {\n                throw new MockitoException(\" Unable to create mock instance due to missing dependency for constructor parameter \" + parameterTypes[i].getName());\n            }\n        }\n    }\n    return args;\n}\n\n// Helper method to handle constructor exceptions\nprivate void handleConstructorException(MockCreationSettings<?> settings, Throwable e) {\n    if (e instanceof InvocationTargetException) {\n        Throwable targetException = ((InvocationTargetException) e).getTargetException();\n        if (targetException!= null) {\n            throw new MockitoException(\"Unable to create mock instance of type '\" + settings.getTypeToMock().getName() + \"'\", targetException);\n        }\n    }\n    throw new MockitoException(\"Unable to create mock instance of type '\" + settings.getTypeToMock().getName() + \"': \" + (e.getMessage()!= null? e.getMessage() : e.getClass().getName()), e);\n}\n\n// Helper method to get default primitive values\nprivate Object getDefaultPrimitiveValue(Class<?> type) {\n    if (type.equals(boolean.class)) return false;\n    if (type.equals(byte.class)) return (byte) 0;\n    if (type.equals(short.class)) return (short) 0;\n    if (type.equals(char.class)) return (char) 0;\n    if (type.equals(int.class)) return 0;\n    if (type.equals(long.class)) return 0L;\n    if (type.equals(float.class)) return 0.0f;\n    if (type.equals(double.class)) return 0.0;\n    throw new MockitoException(\"Unsupported primitive type \" + type.getName());\n}",
    "exact_match": false,
    "ast_match": false,
    "compile": false,
    "test": false
}