{
    "generation": "public <T> T createMock(MockCreationSettings<T> settings, MockHandler handler) {\n    if (settings.getSerializableMode() == SerializableMode.ACROSS_CLASSLOADERS) {\n        throw new MockitoException(\"Serialization across classloaders not yet supported with ByteBuddyMockMaker\");\n    }\n\n    Class<? extends T> mockedProxyType = cachingMockBytecodeGenerator.get(\n            settings.getTypeToMock(),\n            settings.getExtraInterfaces()\n    );\n\n    T mockInstance = null;\n    try {\n        // Use the appropriate constructor, if specified\n        if (settings.getOuterClassInstance() != null) {\n            mockInstance = classInstantiator.instantiate(mockedProxyType, settings.getOuterClassInstance());\n        } else if (settings.getConstructorArgs() != null && settings.getConstructorArgs().length > 0) {\n            mockInstance = classInstantiator.instantiate(mockedProxyType, settings.getConstructorArgs());\n        } else {\n            mockInstance = classInstantiator.instantiate(mockedProxyType);\n        }\n\n        MockMethodInterceptor.MockAccess mockAccess = (MockMethodInterceptor.MockAccess) mockInstance;\n        mockAccess.setMockitoInterceptor(new MockMethodInterceptor(asInternalMockHandler(handler), settings));\n\n        // Initialize the mock instance if it's a spy and the type to mock is not an interface\n        if (settings.isSpy() && !settings.getTypeToMock().isInterface()) {\n            Class<?> typeToMock = settings.getTypeToMock();\n            if (typeToMock.isMemberClass() && !Modifier.isStatic(typeToMock.getModifiers())) {\n                Constructor<?> constructor = typeToMock.getDeclaredConstructors()[0];\n                constructor.setAccessible(true);\n                Object realInstance = constructor.newInstance(settings.getOuterClassInstance());\n                copyProperties(realInstance, mockInstance);\n            } else {\n                Constructor<?> constructor = typeToMock.getDeclaredConstructor();\n                constructor.setAccessible(true);\n                Object realInstance = constructor.newInstance();\n                copyProperties(realInstance, mockInstance);\n            }\n        }\n\n        return ensureMockIsAssignableToMockedType(settings, mockInstance);\n    } catch (ClassCastException cce) {\n        throw new MockitoException(join(\n                \"ClassCastException occurred while creating the mockito mock :\",\n                \"  class to mock : \" + describeClass(mockedProxyType),\n                \"  created class : \" + describeClass(settings.getTypeToMock()),\n                \"  proxy instance class : \" + describeClass(mockInstance),\n                \"  instance creation by : \" + classInstantiator.getClass().getSimpleName(),\n                \"\",\n                \"You might experience classloading issues, please ask the mockito mailing-list.\",\n                \"\"\n        ), cce);\n    } catch (Exception e) {\n        // Handle various exceptions in a more specific way\n        if (e instanceof NoSuchMethodException) {\n            throw new MockitoException(\"Unable to create mock instance of type '\" + settings.getTypeToMock().getSimpleName() + \"'. No default constructor found.\", e);\n        } else if (e instanceof IllegalAccessException || e instanceof InvocationTargetException) {\n            throw new MockitoException(\"Unable to create mock instance of type '\" + settings.getTypeToMock().getSimpleName() + \"'. Constructor is not accessible or threw an exception.\", e);\n        } else if (e instanceof InstantiationException) {\n            throw new MockitoException(\"Unable to create mock instance of type '\" + settings.getTypeToMock().getSimpleName() + \"'. Class cannot be instantiated.\", e);\n        } else {\n            throw new MockitoException(\"Unable to create mock instance of type '\" + settings.getTypeToMock().getSimpleName() + \"'\", e);\n        }\n    }\n}\n\n// Helper method to copy properties from one object to another\nprivate void copyProperties(Object source, Object target) {\n    Class<?> sourceClass = source.getClass();\n    Class<?> targetClass = target.getClass();\n    for (Field field : sourceClass.getDeclaredFields()) {\n        try {\n            Field targetField = targetClass.getDeclaredField(field.getName());\n            field.setAccessible(true);\n            targetField.setAccessible(true);\n            targetField.set(target, field.get(source));\n        } catch (NoSuchFieldException | IllegalAccessException ignored) {\n            // Field not present in target or not accessible, ignore\n        }\n    }\n}",
    "exact_match": false,
    "ast_match": false,
    "compile": false,
    "test": false
}