{
    "generation": "public <T> T createMock(MockCreationSettings<T> settings, MockHandler handler) {\n    if (settings.getSerializableMode() == SerializableMode.ACROSS_CLASSLOADERS) {\n        throw new MockitoException(\"Serialization across classloaders not yet supported with ByteBuddyMockMaker\");\n    }\n    Class<? extends T> mockedProxyType = cachingMockBytecodeGenerator.get(\n            settings.getTypeToMock(),\n            settings.getExtraInterfaces()\n    );\n    T mockInstance;\n    try {\n        Class<?> outerClass = Class.forName(mockedProxyType.getName().split(\"\\\\$\")[0]);\n        Constructor<?> constructor = mockedProxyType.getConstructor(outerClass);\n        mockInstance = (T) classInstantiator.instantiateWithConstructor(constructor, new Object[]{settings.getOuterInstance()});\n    } catch (Exception e) {\n        try {\n            Constructor<?> constructor = mockedProxyType.getConstructor();\n            mockInstance = (T) classInstantiator.instantiateWithConstructor(constructor);\n        } catch (Exception ex) {\n            throw new MockitoException(\"Unable to create mock instance of type '\" + mockedProxyType.getSimpleName() + \"'\", ex);\n        }\n    }\n    MockMethodInterceptor.MockAccess mockAccess = (MockMethodInterceptor.MockAccess) mockInstance;\n    mockAccess.setMockitoInterceptor(new MockMethodInterceptor(asInternalMockHandler(handler), settings));\n\n    return ensureMockIsAssignableToMockedType(settings, mockInstance);\n}",
    "exact_match": false,
    "ast_match": false,
    "compile": false,
    "test": false
}