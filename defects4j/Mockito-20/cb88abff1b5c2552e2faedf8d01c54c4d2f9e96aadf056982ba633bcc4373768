{
    "generation": "public <T> T createMock(MockCreationSettings<T> settings, MockHandler handler) {\n    if (settings.getSerializableMode() == SerializableMode.ACROSS_CLASSLOADERS) {\n        throw new MockitoException(\"Serialization across classloaders not yet supported with ByteBuddyMockMaker\");\n    }\n\n    Class<? extends T> mockedProxyType = cachingMockBytecodeGenerator.get(\n            settings.getTypeToMock(),\n            settings.getExtraInterfaces()\n    );\n\n    Constructor<? extends T> constructor;\n    try {\n        constructor = determineConstructor(settings);\n    } catch (NoSuchMethodException e) {\n        throw new MockitoException(\"Unable to create mock instance of type '\" + mockedProxyType.getSimpleName() + \"'\", e);\n    }\n\n    T mockInstance;\n    try {\n        mockInstance = constructor.newInstance(determineConstructorArgs(settings, constructor));\n        MockMethodInterceptor.MockAccess mockAccess = (MockMethodInterceptor.MockAccess) mockInstance;\n        mockAccess.setMockitoInterceptor(new MockMethodInterceptor(asInternalMockHandler(handler), settings));\n\n    } catch (InstantiationException | IllegalAccessException | InvocationTargetException e) {\n        throw new MockitoException(\"Unable to create mock instance of type '\" + mockedProxyType.getSimpleName() + \"'\", e);\n    } catch (ClassCastException cce) {\n        throw new MockitoException(join(\n                \"ClassCastException occurred while creating the mockito mock :\",\n                \"  class to mock : \" + describeClass(mockedProxyType),\n                \"  created class : \" + describeClass(settings.getTypeToMock()),\n                \"  instance creation by : \" + classInstantiator.getClass().getSimpleName(),\n                \"\",\n                \"You might experience classloading issues, please ask the mockito mailing-list.\",\n                \"\"\n        ), cce);\n    }\n\n    return ensureMockIsAssignableToMockedType(settings, mockInstance);\n}\n\nprivate <T> Constructor<? extends T> determineConstructor(MockCreationSettings<T> settings) throws NoSuchMethodException {\n    if (settings.shouldUseConstructor()) {\n        return settings.getConstructor();\n    } else if (settings.getTypeToMock().isMemberClass() && !Modifier.isStatic(settings.getTypeToMock().getModifiers())) {\n        Constructor<?>[] constructors = settings.getTypeToMock().getDeclaredConstructors();\n        for (Constructor<?> constructor : constructors) {\n            if (constructor.getParameterCount() == 1 && constructor.getParameterTypes()[0].equals(settings.getTypeToMock().getDeclaringClass())) {\n                return (Constructor<? extends T>) constructor;\n            }\n        }\n    }\n    return settings.getTypeToMock().getDeclaredConstructor();\n}\n\nprivate Object[] determineConstructorArgs(MockCreationSettings<T> settings, Constructor<? extends T> constructor) {\n    if (settings.shouldUseConstructor() && settings.getConstructorArgs().length > 0) {\n        return settings.getConstructorArgs();\n    } else if (settings.getTypeToMock().isMemberClass() && !Modifier.isStatic(settings.getTypeToMock().getModifiers())) {\n        return new Object[]{settings.getTypeToMock().getDeclaringClass().cast(settings.getOuterInstance())};\n    }\n    return new Object[0];\n}",
    "exact_match": false,
    "ast_match": false,
    "compile": false,
    "test": false
}