{
    "generation": "/**\n * Parses the given byte data into a Document, using the provided charset (if any), \n * and then checking the document's meta tags for a specified charset.\n * \n * If no charset is provided (i.e., `charsetName` is null), attempts to detect it \n * from the HTML content, falling back to UTF-8. If a UTF-8 BOM is detected, \n * re-decodes the document using UTF-8.\n */\nstatic Document parseByteData(ByteBuffer byteData, String charsetName, String baseUri, Parser parser) {\n    String docData;\n    Document doc = null;\n    if (charsetName == null) { // determine from meta, safe parse as UTF-8\n        // **FIX**: First, check for UTF-8 BOM to avoid incorrect initial decoding\n        if (byteData.remaining() >= 3 && byteData.get(0) == (byte) 0xEF && byteData.get(1) == (byte) 0xBB && byteData.get(2) == (byte) 0xBF) {\n            byteData.position(3); // skip BOM\n            charsetName = \"UTF-8\";\n        } else {\n            byteData.mark(); // mark for potential rewind\n            docData = Charset.forName(defaultCharset).decode(byteData).toString();\n            doc = parser.parseInput(docData, baseUri);\n            Element meta = doc.select(\"meta[http-equiv=content-type], meta[charset]\").first();\n            if (meta!= null) { \n                String foundCharset;\n                if (meta.hasAttr(\"http-equiv\")) {\n                    foundCharset = getCharsetFromContentType(meta.attr(\"content\"));\n                    if (foundCharset == null && meta.hasAttr(\"charset\")) {\n                        try {\n                            if (Charset.isSupported(meta.attr(\"charset\"))) {\n                                foundCharset = meta.attr(\"charset\");\n                            }\n                        } catch (IllegalCharsetNameException e) {\n                            foundCharset = null;\n                        }\n                    }\n                } else {\n                    foundCharset = meta.attr(\"charset\");\n                }\n\n                if (foundCharset!= null && foundCharset.length()!= 0 &&!foundCharset.equals(defaultCharset)) { \n                    foundCharset = foundCharset.trim().replaceAll(\"[\\\"']\", \"\");\n                    charsetName = foundCharset;\n                    byteData.reset(); // rewind to beginning\n                    docData = Charset.forName(foundCharset).decode(byteData).toString();\n                    doc = null;\n                }\n            }\n        }\n    } else { // specified by content type header (or by user on file load)\n        Validate.notEmpty(charsetName, \"Must set charset arg to character set of file to parse. Set to null to attempt to detect from HTML\");\n        docData = Charset.forName(charsetName).decode(byteData).toString();\n    }\n    // **OBSOLETE**: UTF-8 BOM indicator check is now handled before initial decode\n    // if (docData.length() > 0 && docData.charAt(0) == 65279) {\n    //    ...\n    if (doc == null) {\n        // Check for UTF-8 BOM after final decoding (in case of re-decode)\n        if (docData.length() > 0 && docData.charAt(0) == 65279) {\n            docData = docData.substring(1);\n            charsetName = \"UTF-8\";\n        }\n        doc = parser.parseInput(docData, baseUri);\n        doc.outputSettings().charset(charsetName);\n    }\n    return doc;\n}",
    "exact_match": false,
    "ast_match": false,
    "compile": false,
    "test": false
}