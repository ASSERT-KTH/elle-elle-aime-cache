{
    "generation": "protected Date parseAsISO8601(String dateStr, ParsePosition pos)\n{\n    /* 21-May-2009, tatu: DateFormat has very strict handling of\n     * timezone modifiers for ISO-8601. So we need to do some scrubbing.\n     */\n\n    /* ... existing code ... */\n\n    int len = dateStr.length();\n    char c = dateStr.charAt(len-1);\n    DateFormat df;\n\n    // [JACKSON-200]: need to support \"plain\" date...\n    if (len <= 10 && Character.isDigit(c)) {\n        /* ... existing code ... */\n    } else if (c == 'Z') {\n        /* ... existing code ... */\n    } else {\n        // Let's see if we have timezone indicator or not...\n        if (hasTimeZone(dateStr)) {\n            // Milliseconds partial or missing; and even seconds are optional\n            len = dateStr.length();\n            // Check if millisecond part is missing or partially present\n            int millisecondIndex = dateStr.lastIndexOf('.') + 1;\n            int timeZoneIndex = len - 5;\n            if (millisecondIndex > 0 && millisecondIndex <= timeZoneIndex) {\n                int numDigits = timeZoneIndex - millisecondIndex;\n                StringBuilder sb = new StringBuilder(dateStr);\n                // Append zeros to ensure we have three digits for milliseconds\n                while (numDigits < 3) {\n                    sb.append('0');\n                    numDigits++;\n                }\n                dateStr = sb.toString();\n            } else {\n                StringBuilder sb = new StringBuilder(dateStr);\n                sb.insert(len-5, \".000\");\n                dateStr = sb.toString();\n            }\n            /* ... rest of existing code ... */\n        } else {\n            /* ... existing code ... */\n        }\n    }\n    return df.parse(dateStr, pos);\n}",
    "exact_match": false,
    "ast_match": false,
    "compile": false,
    "test": false
}