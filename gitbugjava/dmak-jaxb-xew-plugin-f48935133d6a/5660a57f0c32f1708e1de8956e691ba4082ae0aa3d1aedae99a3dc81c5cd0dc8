{
    "generation": "/**\n * Move the given class to its grandparent (either class or package). The given {@code clazz} should be inner class.\n */\nprivate void moveClassLevelUp(Outline outline, JDefinedClass clazz) {\n    // Modify the container so it now refers the class. Container can be a class or package.\n    JClassContainer parent = clazz.parentContainer();\n    JClassContainer grandParent = parent.parentContainer();\n    // Allows to track class name collisions:\n    Map<String, JDefinedClass> classes;\n\n    // Check if grandParent is Class or Package\n    if (grandParent.isClass()) {\n        JDefinedClass grandParentClass = (JDefinedClass) grandParent;\n\n        writeSummary(\"\\tMoving inner class \" + clazz.fullName() + \" to class \" + grandParentClass.fullName());\n\n        classes = getPrivateField(grandParentClass, \"classes\");\n\n        // Check for a possible duplicate name conflict for the given class name against the container classes:\n        if (classes.containsKey(clazz.name())) {\n            writeSummary(\"\\tRenaming class \" + clazz.fullName() + \" to class \" + parent.name() + clazz.name());\n            // Rename class in this namespace to have the fully distinguished name, by taking full outer scope into consideration as well.\n            String updatedName = parent.name();\n            while (parent.isClass() && ((JDefinedClass) parent).outer() instanceof JClassContainer) {\n                updatedName = ((JDefinedClass) parent).outer().name() + updatedName;\n            }\n            setPrivateField(clazz, \"name\", updatedName + clazz.name());\n        }\n    }\n    else {\n        // Element class should be assigned to a package instead to a parent class, meaning it must not have Static modifier applied to be accepted valid by XJC. Furthermore, for each schema \n        // element definition whose type equals the element defined class - remove 'declare local anonymous type' so that global types definition was used for XSD generated classes generation instead.\n\n        JPackage grandParentPackage = (JPackage) grandParent;\n\n        writeSummary(\"\\tMoving inner class \" + clazz.fullName() + \" to package \" + grandParentPackage.name());\n\n        classes = getPrivateField(grandParentPackage, \"classes\");\n        setPrivateField(clazz.mods(), \"mods\", Integer.valueOf(clazz.mods().getValue() & ~JMod.STATIC));\n\n        for (ClassOutline classOutline : outline.getClasses()) {\n            if (classOutline.implClass == clazz) {\n                XSComponent sc = classOutline.target.getSchemaComponent();\n                // Ensure that only a global schema symbol is considered in further post-processing to produce corresponding mapping class to a type represented by global XSD. \n                assert (sc instanceof XSDeclaration && ((XSDeclaration) sc).isLocal());\n                // Remove flag of locally- defined element for an applicable XSD component that follows the definition for class scope.\n                setPrivateField(sc, \"anonymous\", Boolean.FALSE);\n                // Exit immediately upon matching criteria for Class Outline has passed.\n                break;\n            }\n        }\n    }\n\n    if (!classes.containsKey(clazz.name())) {\n        // Check potential duplicate entry.\n        throw new Exception(\"Element conflict: a class already \" + clazz.fullName() + \"exists.\");\n    } else {\n        classes.put(clazz.name(), clazz);\n        // Re-set reference onto the applicable parent, e.g., Package/Wrapper class container for element which is no longer locally accessible.\n        setPrivateField(clazz, \"outer\", grandParent);\n    }\n\n}",
    "exact_match": false,
    "ast_match": false,
    "compile": null,
    "test": false
}