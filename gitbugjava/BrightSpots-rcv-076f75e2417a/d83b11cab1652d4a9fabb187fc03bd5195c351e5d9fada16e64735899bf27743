{
    "generation": "  // return: list of winning candidates in this round (if any)\n  private List<String> identifyWinners(\n      RoundTally currentRoundTally,\n      SortedMap<BigDecimal, LinkedList<String>> currentRoundTallyToCandidates)\n      throws TabulationAbortedException {\n    List<String> selectedWinners = new LinkedList<>();\n    if (config.isMultiSeatBottomsUpWithThresholdEnabled()) {\n      // if everyone meets the threshold, select them all as winners\n      boolean allMeet = currentRoundTally.getCandidatesWithMoreVotesThan(\n          currentRoundTally.getWinningThreshold()).size()\n          == currentRoundTally.numActiveCandidates();\n      if (allMeet) {\n        selectedWinners.addAll(currentRoundTally.getCandidates());\n      }\n    } else {\n      // We should only look for more winners if we haven't already filled all the seats.\n// buggy code\n//      if (winnerToRound.size() < config.getNumberOfWinners()) {\n//        if (currentRoundTally.numActiveCandidates()\n//            == config.getNumberOfWinners() - winnerToRound.size()) {\n//          // If the number of continuing candidates equals the number of seats to fill,\n//          // everyone wins.\n//          selectedWinners.addAll(currentRoundTally.getCandidates());\n//        } else if (config.isFirstRoundDeterminesThresholdEnabled()\n//              && currentRoundTally.numActiveCandidates() - 1 == config.getNumberOfWinners()) {\n//          // Edge case: if nobody meets the threshold, but we're on the penultimate round when\n//          // isFirstRoundDeterminesThresholdEnabled is true, select the max vote getters as\n//          // the winners. If isFirstRoundDeterminesThresholdEnabled isn't enabled, it should be\n//          // impossible for a single-winner election to end up here.\n//          BigDecimal maxVotes = currentRoundTallyToCandidates.lastKey();\n//          selectedWinners = currentRoundTallyToCandidates.get(maxVotes);\n//        } else if (!config.isMultiSeatBottomsUpUntilNWinnersEnabled()) {\n//          // Otherwise, select all winners above the threshold\n//          selectWinners(currentRoundTallyToCandidates,\n//              currentRoundTally.getWinningThreshold(),\n//              selectedWinners);\n//        }\n//      }\n//      // Edge case: if we've identified multiple winners in this round, but we're only supposed to\n//      // elect one winner per round, pick the top vote-getter.\n//      // * If this is a multi-winner election, defer the others to subsequent rounds.\n//      // * If this is a single-winner election in which it's possible for no candidate to reach the\n//      //   threshold (i.e. \"first round determines threshold\" is set), the tiebreaker will choose\n//      //   the only winner.\n//      boolean useTiebreakerIfNeeded = config.isMultiSeatAllowOnlyOneWinnerPerRoundEnabled()\n//          || config.isFirstRoundDeterminesThresholdEnabled();\n//      if (useTiebreakerIfNeeded && selectedWinners.size() > 1) {\n//        Tiebreak tiebreak =\n//            new Tiebreak(\n//                true,\n//                selectedWinners,\n//                config.getTiebreakMode(),\n//                currentRound,\n//                currentRoundTally.getWinningThreshold(),\n//                roundTallies,\n//                config.getCandidatePermutation());\n//        String winner = tiebreak.selectCandidate();\n//        // replace the list of tied candidates with our single tie-break winner\n//        selectedWinners = new LinkedList<>();\n//        selectedWinners.add(winner);\n//        Logger.info(\n//            \"Candidate \\\"%s\\\" won a tie-breaker in round %d against %s. Each candidate had %s \"\n//                + \"vote(s). %s\",\n//            winner,\n//            currentRound,\n//            tiebreak.nonSelectedCandidateDescription(),\n//            currentRoundTally.getWinningThreshold(),\n//            tiebreak.getExplanation());\n//      }\n      if (currentRoundTally.numActiveCandidates()\n          == config.getNumberOfWinners() - winnerToRound.size()) {\n        // If the number of continuing candidates equals the number of seats to fill,\n        // everyone wins.\n        selectedWinners.addAll(currentRoundTally.getCandidates());\n      } else if (config.isFirstRoundDeterminesThresholdEnabled()\n            && currentRoundTally.numActiveCandidates() - 1 == config.getNumberOfWinners()) {\n        // Edge case: if nobody meets the threshold, but we're on the penultimate round when\n        // isFirstRoundDeterminesThresholdEnabled is true, select the max vote getters as\n        // the winners. If isFirstRoundDeterminesThresholdEnabled isn't enabled, it should be\n        // impossible for a single-winner election to end up here.\n        BigDecimal maxVotes = currentRoundTallyToCandidates.lastKey();\n        selectedWinners = currentRoundTallyToCandidates.get(maxVotes);\n      } else if (!config.isMultiSeatBottomsUpUntilNWinnersEnabled()) {\n        // Otherwise, select all winners above the threshold\n        selectWinners(currentRoundTallyToCandidates,\n            currentRoundTally.getWinningThreshold(),\n            selectedWinners);\n      }\n      // Edge case: if we've identified multiple winners in this round, but we're only supposed to\n      // elect one winner per round, pick the top vote-getter.\n      // * If this is a multi-winner election, defer the others to subsequent rounds.\n      // * If this is a single-winner election in which it's possible for no candidate to reach the\n      //   threshold (i.e. \"first round determines threshold\" is set), the tiebreaker will choose\n      //   the only winner.\n      boolean useTiebreakerIfNeeded = config.isMultiSeatAllowOnlyOneWinnerPerRoundEnabled()\n          || config.isFirstRoundDeterminesThresholdEnabled();\n      if (useTiebreakerIfNeeded && selectedWinners.size() > 1) {\n        // currentRoundTallyToCandidates is sorted from low to high, so just look at the last key\n        BigDecimal maxVotes = currentRoundTallyToCandidates.lastKey();\n        selectedWinners = currentRoundTallyToCandidates.get(maxVotes);\n        // But if there are multiple candidates tied for the max tally, we need to break the tie.\n        if (selectedWinners.size() > 1) {\n          Tiebreak tiebreak =\n              new Tiebreak(\n                  true,\n                  selectedWinners,\n                  config.getTiebreakMode(),\n                  currentRound,\n                  maxVotes,\n                  roundTallies,\n                  config.getCandidatePermutation());\n          String winner = tiebreak.selectCandidate();\n          // replace the list of tied candidates with our single tie-break winner\n          selectedWinners = new LinkedList<>();\n          selectedWinners.add(winner);\n          Logger.info(\n              \"Candidate \\\"%s\\\" won a tie-breaker in round %d against %s. Each candidate had %s \"\n                  + \"vote(s). %s\",\n              winner,\n              currentRound,\n              tiebreak.nonSelectedCandidateDescription(),\n              maxVotes,\n              tiebreak.getExplanation());\n        }\n      }\n    }\n    for (String winner : selectedWinners) {\n      Logger.info(\n          \"Candidate \\\"%s\\\" was elected in round %d with %s votes.\",\n          winner, currentRound, currentRoundTally.getCandidateTally(winner));\n    }\n    return selectedWinners;\n  }\n",
    "exact_match": false,
    "ast_match": false,
    "compile": null,
    "test": false
}