{
    "generation": "/**\n * Consumes a sub-query (enclosed or not) from the token queue, \n * stopping at combinators if the sub-query is not empty, \n * or consuming a single token if the sub-query is empty.\n * \n * @return the consumed sub-query as a string\n */\nprivate String consumeSubQuery() {\n    StringBuilder sq = StringUtil.borrowBuilder();\n    boolean inEnclosure = false; // track if we're inside an enclosure\n    while (!tq.isEmpty()) {\n        if (tq.matches(\"(\")) {\n            if (inEnclosure) {\n                sq.append(tq.consume()); // append if already in enclosure\n            } else {\n                inEnclosure = true;\n                sq.append(\"(\").append(tq.chompBalanced('(', ')')).append(\")\");\n                inEnclosure = false; // exit enclosure after consumption\n            }\n        } else if (tq.matches(\"[\")) {\n            if (inEnclosure) {\n                sq.append(tq.consume()); // append if already in enclosure\n            } else {\n                inEnclosure = true;\n                sq.append(\"[\").append(tq.chompBalanced('[', ']')).append(\"]\");\n                inEnclosure = false; // exit enclosure after consumption\n            }\n        } else if (tq.matchesAny(Combinators)) {\n            if (sq.length() > 0 || inEnclosure) // break if non-empty or still in enclosure\n                break;\n            else\n                tq.consume();\n        } else {\n            if (inEnclosure) {\n                sq.append(tq.consume());\n            } else {\n                // If not in an enclosure, consume and stop to avoid over-selection\n                sq.append(tq.consume());\n                break;\n            }\n        }\n    }\n    return StringUtil.releaseBuilder(sq);\n}",
    "exact_match": false,
    "ast_match": false,
    "compile": null,
    "test": false
}