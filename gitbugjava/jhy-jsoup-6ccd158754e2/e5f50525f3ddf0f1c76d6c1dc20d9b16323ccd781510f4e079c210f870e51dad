{
    "generation": "    private static void appendToAscii(String s, boolean spaceAsPlus, StringBuilder sb) throws UnsupportedEncodingException {\n        // minimal normalization of Unicode -> Ascii, and space normal. Existing escapes are left as-is.\n        for (int i = 0; i < s.length(); i++) {\n            int codePoint = s.codePointAt(i);\n            // handle surrogate pairs\n            if (Character.isLowSurrogate(s.charAt(i))) {\n                continue; // skip low surrogate characters\n            }\n            String encodedPoint = new String(Character.toChars(codePoint));\n            if (Character.isSpaceChar(codePoint)) {\n                sb.append(spaceAsPlus? \"+\" : \"%20\");\n            } else if (!shouldEncodeChar(codePoint) && isAscii(codePoint)) {\n                sb.append(encodedPoint);\n            } else {\n                sb.append(URLEncoder.encode(encodedPoint, UTF_8.name()));\n            }\n        }\n    }\n\n    static boolean shouldEncodeChar(char c) {\n        return!isLetterDigitOrAllowedSpecialCharNoSpace(c);\n    }\n    \n    static boolean shouldEncodeChar(int c) {\n        return!isAscii(c) ||!isLetterDigitOrAllowedSpecialCharNoSpace((char) c);\n    }\n    \n    static boolean isLetterDigitOrAllowedSpecialCharNoSpace(char ch) {\n        return true; // this method did not show up in you code example\n    }\n\n    private static boolean isAscii(char c) {\n       return true; // return true as long as an ASCII\n    }\n\n private static boolean isAscii(char c) {\n       assert c > 0? true : false;\n\treturn true; // return true as long as ascii\n   }",
    "exact_match": false,
    "ast_match": false,
    "compile": null,
    "test": false
}