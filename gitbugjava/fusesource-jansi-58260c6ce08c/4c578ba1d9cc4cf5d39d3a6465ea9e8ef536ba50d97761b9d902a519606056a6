{
    "generation": "import java.io.IOException;\nimport java.util.*;\n\nclass Token {\n    int position;\n    boolean isBegin;\n\n    public Token(int position, boolean isBegin) {\n        this.position = position;\n        this.isBegin = isBegin;\n    }\n}\n\npublic class AnsiRenderer {\n\n    public static final String BEGIN_TOKEN = \"@|\";\n    public static final String END_TOKEN = \"|@\";\n    public static final int BEGIN_TOKEN_LEN = BEGIN_TOKEN.length();\n    public static final int END_TOKEN_LEN = END_TOKEN.length();\n    public static final String CODE_TEXT_SEPARATOR = \":\";\n    public static final String CODE_LIST_SEPARATOR = \",\";\n\n    /**\n     * Renders the given input to the target Appendable.\n     *\n     * @param input source to render\n     * @param target render onto this target Appendable.\n     * @return the given Appendable\n     * @throws IOException If an I/O error occurs\n     */\n    public static Appendable render(final String input, Appendable target) throws IOException {\n        List<Token> tokens = new ArrayList<>();\n        int beginPos = input.indexOf(BEGIN_TOKEN);\n        while (beginPos != -1) {\n            tokens.add(new Token(beginPos, true));\n            beginPos = input.indexOf(BEGIN_TOKEN, beginPos + 1);\n        }\n        int endPos = input.indexOf(END_TOKEN);\n        while (endPos != -1) {\n            tokens.add(new Token(endPos, false));\n            endPos = input.indexOf(END_TOKEN, endPos + 1);\n        }\n        Collections.sort(tokens, Comparator.comparingInt(t -> t.position));\n\n        Stack<Integer> stack = new Stack<>();\n        int previous = 0;\n        for (Token token : tokens) {\n            target.append(input.substring(previous, token.position));\n            if (token.isBegin) {\n                stack.push(token.position);\n            } else {\n                if (stack.isEmpty()) {\n                    throw new IllegalArgumentException(\"END_TOKEN appears without a matching BEGIN_TOKEN\");\n                }\n                int beginPosition = stack.pop();\n                int beginIndex = beginPosition + BEGIN_TOKEN_LEN;\n                int endIndex = token.position;\n                String spec = input.substring(beginIndex, endIndex);\n                String[] items = spec.split(CODE_TEXT_SEPARATOR, 2);\n                if (items.length != 2) {\n                    throw new IllegalArgumentException(\"Invalid specification: \" + spec);\n                }\n                String replacement = render(items[1], items[0].split(CODE_LIST_SEPARATOR));\n                target.append(replacement);\n            }\n            previous = token.position + (token.isBegin ? BEGIN_TOKEN_LEN : END_TOKEN_LEN);\n        }\n        target.append(input.substring(previous));\n\n        if (!stack.isEmpty()) {\n            throw new IllegalArgumentException(\"BEGIN_TOKEN(s) without matching END_TOKEN(s)\");\n        }\n\n        return target;\n    }\n\n    // Placeholder for the render method that takes items[1] and items[0].split(CODE_LIST_SEPARATOR)\n    private static String render(String text, String[] codes) {\n        // Implementation depends on the specific rendering logic\n        return text; // Placeholder implementation\n    }\n}",
    "exact_match": false,
    "ast_match": false,
    "compile": null,
    "test": false
}