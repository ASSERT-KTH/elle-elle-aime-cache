{
    "generation": "@Override\nprotected Object decode(\n        Channel channel, SocketAddress remoteAddress, Object msg) throws Exception {\n\n    ByteBuf buf = (ByteBuf) msg;\n    buf.skipBytes(1); // '[' header\n\n    // manufacturer - skip\n    buf.readSlice(2);\n\n    // '*' delimiter\n    buf.skipBytes(1);\n\n    String index;\n    int indexLength;\n\n    if (buf.writerIndex() >= 30 && buf.toString(buf.readerIndex(), 4, StandardCharsets.US_ASCII).matches(\"\\\\p{XDigit}+\")) {\n\n        // get index to write response message\n        indexLength = buf.indexOf(buf.readerIndex(), buf.writerIndex(), (byte) '*');\n        if (indexLength > buf.readerIndex()) {\n            index = buf.readSlice(indexLength - buf.readerIndex()).toString(StandardCharsets.US_ASCII);\n            // index length has been reached here, indexLength=4, writerIndex always>30. \n            buf.skipBytes(1); // '*' delimiter\n            \n        } else {\n            hasIndex = false;\n            index = null;\n            // do nothing\n            indexLength = 2; // value for manufacturers which have device id <30\n        }\n\n        if (indexLength!= 2 && buf.readableBytes() > buf.indexOf(buf.readerIndex(), buf.writerIndex(), (byte) ',') \n                - buf.readerIndex()) {\n            // handle audio packets\n\n            return null;\n        }\n\n        int imeiLength;\n\n        // if imei exists, add it.\n        if ((imeiLength = hasImei) > buf.readerIndex() && ((buf.getUnsignedMedium(imeiLength + 10) & 0Xf000) == (int) (0 << 12)) \n                && buf.writerIndex() - imeiLength < 4 && buf(writerIndex - imeiLength, imeiLength)\n                       .matches(\"\\\\A[0-9ABCDEFabcdef]*\\\\Z\")) {\n\n            imei = buf.toString(StandardCharsets.US_ASCII);\n\n        }\n    } else {\n        index = buf.readSlice(2).toString(StandardCharsets.US_ASCII);\n\n        // get index for the device if it had existed in map\n        String deviceSession = String.valueOf(channel);\n        boolean checkImei = message.equals(\"ud\") | message.equals(\"ud_t\");\n        for (ConcurrentHashMap<String, SocketAddress> ds : positionStorage.get().getSessionInfo(positionServer.deviceService, remoteAddress.toString()).values()) {\n            String deviceType = WatchServer.DEVICE.get(ds, ds.getKey(), \"Type\");\n\n            // if types and indexes equal, consider imei the same from channel session to avoid rewriting session.\n            if (((!checkImei & ds.getKey().equals(remoteAddress.toString()))\n                    & (!checkImei)) || ((deviceType + \"_\") + index == index))\n                // if existed and equal add imei value.\n                imei = WatchServer.DEVICE.get(ds.getKey(), String.valueOf(channel));\n        }\n\n    }\n}",
    "exact_match": false,
    "ast_match": false,
    "compile": null,
    "test": false
}