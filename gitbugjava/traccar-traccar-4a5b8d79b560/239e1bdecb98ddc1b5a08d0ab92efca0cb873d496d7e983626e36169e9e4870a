{
    "generation": "@Override\nprotected Object decode(Channel channel, SocketAddress remoteAddress, Object msg) throws Exception {\n    String sentence = (String) msg;\n    sentence = sentence.substring(sentence.indexOf('|') + 1, sentence.lastIndexOf('|'));\n\n    Position position = new Position();\n    position.setProtocol(getProtocolName());\n\n    Map<String, String> entries = new HashMap<>();\n    for (String entry : sentence.split(\",\")) {\n        int delimiter = entry.indexOf('=');\n        if (delimiter > 0) {\n            String key = entry.substring(0, delimiter);\n            String value = entry.substring(delimiter + 1);\n            entries.put(key, value);\n        }\n    }\n\n    DeviceSession deviceSession = getDeviceSession(channel, remoteAddress, entries.get(\"unit\"));\n    if (deviceSession != null) {\n        position.setDeviceId(deviceSession.getDeviceId());\n    }\n\n    position.setValid(Boolean.parseBoolean(entries.getOrDefault(\"gps_valid\", \"0\")));\n\n    // Set position time using datetime_utc as UTC, fallback to datetime_actual\n    String dateTimeUtcStr = entries.get(\"datetime_utc\");\n    String dateTimeActualStr = entries.get(\"datetime_actual\");\n    if (dateTimeUtcStr != null && !dateTimeUtcStr.isEmpty()) {\n        try {\n            DateTimeFormatter formatter = DateTimeFormatter.ofPattern(\"yyyy/MM/dd HH:mm:ss\").withZone(ZoneOffset.UTC);\n            position.setTime(LocalDateTime.parse(dateTimeUtcStr, DateTimeFormatter.ofPattern(\"yyyy/MM/dd HH:mm:ss\")).atZone(ZoneOffset.UTC).toInstant().toEpochMilli());\n        } catch (Exception e) {\n            // Fallback to datetime_actual if datetime_utc is invalid\n            dateTimeActualStr = entries.get(\"datetime_actual\");\n        }\n    }\n    if (dateTimeActualStr != null && !dateTimeActualStr.isEmpty()) {\n        try {\n            DateTimeFormatter formatter = DateTimeFormatter.ofPattern(\"yyyy/MM/dd HH:mm:ss\").withZone(ZoneId.systemDefault());\n            position.setTime(LocalDateTime.parse(dateTimeActualStr, DateTimeFormatter.ofPattern(\"yyyy/MM/dd HH:mm:ss\")).atZone(ZoneId.systemDefault()).toInstant().toEpochMilli());\n        } catch (Exception e) {\n            // Handle invalid date strings\n            position.setTime(null);\n        }\n    }\n\n    try {\n        position.setLatitude(Double.parseDouble(entries.get(\"latitude\")));\n        position.setLongitude(Double.parseDouble(entries.get(\"longitude\")));\n        position.setAltitude(Double.parseDouble(entries.get(\"altitude\")));\n        \n        double velocityKph = Double.parseDouble(entries.get(\"velocity\"));\n        position.setSpeed(velocityKph * 1000 / 3600); // Convert km/h to m/s\n\n        position.setCourse(Integer.parseInt(entries.get(\"heading\")));\n        position.set(Position.KEY_EVENT, Integer.parseInt(entries.get(\"eventid\")));\n        position.set(Position.KEY_ODOMETER, (long) (Double.parseDouble(entries.get(\"mileage\")) * 1000));\n        position.set(Position.KEY_SATELLITES, Integer.parseInt(entries.get(\"satellites\")));\n        position.set(Position.KEY_IGNITION, Integer.parseInt(entries.get(\"ignition\")) != 0);\n        position.set(Position.KEY_DOOR, Integer.parseInt(entries.get(\"door\")) != 0);\n        position.set(Position.KEY_ARMED, Integer.parseInt(entries.get(\"arm\")) != 0);\n        position.set(Position.KEY_FUEL_LEVEL, Integer.parseInt(entries.get(\"fuel\")));\n        position.set(Position.KEY_RPM, Integer.parseInt(entries.get(\"rpm\")));\n        position.set(Position.KEY_POWER, Double.parseDouble(entries.get(\"main_voltage\")));\n        position.set(Position.KEY_BATTERY, Double.parseDouble(entries.get(\"backup_voltage\")));\n\n        for (int i = 1; i <= 3; i++) {\n            String analogKey = \"analog\" + i;\n            if (entries.containsKey(analogKey)) {\n                position.set(Position.PREFIX_ADC + i, Double.parseDouble(entries.get(analogKey)));\n            }\n        }\n\n        // Set any remaining keys directly\n        for (Map.Entry<String, String> entry : entries.entrySet()) {\n            if (!entry.getKey().startsWith(\"analog\")) {\n                position.set(entry.getKey(), entry.getValue());\n            }\n        }\n    } catch (NumberFormatException e) {\n        // Handle invalid number formats, possibly set default values or mark position as invalid\n    }\n\n    return position;\n}",
    "exact_match": false,
    "ast_match": false,
    "compile": null,
    "test": false
}